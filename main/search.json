[{"path":"https://openpharma.github.io/crmPack/articles/crmPack-jss-paper.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"Model-based dose escalation designs gained increasing interest due need efficient informative Phase trials. wide-spread implementation designs hindered need either licensing specialized commercial software programming design simulations scratch project. R-package crmPack provides simple unified object-oriented framework model-based dose escalation designs. enables standard use designs, able flexibly adapt extend . framework comprises classes methods data structure including dose grid, statistical models including prior specification, rules maximum increments, next best dose, adaptive stopping cohort sizes. addition multiple modified classic continual reassessment method escalation overdose control designs possibly advanced prior specifications (e.g., minimal informative mixture priors), crmPack currently features dual-endpoint (safety biomarker) designs two-part designs. Optional assignment small number patients cohort placebo instead treatment enables use trials outside Oncology. Keywords: continual reassessment method, model based dose escalation, dual-endpoint design, R, object oriented.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/crmPack-jss-paper.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"Phase trials testing new investigational agents humans first time escalate low high doses sequential fashion. dose escalation design necessary order reduce risk high therefore toxic doses probands. can either healthy volunteers (e.g., neurology) patients (e.g., oncology), henceforth use latter ease presentation. higher doses agents usually expected deliver stronger pharmacodynamic effects hence improved efficacy, higher doses also usually cause severe adverse events patients. order simplify decision making usually binary dose-limiting toxicities (DLTs) defined (e.g., adverse events reaching specific severity levels) starting trial. maximum tolerated dose (MTD) defined dose certain probability DLTs (either using single value, e.g., 33%, range, e.g., 20 35%). Historically, patients treated dose cohorts three, dose next cohort determined number DLTs observed current cohort. Algorithmic designs like simple 3+3 design (Carter 1973) disadvantages recognized statistics community, see e.g., (Paoletti, Ezzalfani, Le Tourneau 2015). Fundamentally, escalation rules 3+3 design statistical justification (Storer 1989) terms estimating MTD. Moreover, extended address today’s Phase trials, extension cohorts, dose escalation drug combinations optimal biological dose determination, naming just prominent challenges. Hence model-based dose escalation designs like continual reassessment method (CRM) (O’Quigley, Pepe, Fisher 1990) gained increasing interest due need efficient informative Phase trials. designs based statistical inference, dose-toxicity regression models backbone, therefore flexible adaptation various complex trial designs. Importantly, avoid fixing dose levels advance. wider comparison algorithmic model based designs see e.g., (Jaki, Clive, Weir 2013). However, wide-spread implementation designs hindered need either licensing specialized commercial software (thus losing flexibility) programming design simulations scratch project (thus losing efficiency). models underlying model-based dose escalation procedures can easily fit standard software capability fit generalized linear models, e.g., PROC MIXED SAS ( Institute Inc. 2003), glm Stata (StataCorp 2015) R ( Core Team 2016), still software solutions available dedicated dose escalation studies. commercial packages East (Cytel Inc. 2016) ADDPLAN (ICON Plc 2016) offer extensions basic design software dose escalation studies (ESCALATE East df ADDPLAN) implementing algorithmic 3+3 design various versions CRM. Similarly FACTS (FACTS Development Team 2015) also offers different common dose escalation methods. Due commercial nature implementations , however, limitation much designs can tailored towards individual needs study. Similarly static implementations methods dose escalation available Stata module crm (Mander 2013) implements CRM dfcrm package (K. Cheung 2013) R additionally implements time--event CRM (TITE-CRM) (Y. K. Cheung Chappell 2000). Several R-packages extensions available. bcrm package (M. Sweeting, Mander, Sabin 2013) implements variety one two parameter models, facilitates different ways specify prior distributions, escalation stopping rules. ordcrm package (Dressler Huang 2016) implements ordinal proportional odds continuation ratio models CRMs. dfpk package (Toumazi, Ursino, Zohar 2017) uses pharmacokinetic data dose escalation. paper introduce R-package crmPack (Sabanes Bove et al. 2018) dose escalation studies, publicly available CRAN. package’s name pays tribute original CRM first model-based dose escalation design, package’s functionality differs existing implementations three fundamental ways. Firstly, written using S4 classes methods (Chambers 2008), allows customized methodology added package still able use existing backbone functionalities. Secondly, methods studies placebo group (e.g., healthy volunteer studies) readily implemented. Thirdly, dual endpoint dose escalation methods incorporate safety efficacy allow determination optimal biological dose already available.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/crmPack-jss-paper.html","id":"framework","dir":"Articles","previous_headings":"","what":"Framework","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"describing framework package adapt general notation early phase trials (Thall 2010). Figure @ref(fig:schematic) summarizes framework schematic. Schematic framework Separate design features implemented classes (shown gray boxes) bundled together overarching Design object. can processed various methods (blue text) run dose escalation trial produce results (blue boxes). example, Data GeneralModel objects can processed mcmc method order obtain posterior samples model parameters, given sample size dose next cohort, updated Data closes dose escalation loop. higher level, designs can investigated examine simulate methods obtain hypothetical trial courses operating characteristics, respectively. Note individual model classes methods shown clarity, please refer package documentation details, e.g., calling crmPackHelp().’ Data Let xx denote one specific treatment, chosen set possible treatments ${\\cal X}$. one specific dose, also generally vector, containing example doses multiple drugs combination trial. giving treatment xx patient, outcome yy observed, typically safety endpoint e.g., binary DLT y∈{0,1}y \\\\{0, 1\\}. Grouping together njn_{j} patients cohort jj, generating cohort jj data ${\\cal C}_{j} = \\{(x_{j}, y_{j,1}), \\dotsc, (x_{j}, y_{j,n_{j}})\\}$, can denote data generated first NN cohorts ${\\cal D}_{N}= {\\cal C}_{1} \\cup \\dotsb \\cup {\\cal C}_{N}$. crmPack S4 class GeneralData encapsulates notion subclasses implement concrete data structures. Model core model-based dose escalation designs underlying statistical model. Taking Bayesian approach inference, model crmPack consists firstly likelihood, either probability density function f(y|x,θ) f(y | x, \\theta) probability mass function Prob(Y=y|x,θ) Prob(Y=y | x, \\theta) yy patient receives treatment xx assuming parameter (vector) θ\\theta, (likelihood θ\\theta) secondly prior p(θ|ξ) p(\\theta | \\xi) θ\\theta given fixed hyperparameters ξ\\xi. crmPack virtual S4 class GeneralModel encapsulates notion subclasses implement concrete models. example, class LogisticLogNormal implements logistic regression model (Neuenschwander, Branson, Gsponer 2008) logit(Prob(Y=1|x,θ))≡logit(π(x,θ))=α0+α1log⁡(xx*),\\begin{equation} \\label{eq:LogisticLogNormal} \\mathrm{logit}(Prob(Y=1 | x,\\theta)) \\equiv \\mathrm{logit}(\\pi(x,\\theta)) = \\alpha_{0} + \\alpha_{1} \\log\\left(\\frac{x}{x^*}\\right), \\end{equation} parameter vector θ=(α0,α1)\\theta = (\\alpha_{0},\\alpha_{1}), dose x>0x > 0 specified reference dose x*x^{*}. prior p(θ|ξ)p(\\theta | \\xi) specified via bivariate normal distribution transformation θ\\theta ensure α1>0\\alpha_{1} > 0: (α0,log⁡(α1))|ξ∼𝒩2(μ,Σ)\\begin{equation}   \\label{eq:bivariateNormal}   (\\alpha_{0}, \\log(\\alpha_{1})) | \\xi \\sim \\mathcal{N}_{2} (\\mu, \\Sigma) \\end{equation} hyperparameters ξ=(μ,Σ)\\xi = (\\mu, \\Sigma) consisting prior mean vector μ\\mu prior covariance matrix Σ\\Sigma. Decision making next dose Another core element dose escalation design concerns decision making next dose xN+1x_{N+1} tested next cohort N+1N+1. (Thall 2010) notation, function α\\alpha mapping currently accumulated data 𝒟N\\mathcal{D}_{N} dose space 𝒳\\mathcal{X} (dose 00, meaning stop trial doses toxic): $$\\begin{equation} \\alpha: {\\cal D}_{N} \\rightarrow \\mathcal{X} \\cup \\{0\\} \\end{equation}$$ mapping commonly specified via combination two elements: first element function τ\\tau maximum increments dose levels, can calculate current data 𝒟N\\mathcal{D}_{N} (including current dose xNx_{N}) maximum possible next dose tN+1=τ(𝒟N)t_{N+1}=\\tau(\\mathcal{D}_{N}) next cohort. second element rule ν\\nu indirectly acting current data posterior distribution p(θ|𝒟N)p(\\theta | \\mathcal{D}_{N}) maximum possible dose tN+1t_{N+1} finally give next dose xN+1=ν(p(θ|𝒟N),tN+1)x_{N+1} = \\nu(p(\\theta | \\mathcal{D}_{N}), t_{N+1}). crmPack maximum increments specified subclasses Increments, next best dose rule subclasses NextBest. design class Additional features design concern adaptive sizing next cohort adaptive stopping trial. implemented subclasses CohortSize Stopping, respectively. Moreover, starting dose x1x_{1} also feature design. Finally, overall dose escalation design bundling described features together dedicated class typically inheriting Design. noted (Thall 2010), operating characteristics complex dose escalation design can evaluated simulations. can done using simulate methods design classes, recommended performed multitude different scenarios order stress-test design convince oneself properties. particular, operating characteristics reveal whether MTD can estimated well designs. addition, examine method evaluates hypothetical trial outcomes lists resulting trial decisions (dose next cohort trial end). order illustrate use object-oriented framework, next section contains practical examples use existing functionality well example creating new extensions.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/crmPack-jss-paper.html","id":"using-crmpack","dir":"Articles","previous_headings":"","what":"Using crmPack","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"consider trial Type II diabetes carried Hoffmann-La Roche Ltd. order illustrate functionality package. patient, observed binary safety (DLT) continuous efficacy outcome. Implementing CRM trial show implement CRM design dose escalation based safety endpoint , Dose escalation safety efficacy also efficacy endpoint considered. Extending crmPack functionality gives example extending crmPack functionality. start, install subsequently load package R: indicated startup message, try crmPackHelp() crmPackExample() open help page package vignette.","code":"library(\"crmPack\") ## Loading required package: ggplot2 ## Registered S3 method overwritten by 'crmPack': ##   method       from   ##   print.gtable gtable ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example"},{"path":"https://openpharma.github.io/crmPack/articles/crmPack-jss-paper.html","id":"implementing-a-crm-trial","dir":"Articles","previous_headings":"Using crmPack","what":"Implementing a CRM trial","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"Suppose 12 dose levels ranging 25 300 mg 25 mg increments novel agent available addition placebo, defining dose grid 𝒳={0.001,25,50,…,300}\\mathcal{X} = \\{0.001,25, 50,\\dotsc, 300\\}, x1=0.001x_{1} = 0.001 mg representing placebo x2=25x_{2} = 25 starting dose. Note used small dose instead zero x1x_{1}, since consider regression model @eqref(eq:LogisticLogNormal) log transformation dose xx (x*=100x^{*} = 100 chosen reference dose). Minimally informative prior assume limited prior information available dose-toxicity relationship, hence like use minimally informative prior (Neuenschwander, Branson, Gsponer 2008) can easily obtained function MinimalInformative. Since stochastic optimization used internally, setting seed required reproducibility. Furthermore, recommended specify coarse dose grid across original dose range (excluding placebo dose) avoid long computation time: resulting model (object class LogisticLogNormal) prior parameters μ=(0.0720313,2)\\mu = (0.0720313, 2) Σ=(1.510.180.180.21)\\Sigma=  \\left(\\begin{smallmatrix}    1.51 & 0.18 \\\\    0.18 & 0.21  \\end{smallmatrix}\\right) approximately 5% probability DLT rate exceed 10% (threshmin argument) 25 mg dose 20% (threshmax) 300 mg dose. Data object definition visualization simple case univariate dose xx resulting binary DLT observations yy, S4 class Data can used. Objects class can created calling accompanying initialization function name (general convention crmPack): argument x takes doses x1=0.001,x2=25,x3=50,x4=100x_{1}=0.001, x_{2}=25, x_{3} = 50, x_{4} = 100 (note repetition match outcome variables yj,ky_{j,k}) doseGrid captures set ${\\cal X}$ possible doses, y takes binary DLTs (y3,3=1y_{3, 3} = 1 denotes DLT observed 3rd patient 3rd cohort), cohort groups patients together cohorts (N=3N=3). option placebo used specify placebo controlled study, placebo patients included cohort. lowest dose x1x_{1} interpreted internally placebo dose. Patient IDs can given optionally ID argument. data can visualized simply applying plot function object, also allows produce blinded plot (hiding patient IDs placebo/treatment assignment) option blind, see Figure @ref(fig:plot-data): Open blinded data plots Open blinded data plots Sampling prior posterior Now model data place, can use MCMC sampling obtaining posterior distribution model parameters θ\\theta, hence DLT rates Prob(Y=1|x,θ)Prob(Y=1 | x,\\theta), various doses xx. MCMC sampling can controlled object class McmcOptions, provided mcmc function, together data model objects: posterior mean curve 95% equi-tailed credible interval curves DLT rates can obtained supplying samples, model data generic plot function. Similarly can also produce similar plot without data, giving prior, see Figure @ref(fig:plot-model-fit): Posterior prior regression model fits illustrated , plots can customized using ggplot2(Wickham 2009) functionality. can see posterior mean estimate (left panel, continuous line) slightly steeper prior mean estimate curve (right panel, continuous line), posterior uncertainty reduced due data (smaller credible intervals, dashed lines). Decision making next dose determine dose administer next (cohort ) patients begin specifying maximum increments function τ\\tau. example maximum increase 100% doses 100 mg, 50% doses range 100 mg 200 mg, 33% doses equal 200 mg specified using class IncrementsRelative: specific rule τ\\tau can evaluated current dataset ${\\cal D}_{N}$ maxDose function obtain maximum next dose $t_{N+1} = \\tau({\\cal D}_{N})$: define function ν\\nu selecting dose next cohort. case like select dose maximizes probability DLT rate target toxicity range 20% 35%, probability overdosing exceeding 25% (Neuenschwander, Branson, Gsponer 2008), using NextBestNCRM class: rule can evaluated function NextBest obtain next dose $x_{N+1}=\\nu({\\cal D}_{N}, t_{N+1})$: returned list also contains accompanying plot (nextDoseRes$plot), see Figure @ref(fig:nextBest-ncrm). Dose recommendation plot NCRM design Adaptive stopping trial like stop dose escalation adaptively maximum sample size n=30n=30 patients reached already, sufficient precision MTD estimate. can specify latter condition follows: probability next dose xN+1x_{N+1} target toxicity range 50%, least 9 patients already dosed within +/- 20% range xN+1x_{N+1}. corresponding Stopping class object constructed combining atomic rules logical operators follows: , specific rule can evaluated function, called stopTrial, specific situation: result FALSE means yet stop trial, attribute message giving results atomic stopping rules. Examine dose escalation design last topic section, want show assess performance given CRM design. first need specify design creating object class Design. contains model, rules dose escalation (Increments, NextBest, Stopping CohortSize), dose grid (example object emptydata) starting dose (see also Figure @ref(fig:schematic). case use fixed cohort size 3 patients active 1 patient placebo (``3+1’’) throughout study: can start looking single trial operating characteristics dose escalation design function examine, generates data frame showing beginning several hypothetical trial courses design. Assuming DLTs seen certain dose, consequences different number DLTs observed dose shown. example, observe 3 DLTs starting dose 25 mg, need stop trial, enroll another cohort dose level case 2 DLTs. last rows output see DLTs observed 250 mg cohort, maximum considered dose 300 mg dose can reached next cohort also DLTs observed 250 mg. 1, 2 3 DLTs observed, next dose recommended 225, 175 150 mg, respectively. Simulating operating characteristics many trials operating characteristics, first define true scenarios, data arise. case, requires function computes probability DLT given dose. example use function contained slot prob object model: %, dose-toxicity curve shown . Note possible R-function returning vector probabilities upon input dose vector can used. particular, trivially possible directly specify probability DLT dose order examine operating characteristics based statistical model. example, assume 5 doses 1–5 probabilities DLT 0.01, 0.02, 0.04, 0.06, 0.09, following code used: Now can proceed simulations using function simulate: number simulated trials depends required accuracy results. argument parallel can set TRUE one wishes run iterations parallel processors computer, can yield meaningful speedup. needed 201 seconds 100 simulated trials Intel Core i5-6300U CPU 2.4 GHz. result object class Simulations containing multiple slots, e.g., data slot containing list simulated trials. slots doses stopReasons contain information final MTD stopping reason trial. can e.g., investigate number patients MTD end third simulated trial: Furthermore, can plot Simulations object calling plot method , see Figure @ref(fig:sim-plot). can select plots changing type argument plot, default type = c(\"trajectory\", \"dosesTried\"). Simulation plot Second, can summarize simulation results, obtain textual description results: Simulation summary plot","code":"coarseGrid <- c(25, 50, 100, 200, 300) model <- MinimalInformative(   dosegrid = coarseGrid, refDose = 100,   logNormal = TRUE, threshmin = 0.1,   threshmax = 0.2, seed = 432,   control = list(max.time = 30) )$model PL <- 0.001 data <- Data(   x = c(PL, 25, 25, 25, PL, 50, 50, 50, PL, 100, 100, 100),   y = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3),   doseGrid = c(PL, seq(25, 300, 25)),   ID = 1:12,   placebo = TRUE ) plot(data) plot(data, blind = TRUE) options <- McmcOptions(burnin = 1000, step = 2, samples = 10000) set.seed(94) samples <- mcmc(data, model, options) plot(samples, model, data) + ggtitle(\"Posterior\")  emptydata <- Data(doseGrid = data@doseGrid, placebo = TRUE) priorsamples <- mcmc(emptydata, model, options) plot(priorsamples, model, emptydata) + ggtitle(\"Prior\") myIncrements <- IncrementsRelative(   intervals = c(0, 100, 200),   increments = c(1, 0.5, 0.33) ) (nextMaxDose <- maxDose(myIncrements, data)) ## [1] 150 myNextBest <- NextBestNCRM(   target = c(0.2, 0.35), overdose = c(0.35, 1),   max_overdose_prob = 0.25 ) nextDoseRes <- nextBest(myNextBest, nextMaxDose, samples, model, data) (nextDoseVal <- nextDoseRes$value) ## [1] 100 myStopping1 <- StoppingMinPatients(nPatients = 30) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) myStopping3 <- StoppingPatientsNearDose(nPatients = 9, percentage = 20) myStopping <- myStopping1 | (myStopping2 & myStopping3) stopTrial(myStopping, nextDoseVal, samples, model, data) ## [1] FALSE ## attr(,\"message\") ## attr(,\"message\")[[1]] ## [1] \"Number of patients is 12 and thus below the prespecified minimum number 30\" ##  ## attr(,\"message\")[[2]] ## attr(,\"message\")[[2]][[1]] ## [1] \"Probability for target toxicity is 33 % for dose 100 and thus below the required 50 %\" ##  ## attr(,\"message\")[[2]][[2]] ## [1] \"3 patients lie within 20% of the next best dose 100. This is below the required 9 patients\" ##  ##  ## attr(,\"individual\") ## attr(,\"individual\")[[1]] ## [1] FALSE ## attr(,\"message\") ## [1] \"Number of patients is 12 and thus below the prespecified minimum number 30\" ## attr(,\"report_label\") ## [1] \"≥ 30 patients dosed\" ##  ## attr(,\"individual\")[[2]] ## [1] FALSE ## attr(,\"message\") ## attr(,\"message\")[[1]] ## [1] \"Probability for target toxicity is 33 % for dose 100 and thus below the required 50 %\" ##  ## attr(,\"message\")[[2]] ## [1] \"3 patients lie within 20% of the next best dose 100. This is below the required 9 patients\" ##  ## attr(,\"individual\") ## attr(,\"individual\")[[1]] ## [1] FALSE ## attr(,\"message\") ## [1] \"Probability for target toxicity is 33 % for dose 100 and thus below the required 50 %\" ## attr(,\"report_label\") ## [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\" ##  ## attr(,\"individual\")[[2]] ## [1] FALSE ## attr(,\"message\") ## [1] \"3 patients lie within 20% of the next best dose 100. This is below the required 9 patients\" ## attr(,\"report_label\") ## [1] \"≥ 9 patients dosed in 20 % dose range around NBD\" ##  ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"report_label\") ## [1] NA mySize <- CohortSizeConst(3) mySizePL <- CohortSizeConst(1)  design <- Design(   model = model, nextBest = myNextBest,   stopping = myStopping, increments = myIncrements,   cohort_size = mySize, pl_cohort_size = mySizePL,   data = emptydata, startingDose = 25 ) set.seed(23) examine(design, mcmcOptions = options) ##    dose DLTs nextDose  stop increment ## 1    25    0       50 FALSE       100 ## 2    25    1       50 FALSE       100 ## 3    25    2       25 FALSE         0 ## 4    25    3       NA FALSE        NA ## 5    50    0      100 FALSE       100 ## 6    50    1       75 FALSE        50 ## 7    50    2       50 FALSE         0 ## 8    50    3       25 FALSE       -50 ## 9   100    0      125 FALSE        25 ## 10  100    1      100 FALSE         0 ## 11  100    2       75 FALSE       -25 ## 12  100    3       50 FALSE       -50 ## 13  125    0      175 FALSE        40 ## 14  125    1      125 FALSE         0 ## 15  125    2      100 FALSE       -20 ## 16  125    3       75 FALSE       -40 ## 17  175    0      250 FALSE        43 ## 18  175    1      150 FALSE       -14 ## 19  175    2      125 FALSE       -29 ## 20  175    3      100 FALSE       -43 ## 21  250    0      300 FALSE        20 ## 22  250    1      225 FALSE       -10 ## 23  250    2      175 FALSE       -30 ## 24  250    3      150 FALSE       -40 myTruth <- probFunction(model, alpha0 = 4.5, alpha1 = 8) doseProbMatrix <- cbind(c(1, 2, 3, 4, 5), c(0.01, 0.02, 0.04, 0.06, 0.09)) myTruthMatrix <-   function(dose) {     doseProbMatrix[match(dose, doseProbMatrix[, 1]), 2]   } mySimsTime <-   system.time(mySims <- simulate(design,     truth = myTruth, nsim = 100,     seed = 819, mcmcOptions = options,     parallel = FALSE   ))[3] mySims@data[[3]]@nObs ## [1] 32 mySims@doses[3] ## [1] 25 ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## ℹ The deprecated feature was likely used in the crmPack package. ##   Please report the issue at <https://github.com/openpharma/crmPack/issues>. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. simSum <- summary(mySims, truth = myTruth) simSum ## Summary of 100 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 47.9, 52.7  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients on placebo : mean 7 (6, 8)  ## Number of patients on active : mean 22 (18, 24)  ## Number of patients overall : mean 30 (24, 32)  ## Number of patients treated above target tox interval : mean 3 (0, 3)  ## Proportions of DLTs in the trials for patients on placebo : mean 0 % (0 %, 0 %)  ## Proportions of DLTs in the trials for patients on active : mean 28 % (21 %, 33 %)  ## Mean toxicity risks for the patients on active : mean 27 % (18 %, 33 %)  ## Doses selected as MTD : mean 46.2 (25, 50)  ## True toxicity at doses selected : mean 22 % (0 %, 26 %)  ## Proportion of trials selecting target MTD: 85 % ## Dose most often selected as MTD: 50  ## Observed toxicity rate at dose most often selected: 26 % ## Fitted toxicity rate at dose most often selected : mean 23 % (17 %, 30 %)  ## Stop reason triggered: ##  ≥ 30 patients dosed :  66 % ##  P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5 :  45 % ##  ≥ 9 patients dosed in 20 % dose range around NBD :  98 %"},{"path":"https://openpharma.github.io/crmPack/articles/crmPack-jss-paper.html","id":"dose-escalation-with-safety-and-efficacy","dir":"Articles","previous_headings":"Using crmPack","what":"Dose escalation with safety and efficacy","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"section, dose escalation designs incorporating safety (binary DLT) efficacy endpoints (continuous response) introduced. Dual endpoint datasets implemented DualData class, illustrate addition efficacy data w previous dataset: endpoints can modelled jointly separately. joint modelling derived (Bekele Shen 2005), please see package vignette DualEndpoint class. following section describe separate modelling, proposed (Yeung et al. 2015). show dual endpoint design can help estimate optimal dose level represents best trade-safety efficacy. Methodology Briefly introducing methodology current notation, assume dose grid $\\cal{X}$ contains kk dose levels, logistic regression model @ x*=1x^{*}=1 used safety endpoint yy. continuous efficacy endpoint ww, linear log-log model can used, conditional y=0y=0 (DLT): E(w(x))=γ+δlog⁡{log⁡(x+c)}\\begin{equation}\\label{eq:loglog} E(w(x)) = \\gamma + \\delta \\log\\{\\log(x + c)\\} \\end{equation} w(x)∼N(E(w(x)),σ2)w(x) \\sim N(E(w(x)), \\sigma^2) c≥0c \\geq 0 constant. Usually default value c=0c=0 can used, case choose c=2c=2 allow placebo dose x=0.001x=0.001 close 0. safety efficacy models, prior expressed form imaginary pseudo data see (Yeung et al. 2015) details. Prior posterior modal estimates model parameters can obtained maximum likelihood estimates data set combining pseudo data observed data (Whitehead 2006). variance σ2\\sigma^{2} can fixed assigned inverse gamma prior distribution. Model classes ModelPseudo class contains model classes priors specified terms pseudo data, subclasses safety (ModelTox) efficacy (ModelEff). Coming back example study, pseudo data safety prior assumes 3 subjects treated lowest (25 mg) highest (300 mg) dose level, 1.05 1.8 DLTs observed two dose levels, respectively. corresponds prior means 0.35 0.6 DLT probabilities. implement model @ pseudo data prior follows: efficacy model can similarly specified argument Eff takes vector pseudo efficacy responses two fixed dose levels, assuming one subject treated dose levels. argument nu specifies Gamma prior distribution shape 1 rate 0.025 precision parameter pseudo efficacy responses. Decision making next dose gain function used quantify trade-efficacy safety, next dose maximize estimated gain modulo safety constraints. define gain expected efficacy response, convention DLT automatically lead zero efficacy response: G(x)=Prob(Y=0|x,θ)E(w(x))\\begin{equation} \\label{eq:gainfunction} G(x)=Prob(Y=0 | x, \\theta)E(w(x)) \\end{equation} Note gain function depends safety parameter vector θ\\theta efficacy parameters γ\\gamma δ\\delta, estimated posterior modal estimates using update method: crmPack can implement next best dose recommendation based maximizing gain function follows: prob_target_drt specifies maximum estimated DLT rate tolerated study prob_target_eot maximum estimated DLT rate tolerated end study. Implementing CRM trial rule ν\\nu can evaluated using NextBest obtain xN+1x_{N+1}, evaluating maximum increments rule τ\\tau using maxDose obtain tN+1t_{N+1}: plot next dose allocation contained doseRecGain$plot shown Figure @ref(fig:doseRecommendation). \\begin{figure} Dose recommendation plot dual endpoint design. red, blue green curves correspond (posterior modal) estimated curves safety, efficacy gain, respectively. vertical red line plot shows maximum possible dose tN+1=150t_{N+1} = 150 mg vertical violet line shows next dose xN+1=25x_{N+1} = 25 mg. circle, square triangle symbols mark estimated doses target toxicity (100 mg 35% DLT probability trial 75 mg 30% DLT probability end trial) estimated dose maximum gain, 25 mg. numbers can obtained doseRecGain list. Stopping rules addition simple stopping rule based maximum number patients trial, can use another one relating precision dose optimum gain: stops trial 30 patients reached, ratio upper lower confidence interval bounds around dose recommendation less  5. Simulations simulate operating characteristics, first design built: Note additional slot efficacy model included design class. can specify scenario simulation, defining true DLT efficacy curves using: Please note parameter names phi1, phi2, theta1 theta2 correspond α0,α1,γ\\alpha_0, \\alpha_1, \\gamma δ\\delta, respectively. Simulations produced simulate function: Note fixed precision nu 1/σ21/\\sigma^{2} specified instead variance σ2\\sigma^{2}. % results simulation can plotted summarized shown .","code":"data2 <- DataDual(   x = data@x, y = data@y, placebo = TRUE,   w = c(     0.02, 0.42, 0.59, 0.45, 0.03, 0.7, 0.6, 0.52,     0.01, 0.71, 0.54, 0.45   ), cohort = data@cohort,   doseGrid = data@doseGrid, ID = data@ID ) DLTmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8), DLEweights = c(3, 3),   DLEdose = c(25, 300), data = emptydata ) emptydata2 <- DataDual(doseGrid = emptydata@doseGrid, placebo = TRUE) Effmodel <- Effloglog(   eff = c(1.223, 2.513), eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025), data = emptydata2, c = 2 ) newDLTmodel <- update(object = DLTmodel, data = data2) newEffmodel <- update(object = Effmodel, data = data2) GainNextBest <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 ) (nextMaxDose <- maxDose(myIncrements, data2)) ## [1] 150 doseRecGain <- nextBest(GainNextBest,   doselimit = nextMaxDose,   model = newDLTmodel, model_eff = newEffmodel,   data = data2 ) (nextDoseVal <- doseRecGain$next_dose) ## [1] 25 myStopping4 <- StoppingMaxGainCIRatio(   target_ratio = 5,   prob_target = GainNextBest@prob_target_eot ) myStoppingDual <- myStopping1 | myStopping4 design2 <- DualResponsesDesign(   nextBest = GainNextBest, model = DLTmodel,   eff_model = Effmodel, data = emptydata2,   stopping = myStoppingDual,   increments = myIncrements,   cohort_size = mySize, startingDose = 25 ) myTruthDLT <- probFunction(DLTmodel, phi1 = -53, phi2 = 10) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.8, theta2 = 3.7) myTruthGain <- function(dose) {   myTruthEff(dose) * (1 - myTruthDLT(dose)) } Sim1 <- simulate(   object = design2, args = NULL, trueDLE = myTruthDLT,   trueEff = myTruthEff, trueNu = 1 / 0.025, nsim = 20,   seed = 819, parallel = FALSE )"},{"path":"https://openpharma.github.io/crmPack/articles/crmPack-jss-paper.html","id":"extending-crmpack-functionality","dir":"Articles","previous_headings":"Using crmPack","what":"Extending crmPack functionality","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"One big advantages crmPack existing R implementations flexible framework based S4 classes methods system (Chambers 2008) JAGS (Plummer 2003) Bayesian computations. therefore illustrate users can extend existing functionality easily specific needs study. Objective example implement version one-parameter CRM (O’Quigley, Pepe, Fisher 1990), currently (yet) included package. based one-parameter power model describe relationship binary DLT responses YY corresponding dose levels xx: π(x,θ)=Prob(Y=1|x,θ)=f(x)θ\\begin{equation} \\label{eq:oneparameter} \\pi(x, \\theta) = Prob(Y=1 | x, \\theta) = f(x)^{\\theta} \\end{equation} 0<f(x)<10 < f(x) < 1 monotonically increasing xx specified investigator upfront. sequence f(x1),…,f(xk)f(x_{1}), \\dotsc, f(x_{k}) along dose grid often called ``skeleton’’ CRM. exponential distribution parameter λ\\lambda imposed prior distribution unknown parameter θ\\theta. next dose chosen distance posterior mean estimated DLT probability predefined target toxicity level minimized. Creating new model implement one-parameter model @ crmPack first need define appropriate S4 class inheriting general model class GeneralModel: specify new class called OneParExp contains three additional slots containing resulting skeleton prior probabilities, dose grid, prior parameter λ\\lambda. Second create convenient initialization function, specifies likelihood prior distributions underlying GeneralModel JAGS. choose let user supply just skeleton probabilities along intended dose grid use. likelihood power model specified datamodel uses Data slots specified datanames. prior defined priormodel. Model parameters passed JAGS via modelspecs. init slot contains function giving starting values MCMC sampler, sample defines parameter samples returned: Finally, create dose prob methods. prob method based (skeleton) function interpolation dose grid points order obtain probability DLT. dose, hand, uses inverse (skeleton) function π−1(p,θ)=f−1(p1/θ)\\begin{equation} \\label{eq:oneparameterInverse} \\pi^{-1}(p, \\theta) = f^{-1}(p^{1/\\theta}) \\end{equation} maps probability pp dose xx. Now can already use model, example following specify skeleton probabilities via dose grid use standard exponential prior θ\\theta. resulting posterior fit can plotted usual, see Figure @ref(fig:OneParExp-model-example). Model fit one parameter power model Creating new dose recommendation rule second step like create new dose recommendation rule, proposes dose estimated DLT probability closest target. start class, now inheriting NextBest: Note keep convention separate class definition initialization function, although technical need case. order make usable need define NextBest method new rule. Note specialize method first argument, rule also used models. method definition, can use fit function order obtain estimated DLT rates. need return list method, since required generic function definition. advantage also include plot supporting information return value. Immediately can now use rule order obtain next dose recommendation, e.g., specifying target dose 30%: using CRM, escalate 150 mg, instead just 100 mg . Using new functionality necessary additions code needed implement one-parameter CRM greedy next best dose rule - now can use new classes way classes already contained crmPack! example, can create corresponding new Design object, examine hypothetical trial course run simulations. particular, placebo convention automatically carries .","code":".OneParExp <- setClass(   Class = \"OneParExp\",   contains = \"GeneralModel\",   slots = c(     skeleton_probs = \"numeric\",     dose_grid = \"numeric\",     lambda = \"numeric\"   ) ) OneParExp <- function(skeleton_probs, dose_grid, lambda) {   .OneParExp(     skeleton_probs = skeleton_probs,     dose_grid = dose_grid,     lambda = lambda,     datamodel = function() {       for (i in 1:nObs) {         y[i] ~ dbern(p[i])         p[i] <- skeleton_probs[xLevel[i]]^theta       }     },     priormodel = function() {       theta ~ dexp(lambda)     },     modelspecs = function() {       list(skeleton_probs = skeleton_probs, lambda = lambda)     },     init = function() {       list(theta = 1)     }, sample = \"theta\",     datanames = c(\"nObs\", \"y\", \"xLevel\")   ) } setMethod(   f = \"dose\",   signature = signature(     x = \"numeric\",     model = \"OneParExp\",     samples = \"Samples\"   ),   definition = function(x, model, samples) {     theta <- samples@data$theta     invSkeletonFun <- approxfun(x = model@skeleton_probs, y = model@dose_grid, rule = 1)     invSkeletonFun(x^(1 / theta))   } )  setMethod(   f = \"prob\",   signature = signature(     dose = \"numeric\",     model = \"OneParExp\",     samples = \"Samples\"   ),   definition = function(dose, model, samples) {     theta <- samples@data$theta     skeletonFun <- approxfun(x = model@dose_grid, y = model@skeleton_probs, rule = 2)     skeletonFun(dose)^theta   } ) (skeleton_probs <- round(data@doseGrid / max(data@doseGrid) / 2, 2)) ##  [1] 0.00 0.04 0.08 0.12 0.17 0.21 0.25 0.29 0.33 0.38 0.42 0.46 0.50 newModel <- OneParExp(   skeleton_probs = skeleton_probs,   dose_grid = data@doseGrid,   lambda = 1 ) newSamples <- mcmc(data, newModel, options) plot(newSamples, newModel, data) .NextBestMinDist <- setClass(   Class = \"NextBestMinDist\",   contains = \"NextBest\",   representation(target = \"numeric\") ) NextBestMinDist <- function(target) {   .NextBestMinDist(target = target) } setMethod(   \"nextBest\",   signature = signature(     nextBest = \"NextBestMinDist\",     doselimit = \"numeric\",     samples = \"Samples\",     model = \"OneParExp\",     data = \"Data\"   ),   def = function(nextBest, doselimit, samples, model, data, ...) {     dosesOK <-       if (length(doselimit)) {         which(data@doseGrid <= doselimit)       } else {         seq_along(data@doseGrid)       }     modelfit <- fit(samples, model, data)     probDLT <- modelfit$middle[dosesOK]     doses <- modelfit$dose[dosesOK]     bestIndex <- which.min(abs(probDLT - nextBest@target))     bestDose <- doses[bestIndex]     return(list(value = bestDose))   } ) newMyNextBest <- NextBestMinDist(target = 0.3) newNextDoseVal <- nextBest(newMyNextBest, nextMaxDose, newSamples, newModel, data)$value ## Warning in fortify(data, ...): Arguments in `...` must be used. ## ✖ Problematic arguments: ## • fill = \"grey50\" ## • colour = \"grey50\" ## ℹ Did you misspell an argument name? newNextDoseVal ## [1] 150"},{"path":"https://openpharma.github.io/crmPack/articles/crmPack-jss-paper.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"paper introduced R package crmPack analyzing evaluating dose escalation trials. Unlike existing software package written make full use class structure enabling easy extensions user-specific dose-response models, prior distributions, escalation stopping rules. example Extending crmPack functionality demonstrated : New functionality can added - without changing package. new functionality needs coded one place - side effects need considered. Templates new designs can found looking existing code package - minimal S4 JAGS knowledge required. Therefore, crmPack allows user easily extend package keeping modifications local limited needs changed, experience key success factor wider use model-based dose escalation designs. package , however, already include wide range model-based algorithmic dose escalation procedures, described package’s documentation available crmPackHelp() provide end-users easy access approaches without need coding. Another unique feature package inclusion approaches allow placebo data, routinely collected healthy volunteer studies, utilized. Finally methods [e.g.,](Bekele Shen 2005)(Yeung et al. 2015) dose-finding incorporating safety efficacy implemented already package. designs, underlying structure extend novel dual endpoint methods provided. Simulation facilities approaches relevant graphical displays also available. package actively developed new methods added. Future extensions crmPack include model-based combination dose escalation designs, see example (M. J. Sweeting Mander 2012) [Riviere et al. (2014) recent reviews. Furthermore, data-augmentation CRM designs [see](Liu Ning 2013) allow decoupling inter-cohort waiting times DLT time windows, hence speeding dose escalation trials, included.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/crmPack-jss-paper.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Model-based Dose Escalation Designs in R with crmPack (JSS manuscript)","text":"like thank Francesca Michielin Peter Dutton valuable comments earlier draft manuscript. report funded Roche Postdoctoral Fellowship programme (RPF-234) research arising Prof Jaki’s Senior Research Fellowship (NIHR-SRF-2015-08-001) supported National Institute Health Research. views expressed publication authors necessarily NHS, National Institute Health Research Department Health. manuscript prepared using knitr (Xie 2018).","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"crmPack: Object-oriented implementation of CRM designs","text":"Many models crmPack rely JAGS (please click link going webpage project) internal MCMC computations. WinBUGS required supported anymore.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"crmPack: Object-oriented implementation of CRM designs","text":"able run anything, load package browsing help pages package, easiest start web browser interface gives list help pages available package. whole R-package built modular form, using S4 classes methods. Please look help page “Methods” read introduction S4 object framework R, typing ?Methods R console. next sections therefore go one one important building blocks (S4 classes corresponding methods) CRM designs crmPack.","code":"library(crmPack) library(data.tree) crmPackHelp()"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"crmPack: Object-oriented implementation of CRM designs","text":"Data classes structure three data classes package. parent class GeneralData class. Data class inheriting GeneralData class DataDual class inheriting Data class. Inheritance means subclass slots (attributes) parent class, can also additional slots. Methods work parent class also work way subclass, unless specialized method subclass defined. First, set data set. beginning trial, observations available. can define empty data set, example: R-package crmPack uses S4 class system implementation dose-escalation designs. convention class initialization functions name class, class names capitalized. Note order create Data object, use initialization function name, give parameters contents object constructed. least doseGrid parameter, contains possible dose levels potentially used trial, must specified call Data() initialization function. middle trial like recommend next dose, data previous patients input model. data can also captured Data object. example: important x (doses) y (DLTs, 0 DLT 1 DLT), using dose grid doseGrid . computations using dose grid specified Data object. example, except patient number 7, patients free DLTs. , can find details help page Data-class. Note received warning , specify patient IDs – however, automatic ones just indexing patients created : can get visual summary data applying plot object:  Note plot calls vignette, can leave away wrapping print function call working interactively R. knitr production vignette print statement needed.","code":"df <- data.frame(   pathString = c(     \"GeneralData/Data/DataDual\"   ) )  tree <- as.Node(df) SetNodeStyle(tree, shape = \"box\") plot(tree) emptydata <- Data(   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ) ) data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ) ) ## Used default patient IDs! data@ID ## [1] 1 2 3 4 5 6 7 8 print(plot(data))"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"structure-of-the-model-class","dir":"Articles","previous_headings":"","what":"Structure of the model class","title":"crmPack: Object-oriented implementation of CRM designs","text":"Figure @ref(fig:model-classes) shows structure model class defined package. AllModels class parent class model classes inherit. two sub-classes: First, GeneralModel class models inherit using JAGS specify model prior distribution estimated MCMC later . , second subclass ModelPseudo class prior models specified terms pseudo data standard maximum likelihood routines R used computational purposes. models included package parent class either GeneralModel ModelPseudo classes. two classes ModelPseudo ModelTox class include DLT (occurrence dose-limiting toxicity) class models, class ModelEff includes efficacy class models. Model classes structure","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"logistic-model-with-bivariate-log-normal-prior","dir":"Articles","previous_headings":"Model setup","what":"Logistic model with bivariate (log) normal prior","title":"crmPack: Object-oriented implementation of CRM designs","text":"First, show example setting model inheriting model GeneralModel classes, logistic normal model. can click corresponding help page LogisticLogNormal-class background information next steps. following command, create new model class LogisticLogNormal, certain mean covariance prior parameters reference dose: can query class object belongs class function: can look detail structure model follows: see object 9 slots, names. can accessed @ operator (similarly lists $ operator), example can extract ref_dose slot: can find slots, looking help page Model-class help browser, univariate models JAGS specification just special cases (subclasses) model class. Model-class help page, also find four additional specific model classes sub-classes model class, namely LogisticLogNormalSub, LogisticNormal, LogisticKadane DualEndpoint. Next, show example setting model ModelPseudo class, LogisticIndepBeta model. specifically, also model ModelTox class. LogisticIndepBeta model two-parameter logistic regression model describe relationship probability occurrence DLT corresponding log dose levels. model parameters φ1, intercept φ 2, slope. also model prior expressed form pseudo data. important data set defined defining models ModelPseudo class. ensure obtained updated estimates model parameters using currently available observations. Either empty data set data set contains currently available observations needed. Therefore, let’s assume empty data set set . example, use 12 dose levels 25 300 mg increments 25 mg. : express prior form pseudo data. idea follows. First fix two dose level d(−1)d_{(-1)} d(0)d_{(0)}, usually lowest highest dose level, choose 25 300 mg. elicit experts clinicians probability occurrence DLT, p(−1)p_{(-1)} p(0)p_{(0)} two dose levels. , assuming n(l)n_{(l)} subjects treated two dose levels, l=−1,0l=-1,0, t(l)t_{(l)} n(l)n{(l)} subjects expected observed DLT p(l)=t(l)/n(l)p_{(l)} = t_{(l)}/n_{(l)}. Let p̃(l)\\tilde{p}_{(l)} probability occurrence DLT dose ll dose l=−1,0l=-1,0. p̃(l)\\tilde{p}_{(l)} follow independent Beta distributions joint probability density function p(l)p_{(l)} can obtained. Therefore, model called LogisticIndepBeta. expressed prior data (pseudo data) trial start. prior modal estimates φ1 φ2, also equivalent maximum likelihood estimators, can obtained R function glm. Please refer (Whitehead Williamson 1998) details form prior posterior density model parameters φ1 φ2. following commands, create model class LogisticIndepBeta, prior specified form pseudo data. (Note functions including initialization function, DLE instead DLT used. vignette use unified abbreviation DLT throughout text variable names.) model specified, fixed two dose levels (25 300 mg) represented DLEdose slot. assume 3 subjects treated dose levels, represented DLEweights slot. 1.05 subjects 3 subjects treated 25 mg observed DLT 1.8 subjects 3 subjects treated 300 mg observed DLT represented binDLE slot. Input Data slot also need ensure currently available observations incorporated model obtain updated modal estimates model parameters. empty data set used Data slot, prior modal estimates model parameters, φ1 intercept φ2 slope, can obtained. data set observations, e.g data1 DLTmodel used, can obtain posterior modal estimates model parameters. addition, pseudo data can expressed using 2 dose levels. hand, least two dose levels pseudo information needed obtain modal estimates intercept slope parameter. Therefore, binDLE,DLEweights, DLEdose must vectors least length 2 corresponding values specified position two vectors. Since imaginary nature pseudo data, value tlt_l number subjects observed DLT can non-integer values. principle, nln_l can also non-integer values. can look structure model: total 10 slots names given. Remember can accessed @ operator (similarly lists $ operator), example can extract phi1 slot: gives updated modal estimate intercept parameter φ1. Please find slots using @ operator looking help page ModelPseudo, ModelTox LogisticIndepBeta classes.","code":"model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 ) class(model) ## [1] \"LogisticLogNormal\" ## attr(,\"package\") ## [1] \"crmPack\" str(model) ## Formal class 'LogisticLogNormal' [package \"crmPack\"] with 9 slots ##   ..@ params         :Formal class 'ModelParamsNormal' [package \"crmPack\"] with 3 slots ##   .. .. ..@ mean: num [1:2] -0.85 1 ##   .. .. ..@ cov : num [1:2, 1:2] 1 -0.5 -0.5 1 ##   .. .. ..@ prec: num [1:2, 1:2] 1.333 0.667 0.667 1.333 ##   ..@ ref_dose       :Formal class 'positive_number' [package \"crmPack\"] with 1 slot ##   .. .. ..@ .Data: num 56 ##   ..@ datamodel      :function ()   ##   ..@ priormodel     :function ()   ##   ..@ modelspecs     :function (from_prior)   ##   ..@ init           :function ()   ##   ..@ datanames      : chr [1:3] \"nObs\" \"y\" \"x\" ##   ..@ datanames_prior: chr(0)  ##   ..@ sample         : chr [1:2] \"alpha0\" \"alpha1\" model@ref_dose ## An object of class \"positive_number\" ## [1] 56 emptydata <- Data(   doseGrid =     seq(from = 25, to = 300, by = 25) ) data1 <- emptydata DLTmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8), DLEweights = c(3, 3),   DLEdose = c(25, 300), data = data1 ) str(DLTmodel) ## Formal class 'LogisticIndepBeta' [package \"crmPack\"] with 7 slots ##   ..@ binDLE    : num [1:2] 1.05 1.8 ##   ..@ DLEdose   : num [1:2] 25 300 ##   ..@ DLEweights: int [1:2] 3 3 ##   ..@ phi1      : num -1.95 ##   ..@ phi2      : num 0.412 ##   ..@ Pcov      : num [1:2, 1:2] 10.05 -2.077 -2.077 0.462 ##   .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(x)\" ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(x)\" ##   ..@ data      :Formal class 'Data' [package \"crmPack\"] with 9 slots ##   .. .. ..@ x       : num(0)  ##   .. .. ..@ y       : int(0)  ##   .. .. ..@ doseGrid: num [1:12] 25 50 75 100 125 150 175 200 225 250 ... ##   .. .. ..@ nGrid   : int 12 ##   .. .. ..@ xLevel  : int(0)  ##   .. .. ..@ placebo : logi FALSE ##   .. .. ..@ ID      : int(0)  ##   .. .. ..@ cohort  : int(0)  ##   .. .. ..@ nObs    : int 0 DLTmodel@phi1 ## [1] -1.946152"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"advanced-model-specification","dir":"Articles","previous_headings":"Model setup","what":"Advanced model specification","title":"crmPack: Object-oriented implementation of CRM designs","text":", advanced ways specify model object crmPack. First, minimal informative prior (Neuenschwander, Branson, Gsponer 2008) can computed using MinimalInformative function. construction based input minimal maximal dose, certain ranges DLT probabilities deemed unlikely. logistic function fitted corresponding points dose-toxicity plane order derive Beta distributions also doses -. Finally Beta distributions approximated common LogisticNormal (LogisticLogNormal) model. minimal informative construction avoids explicit specification prior parameters logistic regression model. example, construct follows, assuming minimal dose 0.1 mg maximum dose 100 mg: use grid points minimum maximum guide approximation routine, based stochastic optimization method (control argument optimization routine, please see help page Quantiles2LogisticNormal details). Therefore need set random number generator seed beforehand able reproduce results future. Please note currently reproducibility testing– currently advised save approximation result order certainly able use model later . threshmin threshmax values specify probability thresholds , respectively, unlikely (5% probability) true probability DLT minimum maximum dose, respectively. result minInfModel list, can use contents illustrate creation prior:  plot see blue quantiles (2.5%, 50%, 97.5%) Beta distributions approximate red quantiles logistic normal model. see distance still quite large, maximum distance red blue point : Therefore usually let computations take longer (removing control option MinimalInformative call) obtain better approximation. final approximating model, produced red points, contained model list element: see slots mean, cov parameters determined. point slight warning: directly change parameters slots existing model object, parameters also saved invisibly places model object. Therefore, always use class initialization function create new model object, new parameters required. want use approximation model, can save shorter name, e.g.:","code":"coarseGrid <- c(0.1, 10, 30, 60, 100) minInfModel <- MinimalInformative(   dosegrid = coarseGrid,   refDose = 50,   threshmin = 0.2,   threshmax = 0.3,   control =     list(       threshold.stop = 0.03,       maxit = 200     ),   seed = 432 ) ## It: 1, obj value (lsEnd): 0.4445658383 indTrace: 1 ## It: 4, obj value (lsEnd): 0.3926716567 indTrace: 4 ## It: 23, obj value (lsEnd): 0.1205177306 indTrace: 23 ## Emini is: 0.1205177306 ## xmini are: ## 1.149417785 1.182441052 1.97337573 0.3758820995 0.3619198625  ## Totally it used 19.464896 secs ## No. of function call is: 4807 ## Algorithm reached max number of iterations. matplot(   x = coarseGrid,   y = minInfModel$required,   type = \"b\", pch = 19, col = \"blue\", lty = 1,   xlab = \"dose\",   ylab = \"prior probability of DLT\" ) matlines(   x = coarseGrid,   y = minInfModel$quantiles,   type = \"b\", pch = 19, col = \"red\", lty = 1 ) legend(\"right\",   legend = c(\"quantiles\", \"approximation\"),   col = c(\"blue\", \"red\"),   lty = 1,   bty = \"n\" ) minInfModel$distance ## [1] 0.1205177 str(minInfModel$model) ## Formal class 'LogisticNormal' [package \"crmPack\"] with 9 slots ##   ..@ params         :Formal class 'ModelParamsNormal' [package \"crmPack\"] with 3 slots ##   .. .. ..@ mean: Named num [1:2] 1.15 1.18 ##   .. .. .. ..- attr(*, \"names\")= chr [1:2] \"meanAlpha.(Intercept)\" \"meanBeta.I(log(dosegrid/refDose))\" ##   .. .. ..@ cov : num [1:2, 1:2] 3.894 0.268 0.268 0.141 ##   .. .. ..@ prec: num [1:2, 1:2] 0.295 -0.561 -0.561 8.145 ##   ..@ ref_dose       :Formal class 'positive_number' [package \"crmPack\"] with 1 slot ##   .. .. ..@ .Data: num 50 ##   ..@ datamodel      :function ()   ##   ..@ priormodel     :function ()   ##   ..@ modelspecs     :function (from_prior)   ##   ..@ init           :function ()   ##   ..@ datanames      : chr [1:3] \"nObs\" \"y\" \"x\" ##   ..@ datanames_prior: chr(0)  ##   ..@ sample         : chr [1:2] \"alpha0\" \"alpha1\" myModel <- minInfModel$model"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"obtaining-the-posterior","dir":"Articles","previous_headings":"","what":"Obtaining the posterior","title":"crmPack: Object-oriented implementation of CRM designs","text":"said , models inheriting GeneralModel class rely MCMC sampling obtaining posterior distribution model parameters, given data. models, except EffFlexi class model (please refer Dual-endpoint dose escalation designs details), inheriting ModelPseudo class necessarily require MCMC sampling obtain posterior estimates. MCMC sampling involved, prior posterior modal estimates model estimates used. can still obtain full posterior distribution model parameters via MCMC models specified ModelPseudo class. MCMC sampling can controlled object class mcmcOptions, created example follows: Now object options specifies like 2000 parameter samples obtained Markov chain starts burn-phase 100 iterations discarded, save sample every 2 iterations. Note numbers low actual production use used illustrating purposes ; normally specify least default parameters initialization function mcmcOptions: 10000 burn-iterations 10000 samples saved every 2nd iteration. can look help browser link McmcOptions. set options, can proceed MCMC sampling calling mcmc function: mcmc function takes data object, model MCMC options. default, JAGS used obtaining samples. Use option verbose = TRUE show progress bar detailed JAGS messages. Finally, good practice check graphically Markov chain really converged posterior distribution. end, crmPack provides interface convenient R-package ggmcmc. function get can extract individual parameters object class Samples. example, extract α0\\alpha_{0} samples: (please look help page LogisticLogNormal model class interpretation parameters) alpha0samples now contains α0\\alpha_{0} samples format understood ggmcmc can produce plots , e.g. trace plot autocorrelation plot:   see autocorrelation samples, might consider using higher thinning parameter order decrease . can find useful plotting functions package information: Similarly, using models ModelPseudo class, can also obtain prior posterior samples model parameters via MCMC. example, using DLTmodel, data1, empty data set options specified earlier examples. prior samples model parameters now saved variable DLTsamples. Similarly, DLTpostsamples now contains posterior samples model parameters. %Since output message seen example display MCMC sampling observed data involved, suppressMessages function used now throughout document avoid showing message document mcmc function also takes data object, model MCMC options. using JAGS just R computations. DLTmodel, obtain samples φ1 φ2. Using described earlier section , can also look structure using function str, extracting model parameters samples get produce plots ggs_traceplot ggs_autocorrelation model parameters. MCMC sampling involved, posterior modal estimates model parameters can obtained models (except EffFlexi class object) inheriting ModelPseudo class object. First need put together currently available observations form Data object (DLT responses modelled) texttt{DataDual} object (DLT efficacy responses modelled) class object. using update function update model, posterior modal estimates model parameters display output model. example, new observations specified data set data3 update DLT model: example, update function used obtain posterior modal estimates model parameters, φ1 φ2, can extracted using operator updated result newDLTmodel.","code":"options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options) ## look at the structure of the samples object: str(samples) ## Formal class 'Samples' [package \"crmPack\"] with 2 slots ##   ..@ data   :List of 2 ##   .. ..$ alpha0: num [1:2000] 1.08 1.08 1.08 1.08 1.08 ... ##   .. ..$ alpha1: num [1:2000] 0.485 0.485 0.485 0.485 0.485 ... ##   ..@ options:Formal class 'McmcOptions' [package \"crmPack\"] with 5 slots ##   .. .. ..@ iterations: int 4100 ##   .. .. ..@ burnin    : int 100 ##   .. .. ..@ step      : int 2 ##   .. .. ..@ rng_kind  : chr NA ##   .. .. ..@ rng_seed  : int NA ## now extract the alpha0 samples (intercept of the regression model) alpha0samples <- get(samples, \"alpha0\") library(ggmcmc) ## Loading required package: dplyr ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union ## Loading required package: tidyr print(ggs_traceplot(alpha0samples)) print(ggs_autocorrelation(alpha0samples)) help(package = \"ggmcmc\", help_type = \"html\") DLTsamples <- mcmc(data = data1, model = DLTmodel, options = options) data3 <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = as.integer(1:8),   cohort = c(1, 2, 2, 3, 4, 4, 5, 6),   doseGrid = seq(from = 25, to = 300, by = 25) ) DLTpostsamples <- mcmc(data = data3, model = DLTmodel, options = options) newDLTmodel <- update(object = DLTmodel, data = data3) newDLTmodel@phi1 ## [1] -5.070681 newDLTmodel@phi2 ## [1] 1.125107"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"plotting-the-model-fit","dir":"Articles","previous_headings":"","what":"Plotting the model fit","title":"crmPack: Object-oriented implementation of CRM designs","text":"obtained parameter samples, can plot model fit, supplying samples, model data generic plot function:  plot shows posterior mean curve 95% equi-tailed credible intervals point dose grid Data object. Note can also produce plot prior mean curve credible intervals, .e. model without data. works principle way data, just use empty data object:  plot function can also apply DLTmodel samples parameters generated:  addition, can also plot fitted dose-response curve using prior posterior modal estimates model parameters MCMC sampling used. example, DLTmodel specified earlier ModelTox class data set data1 specified earlier:  Since samples involved, curve using prior posterior modal estimates parameters produced, without 95% credibility intervals.","code":"print(plot(samples, model, data)) ## provide only the dose grid: emptydata <- Data(doseGrid = data@doseGrid) ## obtain prior samples with this Data object priorsamples <- mcmc(emptydata, model, options) ## then produce the plot print(plot(priorsamples, model, emptydata)) print(plot(DLTsamples, DLTmodel, data1)) print(plot(data1, DLTmodel))"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"escalation-rules","dir":"Articles","previous_headings":"","what":"Escalation Rules","title":"crmPack: Object-oriented implementation of CRM designs","text":"dose escalation, four kinds rules: Increments: specifying maximum allowable increments doses NextBest: derive next best dose CohortSize: specifying cohort size Stopping: Stopping rules finishing dose escalation listed classes rules, multiple subclasses , can find links help pages Increments-class, NextBest-class, CohortSize-class Stopping-class.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"increments-rules","dir":"Articles","previous_headings":"Escalation Rules","what":"Increments rules","title":"crmPack: Object-oriented implementation of CRM designs","text":"Figure @ref(fig:increments) shows structure Increments classes: Increments classes structure Increments class basis maximum increments rule classes within package. three subclasses, IncrementsRelative, IncrementsRelativeParts IncrementsRelativeDLTs classes. Let us start looking detail increments rules. Currently two specific rules implemented: Maximum relative increments based current dose (IncrementsRelative IncrementsRelativeParts, works DataParts objects), maximum relative increments based current cumulative number DLTs happened (IncrementsRelativeDLT). example, order specify maximum increase 100% doses 20 mg, maximum 33% doses 20 mg, can setup following increments rule: intervals slot specifies left bounds intervals, maximum relative Increments (note: decimal values , percentages!) valid. increments rule used maxDose function obtain maximum allowable dose given current data: case, next dose larger 20 mg. following example dose escalation restricted 3-fold (= 200%) increase: doses (since dose grid starts 25 mg) maximum increase 200% . IncrementsRelativeDLT class works similarly, taking number DLTs whole trial far basis maximum increments instead last dose.","code":"myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements,   data = data ) nextMaxDose ## [1] 20 myIncrements1 <- IncrementsRelative(   intervals = c(25),   increments = c(2) )"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"rules-for-next-best-dose-recommendation","dir":"Articles","previous_headings":"Escalation Rules","what":"Rules for next best dose recommendation","title":"crmPack: Object-oriented implementation of CRM designs","text":"Figure @ref(fig:rules) show structure next best dose recommendation rules currently implemented crmPack. Escalation classes structure classes escalation rules contained nextBest class. two main types escalation rules: either binary DLT responses incorporated escalation process, binary DLT continuous efficacy/biomarker response jointly incorporated escalation process. two implemented rules toxicity endpoint CRMs inheriting GeneralModel class: NextBestMTD uses posterior distribution MTD estimate (given target toxicity probability defining MTD), nextBestCRM implements N-CRM, using posterior probabilities target-dosing overdosing dose grid points recommend next best dose. example, order use N-CRM target toxicity interval 20% 35%, maximum overdosing probability 25%, specify: Alternatively, use MTD driven recommendation rule. example, target toxicity rate 33%, recommending 25% posterior quantile MTD, specify Note NextBestMTD class quite flexible, can specify function derive derives next best dose posterior MTD samples. also two next best dose recommendation rules model inheriting ModelTox class. One rule specified samples model parameters involved one samples model parameters generated incorporated dose-escalation procedure. details rules follows. First, two probabilities occurrence DLT fixed. first one called targetDuringTrial target probability occurrence DLT used trial. second probability called targetEndOfTrial target probability occurrence DLT used end trial. two targets always specified. cases samples involved, additional argument used, function advise recommend using samples . elaborated details example . example, fixed target probability occurrence DLT used trial 0.35. means allow subjects dose levels probability DLT closest less equal 0.35 trial. end trial, therefore recommend dose level closest probability DLT less equal 0.3. NextBestTD rule class can used samples involved escalation procedure. Next show example NextBestTDsamples rule class samples involved escalation process. slot targetDuringTrial targetEndOfTrial specified way last example given value 0.35 0.3, respectively. derive slot always specified function. example, using function specified derive slot says recommend 30% posterior quantiles samples estimates doses corresponding targetDuringTrial targetEndOfTrial doses. study, order derive next best dose, supply generic nextBest function rule, maximum dose, posterior samples, model data: result list two elements: value contains numeric value recommended next best dose, plot contains plot illustrates next best dose computed. case used N-CRM rule, therefore plot gives target-dosing overdosing probabilities together safety bar 25%, maximum dose final recommendation (red triangle):  Similarly, can use generic nextBest function theNextBestTD NextBestTDsamples rules. example use data set data3 DLT observations. can compute next best dose given next cohort using posterior modal estimates DLT model (.e., MCMC sampling involved ): list numerical values plot showing next best dose computed given. list results provide numerical values next dose level, next_dose_drt; target probability DLT used trial, prob_target_drt; estimated dose level probability DLT equals target probability used trial, dose_target_drt; target probability DLT used end trial, prob_target_eot; estimated dose level probability DLT equals target probability DLT used end trial dose_target_eot; dose level dose grid closest less dose_target_eot, next_dose_eot. can use $ operator obtain values plot list. example,  can see next dose suggested given next cohort subjects 50 mg. target probability DLT trial 0.35 TD35 (tolerated dose probability DLT equal 0.35) estimated 52.28 mg. using 12 dose levels dose grids 25 mg 300 mg increments 25 mg data set, data3, can see suggested next dose 50 mg also dose level closest 52.28 mg, estimated dose_target_drt. Similarly, end trial also obtain “End Trial” estimates using $ operator. addition, also plot show next dose allocation. red curve shows estimated DLT curve obtained using posterior modal estimates model parameters. also assumed maximum allowable dose 300 mg specified doselimit parameter nextBest function call red vertical line denoted “Max” shows maximum dose level (x-axis) allowed case. vertical purple line denoted “Next” marks dose level allocated next cohort subjects. example, target probability DLT used trial end trial 0.35 0.3, respectively. circle square DLT curve show probability DLT estimated equal 0.3 0.35, respectively. Hence, value estimated TD30 TD35 can checked x-axis vertically symbols. MCMC sampling involved, use samples model parameters choose next best dose. example, following code chunk use data set, data3, DLT observations posterior samples model parameters, DLTpostsamples compute next best dose: list results produced example : values next_dose_drt, prob_target_drt, dose_target_drt, prob_target_eot, dose_target_eot next_dose_eot can obtained using $ operator. difference plot example look slightly different previous example:  graph incorrect plot, vertical lines given show value next dose, TD30 estimate, TD35 estimate maximum allowable dose level. Since samples model parameters utilized, density curves TD30 (pink) TD35 (grey) plotted.","code":"myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 ) mtdNextBest <- NextBestMTD(   target = 0.33,   derive =     function(mtd_samples) {       quantile(mtd_samples, probs = 0.25)     } ) TDNextBest <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 ) TDsamplesNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) doseRecommendation <- nextBest(myNextBest,   doselimit = nextMaxDose,   samples = samples, model = model, data = data ) doseRecommendation$value ## [1] 20 print(doseRecommendation$plot) doseRecDLT <- nextBest(TDNextBest, doselimit = 300, model = newDLTmodel, data = data3) doseRecDLT$next_dose_drt ## [1] 50 doseRecDLT$prob_target_drt ## [1] 0.35 doseRecDLT$dose_target_drt ## [1] 52.28128 print(doseRecDLT$plot) doseRecDLTSamples <- nextBest(TDsamplesNextBest,   doselimit = 300,   samples = DLTpostsamples, model = newDLTmodel,   data = data3 ) print(doseRecDLTSamples$plot) ## Warning: Some data points are outside of `bounds`. Removing them. ## Some data points are outside of `bounds`. Removing them."},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"cohort-size-rules","dir":"Articles","previous_headings":"Escalation Rules","what":"Cohort size rules","title":"crmPack: Object-oriented implementation of CRM designs","text":"CohortSize classes structure % classes related cohort size package contains within CohortSize class. Similarly increments rules, can define intervals dose space /DLT space define size cohorts. example, let’s assume want one patient cohorts reach 30 mg first DLT encountered, proceed three patients per cohort. start creating two separate rules, first dose range: DLT range: Finally combine two rules taking maximum number patients rules: CohortSize rule used size}` function, together next dose current data, order determine size next cohort: , one DLT already, go 3 patients next cohort. Moreover, like constant cohort size, can use following CohortSizeConst class, use (three patients) simplicity remainder vignette:","code":"df <- data.frame(   pathString = c(     \"CohortSize/CohortSizeRange\",     \"CohortSize/CohortSizeDLT\",     \"CohortSize/CohortSizeConst\",     \"CohortSize/CohortSizeParts\",     \"CohortSize/CohortSizeMax\",     \"CohortSize/CohortSizeMin\"   ) )  tree <- as.Node(df) SetNodeStyle(tree, shape = \"box\", fig.alt = \"A dendrogram showing the inheritance stricture of the CohortSize classes.  CohortSie is the parent class.  All other classes are children of CohortSize.\") plot(tree) mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3)) mySize2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3)) mySize <- maxSize(mySize1, mySize2) size(mySize,   dose = doseRecommendation$value,   data = data ) ## [1] 3 mySize <- CohortSizeConst(size = 3)"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"stopping-rules","dir":"Articles","previous_headings":"Escalation Rules","what":"Stopping rules","title":"crmPack: Object-oriented implementation of CRM designs","text":"stopping rules classes inherit directly Stopping class. total 9 stopping rules, listed follows: StoppingCohortNearDose StoppingPatientsNearDose StoppingMinCohorts StoppingMinPatients StoppingTargetProb StoppingMTDdistribution StoppingTargetBiomarker StoppingTDCIRatio StoppingMaxGainCIRatio names stopping rules, can idea criteria used stopping decisions explain briefly criteria. details please refer examples presented later vignette examples given help pages. can find link implemented stopping rule parts help page Stopping-class. example, StoppingCohortNearDose class objects can used stop dose escalation based numbers cohorts treated near next best dose (required proximity given percentage relative deviation next best dose). Similarly, StoppingPatientsNearDose, stopping based number patients treated near next best dose. StoppingMinCohorts StoppingMinPatients rules can used stop dose escalation minimum overall number patients cohorts enrolled. also stopping rules trial stopped either based MTD distribution (StoppingMTDdistribution), reached pre-specified probability next dose target toxicity interval (StoppingTargetProb) target biomarker interval (StoppingTargetBiomarker) current estimate quantity interest ‘accurate’ enough (StoppingTDCIRatio StoppingMaxGainCIRatio) Stopping rules often quite complex, built “/” combinations multiple parts. Therefore crmPack implementation mirrors , multiple atomic stopping rules can combined easily. example, let’s assume like stop trial least 3 cohorts least 50% probability target toxicity interval (20(20%, 35%), maximum sample size 20 patients reached. start creating three pieces rule composed : Finally combine operator & operator |: can also stop trial current estimate quantity interest, TD30 given earlier examples, ‘accurate’ enough. accuracy current estimate TD30 quantified width associated 95% credibility interval. wider interval, less accurate estimate . particular, ratio upper lower limit 95% credibility interval used. smaller ratio, accurate estimate. example, stop trial obtain ratio less 5 95% credibility interval TD30 estimate case, deciding obtained estimate ‘accurate’ enough. StoppingTDCIRatio function can used cases DLT samples DLT samples involved: two examples, targetRatio targetEndOfTrial specified. dose escalation study, (atomic combined) stopping rule can used function stopTrial determine rule already fulfilled. example case: receive FALSE, means stopping rule criteria met. attribute message contains textual results atomic parts stopping rule. can read probability target toxicity just 30% recommended dose 20 mg therefore low, also maximum sample size reached, therefore trial shall continue. way stopping rule myStopping4 (samples samples) can evaluated: DLT samples DLT samples involved. Note moment operator & operator | used together StoppingTDCIRatio class objects. still development.","code":"myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3 myStopping4 <- StoppingTDCIRatio(target_ratio = 5, prob_target = 0.3) stopTrial(   stopping = myStopping, dose = doseRecommendation$value,   samples = samples, model = model, data = data ) ## [1] FALSE ## attr(,\"message\") ## attr(,\"message\")[[1]] ## attr(,\"message\")[[1]][[1]] ## [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" ##  ## attr(,\"message\")[[1]][[2]] ## [1] \"Probability for target toxicity is 36 % for dose 20 and thus below the required 50 %\" ##  ##  ## attr(,\"message\")[[2]] ## [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" ##  ## attr(,\"individual\") ## attr(,\"individual\")[[1]] ## [1] FALSE ## attr(,\"message\") ## attr(,\"message\")[[1]] ## [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" ##  ## attr(,\"message\")[[2]] ## [1] \"Probability for target toxicity is 36 % for dose 20 and thus below the required 50 %\" ##  ## attr(,\"individual\") ## attr(,\"individual\")[[1]] ## [1] TRUE ## attr(,\"message\") ## [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" ## attr(,\"report_label\") ## [1] \"≥ 3 cohorts dosed\" ##  ## attr(,\"individual\")[[2]] ## [1] FALSE ## attr(,\"message\") ## [1] \"Probability for target toxicity is 36 % for dose 20 and thus below the required 50 %\" ## attr(,\"report_label\") ## [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\" ##  ## attr(,\"report_label\") ## [1] NA ##  ## attr(,\"individual\")[[2]] ## [1] FALSE ## attr(,\"message\") ## [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" ## attr(,\"report_label\") ## [1] \"≥ 20 patients dosed\" ##  ## attr(,\"report_label\") ## [1] NA stopTrial(   stopping = myStopping4, dose = doseRecDLTSamples$next_dose_drt,   samples = DLTpostsamples, model = newDLTmodel, data = data3 ) ## [1] FALSE ## attr(,\"message\") ## [1] \"95% CI is (0.000611274483577912, 10459.134513363), Ratio = 17110373.1537 is greater than target_ratio = 5\" ## attr(,\"report_label\") ## [1] \"TD 5 for 0.3 target prob\" stopTrial(   stopping = myStopping4, dose = doseRecDLT$next_dose_drt,   model = newDLTmodel, data = data3 ) ## [1] FALSE ## attr(,\"message\") ## [1] \"95% CI is ( 11.0662 , 164.618 ), Ratio = 14.8758 is  greater than target_ratio = 5\" ## attr(,\"report_label\") ## [1] \"TD 5 for 0.3 target prob\""},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"simulations","dir":"Articles","previous_headings":"","what":"Simulations","title":"crmPack: Object-oriented implementation of CRM designs","text":"order run simulations, first build specific design, comprises model, escalation rules, starting data, cohort size starting dose. Design classes structure might seem strange first sight supply starting data design, show makes sense. First, use emptydata object contains dose grid, cohorts 3 patients, starting 0.1 mg: Another example given TDDesign class used. empty data set, data1 used, starting dose 25 mg. code design defined MCMC sampling involved. nextBest slot TDDesign class function defined TDNextBest class object ensure pick next best dose using rules defined MCMC sampling involved. addition, define myStopping4 trial stop ratio 95% credibility interval limits current estimate TD30 (TDtargetEndOfTrial) less equal 5. addition, also use myIncrements1, mySize data1 defined earlier examples increments, cohort_size data slots defining TDDesign object: MCMC samples involved, also specify design ensure package run simulations using MCMC samples model parameters models specified ModelPseudo class object. example, TDsamplesDesign class object used TDsamplesNextBest class object nextBest slot ensure MCMC sampling involved design. also apply stopping rule myStopping4 myStopping3 trial stop either ratio 95% credibility interval limits current estimate TD30 (TDtargetEndOfTrial) less equal 5 (myStopping4) maximum 30 patients enrolled trial (myStopping3):","code":"design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 ) DLTdesign <- TDDesign(   model = DLTmodel,   nextBest = TDNextBest,   stopping = myStopping4,   increments = myIncrements1,   cohort_size = mySize,   data = data1,   startingDose = 25 ) DLTsamplesDesign <- TDsamplesDesign(   model = DLTmodel,   nextBest = TDsamplesNextBest,   stopping = (myStopping4 | myStopping3),   increments = myIncrements1,   cohort_size = mySize,   data = data1,   startingDose = 25 )"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"examining-single-trial-behavior","dir":"Articles","previous_headings":"Simulations","what":"Examining single trial behavior","title":"crmPack: Object-oriented implementation of CRM designs","text":"looking “many trials” operating characteristics, important look “single trial” operating characteristics dose escalation design. , crmPack provides function examine, generates data.frame showing beginning several hypothetical trial courses design. Assuming DLTs seen certain dose, consequences different number DLTs observed dose shown. current example Note important set seed, since minor changes might occur due sampling variations. However, mcmcOptions parameter chosen order minimize variation. default setting, used implicitly call, normally sufficient, checking (running function twice different seeds comparing results) important. resulting data frame gives dose cohort DLTs observed, number DLTs, resulting next dose recommendation, whether design stop, relative increment next dose compared current dose percentage. Note cohort size rules taken account examine. NA entries mean design stop without valid dose, since doses considered toxic observing number DLTs dose.","code":"set.seed(23) examine(design) ##    dose DLTs nextDose  stop increment ## 1     3    0      6.0 FALSE       100 ## 2     3    1      3.0 FALSE         0 ## 3     3    2      0.1 FALSE       -97 ## 4     3    3       NA FALSE        NA ## 5     6    0     12.0 FALSE       100 ## 6     6    1     12.0 FALSE       100 ## 7     6    2      3.0 FALSE       -50 ## 8     6    3      1.5 FALSE       -75 ## 9    12    0     24.0 FALSE       100 ## 10   12    1     24.0 FALSE       100 ## 11   12    2     14.0 FALSE        17 ## 12   12    3      6.0 FALSE       -50 ## 13   24    0     30.0 FALSE        25 ## 14   24    1     30.0 FALSE        25 ## 15   24    2     26.0 FALSE         8 ## 16   24    3     18.0 FALSE       -25 ## 17   30    0     38.0 FALSE        27 ## 18   30    1     38.0 FALSE        27 ## 19   30    2     34.0 FALSE        13 ## 20   30    3     28.0 FALSE        -7 ## 21   38    0     50.0 FALSE        32 ## 22   38    1     50.0 FALSE        32 ## 23   38    2     42.0 FALSE        11 ## 24   38    3     36.0 FALSE        -5 ## 25   50    0     58.0  TRUE        16 ## 26   50    1     54.0  TRUE         8 ## 27   50    2     50.0  TRUE         0 ## 28   50    3     44.0  TRUE       -12"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"simulating-from-a-true-scenario","dir":"Articles","previous_headings":"Simulations","what":"Simulating from a true scenario","title":"crmPack: Object-oriented implementation of CRM designs","text":"“many trials” operating characteristics, define true scenario, data arise. case, requires function computes probability DLT given dose. use specific case function contained model space:  similar way, can also simulate trials based true DLT scenario using TDDesign TDsamplesDesign. First, specified true DLT scenario  true DLT scenario used TDDesign TDsamplesDesign Now can proceed simulations. generate 100 trial outcomes illustration, actual study increased course least 500: wrapped call simulate system.time obtain required time simulations (147 seconds case). argument args contain additional arguments truth function, require therefore let default NULL. specify number simulations nsim random number generator seed seed. Note also pass MCMC options object, trial simulations MCMC routines used. Finally, argument parallel can used enable use processors computer running simulations parallel. can yield meaningful speedup, especially larger number simulations. (almost) always, result call object class, case Simulations: help page see class subclass GeneralSimulations class. looking help pages Simulations parent class GeneralSimulations, can find description slots mySims. particular, Data slot contains list produced Data objects simulated trials. Therefore, can plot course e.g. third simulated trial follows:  final dose trial stopping reason Furthermore, object, can apply two methods. First, can plot , .e. can apply plot method:  resulting plot shows top panel summary trial trajectories. bottom, proportions doses tried, averaged simulated trials, shown. Note can select plots changing type argument plot, default type =   c(\"trajectory\", \"dosesTried\"). Second, can summarize simulation results. supply true dose-toxicity function. take (myTruth) : Note sometimes observed toxicity rate dose often selected (20 mg) available, can happen patients actually treated dose simulations. (available.) illustrates MTD can selected based evidence data dose levels – advantage model-based dose-escalation designs. Now can also produce plot summary results, gives bit detail textual summary just seen:  top left panel shows distribution sample size across simulated trials. case trials 15 21 patients. top right panel shows distribution final MTD estimate / recommended dose across simulated trials. middle left panel shows distribution across simulations DLT proportions observed patients dosed. trials 20 30% patients DLTs. middle right panel shows distribution across simulations number patients treated target toxicity window (used default 20% 35%). Finally, bottom panel see comparison true dose-toxicity curve (black) estimated dose-toxicity curves, averaged (continuous red line) across trials 95% credible interval across trials. see steep true dose-toxicity curve recovered model fit. find e.g. top right plot distribution final selected doses small shows right x-axis window, can plot one add x-axis customization top: (see ggplot2 documentation information customizing plots)  examples given simulations using TDDesign TDsamplesDesign classes. illustration purpose, generate 10 trial outcomes. example MCMC sampling involved another example simulation MCMC sampling involved: meaning arguments defined explained simulate example Design class. % slots args specify additional arguments truth function, truth real DLT scenario simulate responses , nsim number simulations, seed, random generator seed parallel specify whether parallel computing used running simulations. Similarly, results individual simulations can obtained graphically using plot function. dose level recommendation dose levels closest final estimated TD30 (final estimates dose level probability DLT equals target end trial) overall results 100 trials two simulations can also plotted   show trial trajectories proportion doses level tried. simulation results can also summarized using summary function given truth: can also plot summary two simulations using plot function:  ","code":"## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  ## plot it in the range of the dose grid curve(myTruth(x), from = 0, to = 80, ylim = c(0, 1)) ## define the true function TrueDLT <- probFunction(DLTmodel, phi1 = -53.66584, phi2 = 10.50499)  ## plot it in the range of the dose grid curve(TrueDLT, from = 25, to = 300, ylim = c(0, 1)) time <- system.time(mySims <- simulate(design,   args = NULL,   truth = myTruth,   nsim = 100,   seed = 819,   mcmcOptions = options,   parallel = FALSE ))[3] time ## elapsed  ## 147.437 class(mySims) ## [1] \"Simulations\" ## attr(,\"package\") ## [1] \"crmPack\" help(\"Simulations-class\", help = \"html\") ## starting httpd help server ... done print(plot(mySims@data[[3]])) mySims@doses[3] ## [1] 22 mySims@stop_reasons[[3]] ## [[1]] ## [[1]][[1]] ## [1] \"Number of cohorts is 7 and thus reached the prespecified minimum number 3\" ##  ## [[1]][[2]] ## [1] \"Probability for target toxicity is 51 % for dose 22 and thus above the required 50 %\" ##  ##  ## [[2]] ## [1] \"Number of patients is 21 and thus reached the prespecified minimum number 20\" print(plot(mySims)) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## ℹ The deprecated feature was likely used in the crmPack package. ##   Please report the issue at <https://github.com/openpharma/crmPack/issues>. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. summary(mySims,   truth = myTruth ) ## Summary of 100 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 19.6, 21.6  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients overall : mean 19 (15, 21)  ## Number of patients treated above target tox interval : mean 7 (6, 9)  ## Proportions of DLTs in the trials : mean 26 % (22 %, 29 %)  ## Mean toxicity risks for the patients on active : mean 25 % (17 %, 35 %)  ## Doses selected as MTD : mean 20.6 (16, 26)  ## True toxicity at doses selected : mean 30 % (5 %, 70 %)  ## Proportion of trials selecting target MTD: 21 % ## Dose most often selected as MTD: 18  ## Observed toxicity rate at dose most often selected: 11 % ## Fitted toxicity rate at dose most often selected : mean 24 % (19 %, 28 %)  ## Stop reason triggered: ##  ≥ 3 cohorts dosed :  100 % ##  P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5 :  98 % ##  ≥ 20 patients dosed :  37 % simSum <- summary(mySims,   truth = myTruth ) print(plot(simSum)) dosePlot <- plot(simSum, type = \"doseSelected\") +   scale_x_continuous(breaks = 10:30, limits = c(10, 30)) ## Scale for x is already present. ## Adding another scale for x, which will replace the existing scale. print(dosePlot) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_bar()`). DLTSim <- simulate(DLTdesign,   args = NULL,   truth = TrueDLT,   nsim = 10,   seed = 819,   parallel = FALSE ) DLTsampSim <- simulate(DLTsamplesDesign,   args = NULL,   truth = TrueDLT,   nsim = 10,   seed = 819,   mcmcOptions = options,   parallel = FALSE ) DLTSim@doses[3] ## [1] 100 DLTsampSim@doses[3] ## [1] 100 print(plot(DLTSim)) print(plot(DLTsampSim)) summary(DLTSim,   truth = TrueDLT ) ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 16 (15, 18)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (3, 3)  ## Number of patients treated above the target p(DLE) used during a trial : mean 3 (3, 3)  ## Proportions of observed DLT in the trials : mean 21 % (20 %, 22 %)  ## Mean toxicity risks for the patients : mean 20 % (17 %, 21 %)  ## Doses selected as TDEOT : mean 100 (100, 100)  ## True toxicity at TDEOT : mean 1 % (1 %, 1 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 100  ## Observed toxicity rate at dose most often selected: 6 % ## Fitted probabilities of DLE at dose most often selected : mean 24 % (24 %, 25 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    117.3   120.1   123.8   122.0   123.8   123.8   ## The summary table of the final ratios of the TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    4.054   4.157   4.447   4.330   4.447   4.447   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    137.5   140.7   144.4   142.5   144.4   144.4   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    117.3   120.1   123.8   122.0   123.8   123.8   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    4.054   4.157   4.447   4.330   4.447   4.447   ##  ## Stop reason triggered: ##  TD 5 for 0.3 target prob :  100 % summary(DLTsampSim,   truth = TrueDLT ) ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 21 (21, 21)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 1 (0, 3)  ## Number of patients treated above the target p(DLE) used during a trial : mean 1 (0, 3)  ## Proportions of observed DLT in the trials : mean 10 % (5 %, 14 %)  ## Mean toxicity risks for the patients : mean 6 % (1 %, 10 %)  ## Doses selected as TDEOT : mean 100 (75, 125)  ## True toxicity at TDEOT : mean 2 % (0 %, 5 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 100  ## Observed toxicity rate at dose most often selected: 6 % ## Fitted probabilities of DLE at dose most often selected : mean 22 % (18 %, 26 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    97.28  100.35  115.37  114.40  125.23  135.76   ## The summary table of the final ratios of the TDEOT across all simulations ##       Min.   1st Qu.    Median      Mean   3rd Qu.      Max.   ##  1.000e+01 6.800e+01 4.079e+06 5.241e+11 1.917e+11 3.806e+12   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    118.8   122.2   144.9   143.3   161.5   170.3   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    97.28  100.35  115.37  114.40  125.23  135.76   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##       Min.   1st Qu.    Median      Mean   3rd Qu.      Max.   ##  1.000e+01 6.800e+01 4.079e+06 5.241e+11 1.917e+11 3.806e+12   ##  ## Stop reason triggered: ##  TD 5 for 0.3 target prob :  0 % ##  ≥ 20 patients dosed :  100 % DLTsimSum <- summary(DLTSim,   truth = TrueDLT ) print(plot(DLTsimSum)) DLTsimsampSum <- summary(DLTsampSim,   truth = TrueDLT ) print(plot(DLTsimsampSum))"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"predicting-the-future-course-of-the-trial","dir":"Articles","previous_headings":"Simulations","what":"Predicting the future course of the trial","title":"crmPack: Object-oriented implementation of CRM designs","text":"simulating parameters current posterior distribution instead assumed true scenario, possible generate trial simulations posterior predictive distribution time point trial. means can predict future course trial, given current data. illustrating example, work follows. rationale simulate call now specify truth argument prob function assumed model. simulations, arguments internally given values contained data frame given simulate args argument. case, want supply posterior samples alpha0 alpha1 data frame. take 50 2000 posterior samples order reduce runtime example: Therefore, simulated trial come posterior sample estimated model, given data far. Furthermore make new Design object contains current data start , current recommended dose starting dose: Finally can execute simulations: now, exactly way operating characteristics simulations, can summarize resulting predictive simulations, example show predicted trajectories doses:  summary, need look characteristics involving true dose-toxicity function, case intending compare performance CRM relative truth: see e.g. estimated number patients overall 19, 11 current 8 patients expected needed finishing trial.","code":"postSamples <- as.data.frame(samples@data)[(1:20) * 50, ] postSamples ##           alpha0    alpha1 ## 50    0.69110245 1.6593221 ## 100   0.13500991 2.0681115 ## 150  -0.93319013 2.2039907 ## 200  -0.76766030 1.9168658 ## 250  -0.71575012 0.8637421 ## 300  -1.44860413 1.2306354 ## 350  -0.66384847 1.7058330 ## 400   0.10130748 1.2992960 ## 450  -0.05097666 1.1118438 ## 500  -0.03676994 0.5548014 ## 550  -1.14358206 1.3377109 ## 600  -0.38283728 1.1225844 ## 650   0.66869941 2.0452836 ## 700  -0.63588703 0.9691539 ## 750   0.11418516 0.5934733 ## 800  -1.38174629 1.3083330 ## 850   0.50959453 0.6900552 ## 900  -0.84938932 0.9262908 ## 950   0.88606926 0.6807089 ## 1000 -0.73825362 1.3739291 nowDesign <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   ## use the current data:   data = data,   ## and the recommended dose as the starting dose:   startingDose = doseRecommendation$value ) time <- system.time(futureSims <- simulate(   ## supply the new design here   nowDesign,   ## the truth is the assumed prob function   truth = function(dose, alpha0, alpha1) {     samples <- Samples(       data = list(alpha0 = alpha0, alpha1 = alpha1),       options = McmcOptions(samples = 1)     )     prob(dose, model, samples)   },   ## further arguments are the   ## posterior samples   args = postSamples,   ## do exactly so many simulations as   ## we have samples   nsim = nrow(postSamples),   seed = 918,   ## this remains the same:   mcmcOptions = options,   parallel = FALSE ))[3] time ## elapsed  ##  16.676 print(plot(futureSims)) summary(futureSims,   truth = myTruth ) ## Summary of 20 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 19.6, 21.6  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients overall : mean 18 (17, 20)  ## Number of patients treated above target tox interval : mean 4 (0, 9)  ## Proportions of DLTs in the trials : mean 19 % (10 %, 26 %)  ## Mean toxicity risks for the patients on active : mean 21 % (5 %, 43 %)  ## Doses selected as MTD : mean 26.4 (15, 47)  ## True toxicity at doses selected : mean 49 % (4 %, 100 %)  ## Proportion of trials selecting target MTD: 0 % ## Dose most often selected as MTD: 18  ## Observed toxicity rate at dose most often selected: 17 % ## Fitted toxicity rate at dose most often selected : mean 23 % (10 %, 31 %)  ## Stop reason triggered: ##  ≥ 3 cohorts dosed :  100 % ##  P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5 :  70 % ##  ≥ 20 patients dosed :  60 %"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"simulating-33-design-outcomes","dir":"Articles","previous_headings":"","what":"Simulating 3+3 design outcomes","title":"crmPack: Object-oriented implementation of CRM designs","text":"crmPack focuses model-based dose-escalation designs, also includes 3+3 design order allow convenient comparisons. Note actually simulations required 3+3 design, possible outcomes can enumerated, however still rely simulations consistency overall crmPack design. easiest way setup 3+3 design function ThreePlusThreeDesign: used much coarser dose grid model-based design , 3+3 design jump doses. starting dose automatically chosen first dose grid. outcome RuleDesign object, setup options directly use RuleDesign() initialization function. can simulate trials, assuming myTruth function gives true dose-toxicity relationship: model-based design, can summarize simulations: see mg dose often selected MTD, actually low comparing narrow target dose interval going mg. inherent problem dose-escalation designs dose grid coarse: might know starting trial range need refined dose grid. case obtain doses low, one can see average true toxicity ~% doses selected. Graphical summaries obtained calling plot summary object:","code":"threeDesign <- ThreePlusThreeDesign(doseGrid = c(5, 10, 15, 25, 35, 50, 80)) class(threeDesign) ## [1] \"RuleDesign\" ## attr(,\"package\") ## [1] \"crmPack\" threeSims <- simulate(threeDesign,   nsim = 1000,   seed = 35,   truth = myTruth,   parallel = FALSE ) threeSimsSum <- summary(threeSims,   truth = myTruth ) threeSimsSum ## Summary of 1000 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 19.6, 21.6  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients overall : mean 16 (15, 18)  ## Number of patients treated above target tox interval : mean 4 (3, 6)  ## Proportions of DLTs in the trials : mean 17 % (13 %, 22 %)  ## Mean toxicity risks for the patients on active : mean 17 % (14 %, 22 %)  ## Doses selected as MTD : mean 15.2 (15, 15)  ## True toxicity at doses selected : mean 4 % (3 %, 3 %)  ## Proportion of trials selecting target MTD: 0 % ## Dose most often selected as MTD: 15  ## Observed toxicity rate at dose most often selected: 3 % print(plot(threeSimsSum))"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"dual-endpoint-dose-escalation-designs","dir":"Articles","previous_headings":"","what":"Dual-endpoint dose escalation designs","title":"crmPack: Object-oriented implementation of CRM designs","text":"section, look dose-escalation procedures included package two end points incorporated study. first endpoint binary DLT response discussed already last sections. second endpoint continuous biomarker/efficacy response. package, can either model two responses jointly (using single model class, assuming correlation) separately (using two separate model classes, assuming correlation). Now first describe model two responses jointly.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"dual-endpoint-designs-with-a-joint-model","dir":"Articles","previous_headings":"Dual-endpoint dose escalation designs","what":"Dual-endpoint designs with a joint model","title":"crmPack: Object-oriented implementation of CRM designs","text":"disclaimer, please note designs section still development, far yet published. Therefore please consider experimental. help page DualEndpoint-class general joint model structure described. Basically idea (single) biomarker variable second endpoint dose-escalation design, aim maximize biomarker response controlling toxicity safe range. useful can assumed just increasing dose always lead better efficacy. Let’s look data structure. example: corresponding plot can obtained :  see seems maximum biomarker response around 10 mg already. order model data, consider dual-endpoint model first-order random-walk (RW1) structure dose-biomarker relationship: use smoothing parameter σβW2=0.01\\sigma^{2}_{\\beta_{W}} = 0.01, inverse-gamma prior IG(0.1,0.1)\\mathrm{IG}(0.1, 0.1) biomarker variance σW2\\sigma^{2}_{W} uniform prior (Beta(1,1)\\mathrm{Beta}(1, 1) prior) correlation ρ\\rho latent DLT biomarker variable. dual-endpoint models complex, advisable use sufficiently long Markov chain fitting . just use illustration purposes quite small Markov chain – , real application, need least 25 times longer! can obtain MCMC samples: check convergence picking fitted biomarker means plotting traceplots:  4 βW,j\\beta_{W,j} (j=1,5,10,25j=1, 5, 10, 25) means, biomarker means first, 5th, 10th 25th gridpoint, respectively, seem converged, traceplots show. (Remember data@nGrid gives number grid points.) can plot model fit:  specify extrapolate = FALSE focus biomarker plot right panel observed dose range, don’t want extrapolate biomarker fit higher dose levels. can also look estimated biomarker precision 1/σW21 / \\sigma^{2}_{W}. extract precision precW use another ggmcmc function create histogram:  selection next best dose, special class NextBestDualEndpoint implemented. tries maximize biomarker response, NCRM-type safety constraint. want least 90% maximum biomarker response, 25% maximum overdose probability next dose, specify: example, assuming dose limit 50 mg given maximum allowable increments, next dose can found follows: corresponding plot can produced printing plot element returned list:  bottom panel shows (NCRM) overdose probability, see doses 14 mg toxic. top panel, see probability dose reach least 90% maximum biomarker response dose grid — target probability. numbers low, clearly see local maximum 6 mg target probability, confirming seen previous data model fit plots. corresponding stopping rule exists. certain probability relative biomarker target, StoppingTargetBiomarker rule gives back TRUE queried fulfilled stopTrial function. example, require least 50% probability 90% biomarker response, specify: case, rule fulfilled yet, see : , dual-endpoint specific rule can combined required stopping rule. example, combine maximum sample size 40~patients: one stopping rules fulfilled, trial stopped. Let’s try build corresponding dual-endpoint design. start empty data set, use relative increments rule defined previous section use constant cohort size 3 patients: order study operating characteristics, need determine true biomarker DLT probability functions. going use biomarker function beta family. Note corresponding DualEndpointBeta model class, allows dual-endpoint designs beta biomarker response function. look corresponding help page information . let’s come back scenario definition: can draw corresponding curves:  biomarker response peaks 50 mg, toxicity still low. deciding true correlation ρ=0\\rho=0 true biomarker variance σW2=0.01\\sigma^{2}_{W} = 0.01 (giving high signal--noise ratio), can start simulating trials (starting 6 mg): Note “small” MCMC option set , order reduce simulation time — real application, “larger”. Plotting result gives overview final dose recommendations trial trajectories, also summary biomarker variance correlation estimates simulations:  Finally, summary simulations can obtained corresponding function: see trials proceeded maximum sample size 40 patients (reaching 42 cohort size 3). doses selected lower toxicity target range, aiming biomarker target instead, true biomarker response peaked 50 mg. corresponding plot looks follows:  see average biomarker fit bad range 50 mg, toxicity curve fit bad — probably result low frequency DLTs. warning : dual-endpoint designs still experimental! % Next talk dose escalation designs two endpoints modelled separately.","code":"data <- DataDual(   x =     c(       0.1, 0.5, 1.5, 3, 6, 10, 10, 10,       20, 20, 20, 40, 40, 40, 50, 50, 50     ),   y =     c(       0, 0, 0, 0, 0, 0, 1, 0,       0, 1, 1, 0, 0, 1, 0, 1, 1     ),   ID = as.integer(1:17),   cohort = as.integer(c(1:5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9)),   w =     c(       0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.55, 0.6,       0.52, 0.54, 0.56, 0.43, 0.41, 0.39, 0.34, 0.38, 0.21     ),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ) ) print(plot(data)) model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW =     0.01,   sigma2W =     c(a = 0.1, b = 0.1),   rho =     c(a = 1, b = 1),   rw1 = TRUE ) options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) samples <- mcmc(data, model, options) data@nGrid ## [1] 41 betaWpicks <- get(samples, \"betaW\", c(1L, 5L, 10L, 25L)) ggs_traceplot(betaWpicks) print(plot(samples, model, data, extrapolate = FALSE)) ggs_histogram(get(samples, \"precW\")) myNextBest <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 ) nextDose <- nextBest(myNextBest,   doselimit = 50,   samples = samples,   model = model,   data = data ) nextDose$value ## [1] 10 print(nextDose$plot) myStopping6 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) stopTrial(myStopping6,   dose = nextDose$value,   samples, model, data ) ## [1] FALSE ## attr(,\"message\") ## [1] \"Probability for target biomarker is 12 % for dose 10 and thus below the required 50 %\" ## attr(,\"report_label\") ## [1] \"P(0.9 ≤ Biomarker ≤ 1) ≥ 0.5 (relative)\" myStopping <- myStopping6 | StoppingMinPatients(40) emptydata <- DataDual(doseGrid = data@doseGrid) design <- DualDesign(   model = model,   data = emptydata,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = CohortSizeConst(3),   startingDose = 6 ) betaMod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) * (delta2^delta2) / ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 } trueBiomarker <- function(dose) {   betaMod(dose, e0 = 0.2, eMax = 0.6, delta1 = 5, delta2 = 5 * 0.5 / 0.5, scal = 100) } trueTox <- function(dose) {   pnorm((dose - 60) / 10) } par(mfrow = c(1, 2)) curve(trueTox(x), from = 0, to = 80) curve(trueBiomarker(x), from = 0, to = 80) mySims <- simulate(design,   trueTox = trueTox,   trueBiomarker = trueBiomarker,   sigma2W = 0.01,   rho = 0,   nsim = 10,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions =     McmcOptions(       burnin = 1000,       step = 1,       samples = 3000     ) ) print(plot(mySims)) ## Note: method with signature 'Simulations#missing' chosen for function 'plot', ##  target signature 'DualSimulations#missing'. ##  \"GeneralSimulations#missing\" would also be valid ## Warning: `qplot()` was deprecated in ggplot2 3.4.0. ## ℹ The deprecated feature was likely used in the crmPack package. ##   Please report the issue at <https://github.com/openpharma/crmPack/issues>. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. sumOut <- summary(mySims,   trueTox = trueTox,   trueBiomarker = trueBiomarker ) sumOut ## Summary of 10 simulations ##  ## Target toxicity interval was 20, 35 % ## Target dose interval corresponding to this was 51.6, 56.1  ## Intervals are corresponding to 10 and 90 % quantiles ##  ## Number of patients overall : mean 42 (42, 42)  ## Number of patients treated above target tox interval : mean 0 (0, 0)  ## Proportions of DLTs in the trials : mean 0 % (0 %, 0 %)  ## Mean toxicity risks for the patients on active : mean 0 % (0 %, 0 %)  ## Doses selected as MTD : mean 0.1 (0.1, 0.1)  ## True toxicity at doses selected : mean 0 % (0 %, 0 %)  ## Proportion of trials selecting target MTD: 0 % ## Dose most often selected as MTD: 0.1  ## Observed toxicity rate at dose most often selected: 0 % ## Fitted toxicity rate at dose most often selected : mean 2 % (1 %, 2 %)  ## Stop reason triggered: ##  P(0.9 ≤ Biomarker ≤ 1) ≥ 0.5 (relative) :  0 % ##  ≥ 40 patients dosed :  100 % ## Fitted biomarker level at dose most often selected : mean 0.2 (0.2, 0.2) print(plot(sumOut))"},{"path":"https://openpharma.github.io/crmPack/articles/example.html","id":"dual-endpoint-designs-with-separate-models","dir":"Articles","previous_headings":"Dual-endpoint dose escalation designs","what":"Dual-endpoint designs with separate models","title":"crmPack: Object-oriented implementation of CRM designs","text":"subsection, look dose-escalation designs model binary DLT responses continuous biomarker/efficacy responses separately. hence assume correlation binary DLT continuous efficacy responses. First, define data sets dual responses using DataDual function just like example given last subsection. example, data2 empty data set 12 dose levels, 25 300 mg increments 25 mg used. variable data4 contains data set binary DLT continuous efficacy responses observations. elements slot x dose levels 8 subjects treated. elements slot y represent corresponding binary DLT responses observed 8 subjects elements slot w represent continuous efficacy responses obtained 8 subjects. Similarly, can also obtain plot data sets using plot function described last subsection. described, model two responses separately. order , use models inheriting ModelPseudo class. binary DLT responses, can use models inheriting ModelTox class. example use models inheriting LogisticIndepBeta class variable DLTmodel (newDLTmodel observations) given previous examples. continuous efficacy responses, can use models inheriting ModelEff class. current version package, two model classes, Effloglog EffFlexi model, inheriting ModelEff class. Since ModelEff also inheriting ModelPseudo class, prior efficacy model also needs specified form pseudo data. (Please refer @ref(fig:model-classes) structure model classes defined package.) following commands show set Effloglog model. efficacy model describe relationship efficacy responses corresponding dose levels double logarithmic (“log-log”) scale. refers linear model three unknown parameters: intercept θ1, slope θ2 precision ν\\nu (inverse variance) efficacy responses. Similarly pseudo models, data set specified setting model: specification prior pseudo data, two dose levels 25 300 mg fixed specified eff_dose slot. eliciting prior expected efficacy values two dose levels (e.g. asking experts’), specified eff slot. example, 1.223 expected efficacy value subjects treated dose 25 mg 2.513 expected efficacy value subjects treated 300 mg. slot nu represents prior precision efficacy responses. example, two positive scalars aa bb specified suggesting prior distribution precision gamma shape parameter =1a=1 rate parameter b=0.025b=0.025. Note , since gamma distribution used prior distribution ν\\nu, posterior distribution gamma distribution, gamma prior precision conjugate normal likelihood. fixed value precision preferred, single positive scalar can also specified nu slot. Finally Data slot specified either empty data set data set currently available observations. Similarly, can also look structure Effmodel applying str function: 15 slots, can accessed @ operator. efficacy model, can obtain prior (using empty data set) posterior modal estimates model parameters θ1 (intercept) θ2 (slope). addition, gamma prior distribution used ν\\nu observations (data) available, can obtain updated values shape aa rate bb parameters gamma distribution, via model. joint prior posterior density functions θ1 θ2 described details (Yeung et al. 2015). Next, describe example flexible semi-parametric function used describe relationship efficacy values corresponding dose levels. differences mean efficacy responses neighboring dose levels modeled either first second order random walk models. flexible model aims capture different shapes dose-efficacy curve. estimate mean efficacy responses obtained dose levels MCMC sampling. % involved obtain prior posterior distribution mean efficacy responses. flexible form can specified using EffFlexi class object. EffFlexi class inheriting ModelEff class prior also specified pseudo data: , similarly , also fixed two dose levels 25 300 mg supplied prior expected efficacy responses 1.223 2.513. variance efficacy responses σ2\\sigma^2 model can specified single positive scalar value two positive scalar values shape aa scale bb parameters inverse gamma distribution slot sigma2. , specified variance efficacy responses inverse gamma distribution shape parameter =0.1a=0.1 scale parameter b=0.1b=0.1. , variance random walk model σβW2\\sigma^2_{\\beta_W} can also specified either single positive scalar two positive scalar parameters inverse gamma distribution slot sigma2betaW. , specified variance random walk model inverse gamma distribution shape parameter =20a=20 scale parameter b=50b=50. addition, can also specify like smooth mean efficacy response function. Either first order (RW1) second order (RW2) random walk model can used describe relationship neighbouring mean efficacy responses specified slot smooth. seen example, RW2, second order random walk model used. Finally, also specify data set Data used model data2 example. structure EffFlexi model object follows: slot names shown can accessed @ operator. value ‘FALSE’ slot useFixed shows variance efficacy response sigma2 variance random walk model `sigma2betaWare fixed, estimated assigned inverse gamma prior distribution model. slotuseRW1also gives 'FALSE' value means second order random walk model used model smooth dose-response function. addition, (internally required) random walk difference matrix rank matrix also shown slotRWmatandRWmatRank`, respectively. discussed, posterior estimates model parameters specified ModelPseudo class (except EffFlexi model class) can obtained modal estimates via MCMC sampling. , first show obtain estimates parameters via MCMC sampling. (Similarly, can also use mcmc function obtain prior posterior samples Effloglog EffFlexi models.) % using Effmodel Effmodel2, respectively data2 options specified earlier Effloglog (Effmodel) model, samples intercept θ1, slope θ2 efficacy linear log-log model precision ν\\nu efficacy responses can obtained. EffFlexi (Effmodel2) model, samples mean efficacy responses dose levels, variance σ2\\sigma^2 (sigma2) efficacy responses variance σβW2\\sigma^2_{\\beta_W} (sigma2betaW) random walk model obtained. also possible look structure (str) extract (get) obtain plots (ggs_traceplot ggs_autocorrelation) samples parameters. MCMC sampling involved, prior posterior modal estimates can obtained output models. observations responses available, can put DataDual data set, given Data slot model. can also updating current model new observations using update function. prior posterior modal estimates model parameters can obtained using @ operator model. example, Effloglog class model: posterior modal estimates θ1 θ2 updated values parameters gamma distribution ν\\nu can read now output . Similarly can update new data EffFlexi class model: plot function can also applied Effloglog model class EffFlexi model class objects, samples parameters generated models:   addition, can also plot fitted dose-efficacy curve using prior posterior modal estimates model parameters MCMC sampling used. example, using Effmodel data set data2 specified earlier:  Since samples involved, curves using prior posterior modal estimates parameters produced, 95% credibility intervals provided. Furthermore, can also plot estimated DLT probability efficacy curve side side using plotDualResponses function. example, using DLTmodel, Effmodel data2 specified earlier examples:  MCMC samples used, :  Next talk dose escalation rules two separate models used dual responses. Increments, CohortSize Stopping rules classes described earlier can applied . now look additional nextBest Stopping classes rules can use situation. , decision choosing next best dose administration based gain function defined (Yeung et al. 2015). gain function represents trade-DLT efficacy responses allocate dose gives best trade-responses. words, dose gives maximum gain value dose allocated next cohort subjects. basic ideas rules follows. % old text: Assume DLT observed subject, gain value observed particular dose level obtained multiplying probability DLT observed dose levels expected efficacy responses DLT observed particular dose level. %new: gain value particular dose level obtained multiplying probability DLT dose level expected efficacy response dose level. data accumulates trial, estimate gain function improve. gain function consists two components, one part DLT responses efficacy response. depends values obtained components affect values gain. example, ideal case probability DLT expected value efficacy response high. gain value obtained high. reason dose gives maximum gain value allocated next cohort subjects. can plot gain function given DLT model specified ModelTox class efficacy model specified ModelEff class using plotGain function. example, using variables newDLTmodel, newEffmodel data set observations, data4, specified earlier examples, :  case MCMC sampling involved prior posterior modal estimates model parameters used. two implemented nextBest rules dual responses using gain function: NextBestMaxGain NextBestMaxGainSamples class object. NextBestMaxGain used MCMC sampling involved use prior posterior modal estimates model parameters obtain gain values dose levels, NextBestMaxGainSamples used MCMC sampling involved obtain posterior estimates. example, MCMC sampling involved: use NextBestMaxGain, specify target probability occurrence DLT used trial end trial. example, target probability DLT used trial end trial 0.35 0.3, respectively. Therefore, rule suggest dose level gives maximum gain value probability DLT less equal 0.35 administer next cohort subjects. end trial, recommend dose maximum gain value probability DLT less equal 0.3. order derive next best dose administration, use nextBest function NextBestMaxGain object given doselimit, DLT efficacy models data set, includes currently available observations: results list numerical values plot illustrating next best dose computed. list numerical values include next best dose suggested, values target probabilities DLT used end trial. Furthermore, estimated doses two targets, well “Gstar” estimated dose (dose gives maximum gain value) provided along corresponding dose level dose grid three estimates. can also get see plot next best dose recommendation using $ operator.  usual, solid red, blue green lines curves represent relationship probability DLT, mean efficacy response gain values, respectively, corresponding dose levels. vertical line purple shows next best dose suggested administration vertical brown line shows maximum allowable dose level administered next cohort subjects. Furthermore, circle square DLT curve also show current estimate estimated TD30 TD35. Next look NextBestMaxGainSamples class object MCMC sampling involved. following code, specify target probabilities DLT used end trial 0.35 0.3 , specify 30% posterior quantile used estimate TD35 TD30, specify 50% posterior quantile Gstar estimate: Note two functions, derive mg_derive specified derive corresponding estimates posterior samples. , generic function nextBest used together rule object derive next best dose: list numerical results given output given using NextBestMaxGain class object includes next dose suggested, current estimates TD30, TD35 Gstar corresponding dose levels dose Grid. can also see plot:  plot, posterior distribution Gstar shown histogram. vertical lines plot show current estimates TD30, TD35 Gstar. addition, next dose maximum allowable dose also given blue red lines, respectively. Next, introduce Stopping rules can applied two classes escalation rules. escalation based two responses two separate pseudo DLT efficacy models, select one dose, minimum estimate TD30 (TDtargetEndOfTrial) optimal gain dose (Gstar) recommended dose potential clinical trials. main feature stopping rules trial stopped current estimates selected quantity ‘accurate’ enough. particular, also consider ratio 95% credibility interval bounds current estimate. smaller ratio, accurate estimate. example, like stop trial ratio less equal 5. functions StoppingMaxGainCIRatio used purpose: note , moment class stoppingMaxGainCIRatio used together stopping class rules “” operator & operator | (still development). Similarly, stopTrial function can used order determine rule fulfilled: % cases either DLT efficacy samples involved. Next, now look construct design objects. also start empty data set, object data3 DataDual class introduced earlier examples. two functions can used. DualResponsesDesign can used without MCMC samples, DualResponsesSamplesDesign can used MCMC samples involved. example, use object Effmodel Effloglog class specified earlier efficacy model following code: can use function DualResponsesSamplesDesign specify design efficacy model specified EffFlexi class object. example, use object Effmodel2 EffFlexi class specified earlier examples : specified three designs using previous rules nextBest (escalation rule), stopping, increments cohort size. Next, specify scenarios simulations. example, simulations using DLT model efficacy model LogisticIndepBeta Effloglog objects, respectively, can specify scenario : true DLT, efficacy gain curves can obtained. can see corresponding curves  Using commands, can obtained DLT (red), efficacy(blue) gain (green) curves also corresponding true values TD30 (TDtargetEndOfTrial), TD35 (TDtargetDuringTrial) Gstar. addition, scenario DLT efficacy can used cases (modal estimates MCMC samples). EffFlexi class object used simulations. Using DLT scenario new efficacy scenario specified corresponding curves can also plotted :  Similarly, also get DLT, efficacy gain values corresponding real values TD30, TD35 Gstar. establishing real scenarios, can simulate trials. First, look two examples Effloglog class object used efficacy model. show first example MCMC samples involved: simulate function used cases simulate trials specified scenarios. , specified true precision (trueNu) efficacy responses 1/0.025. words, used value 0.025 true variance efficacy responses simulation. arguments args,nsim, seed parallel, please refer earlier examples details specification description details. MCMC samples used, can also specify simulations similar way additional argument mcmcOptions EffFlexi class object used efficacy model, generate simulations follows: specification arguments object, args, trueDLE, trueEff, mcmcOptions,nsim,seed,parallel please refer earlier examples details. addition, two arguments used EffFlexi class efficacy model used simulations: First, trueSigma2 specified true variance efficacy responses trueSigma2betaW true variance random walk model used simulation. Furthermore, can also plot, summarize plot summary simulated results using plot summary function:    plots give overview final dose recommendations trial trajectories. addition, also give summary efficacy variance also random walk model variance EffFlexi class object used efficacy model. , summary plot summary simulations can obtained :    first simulation, Sim1 trial stop ratio 95% credibility interval bounds current estimate minimum TD30(TDtargetEndOfTrial) Gstar less equal 5. last two simulations, Sim2 Sim3, use trials stop either maximum 72 patients treated ratio 95% credibility interval less equal 5. can see simulations trials require total around 60 patients study. reminder, dual endpoint dose escalation design uses two separate models describe dose-responses relationship, gain function used determine next best dose final recommended dose end trial. specifically end trial, recommend dose level closest minimum final estimate TD30 (TDtargetEndOfTrial) Gstar. DLT efficacy scenario used first, Sim1 second simulations, Sim2 . real TD30 (TDtargetEndOfTrial) given summary 152.6125 mg dose level doseGrid closest real TD30 150 mg. real Gstar 130.0097 mg dose level dose grid closest Gstar 125 mg. case, real Gstar less real TD30 expect recommendations made dose level close real Gstar. words, scenario, expect recommendations made 125 mg. can see simulated results agrees expecting. summaries plots summaries, 125 mg dose level selected often simulations. scenario last simulation, Sim3, real TD30 real Gstar 125 mg. Since real TD30 greater real Gstar, also expect recommendations made close real Gstar scenario. can see simulated results summary plot summary, procedure also recommends 125 mg often simulations, agrees real scenario. Now, also look fitted dose-DLT dose-efficacy curves obtained three simulations. plots summaries, can see cases, fitted dose-DLT curves (solid-red curve) approximate well real dose-DLT curve (solid-black curve). 95% credibility interval DLT curve (broken-red curves) also given MCMC samples involved simulation. contrast, can see fitted efficacy curve (solid-blue curve) gives good fit real efficacy curve (solid-black) cases. approximation real efficacy curve better linear linear log-log model, Effloglog used, compared flexible form , EffFlexi used. addition, can also see 95% credibility interval efficacy curve (broken-blue line) MCMC sampling efficacy responses involved.","code":"data2 <- DataDual(doseGrid = seq(25, 300, 25))  data4 <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = as.integer(1:8),   cohort = as.integer(c(1, 2, 2, 3, 4, 4, 5, 6)),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25) ) Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data2 ) str(Effmodel) ## Formal class 'Effloglog' [package \"crmPack\"] with 13 slots ##   ..@ eff      : num [1:2] 1.22 2.51 ##   ..@ eff_dose : num [1:2] 25 300 ##   ..@ nu       : Named num [1:2] 1 0.025 ##   .. ..- attr(*, \"names\")= chr [1:2] \"a\" \"b\" ##   ..@ use_fixed: logi FALSE ##   ..@ theta1   : num -1.41 ##   ..@ theta2   : num 2.25 ##   ..@ Pcov     : num [1:2, 1:2] NaN NaN NaN NaN ##   .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   ..@ X        : num [1:2, 1:2] 1 1 1.17 1.74 ##   .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. ..$ : chr [1:2] \"1\" \"2\" ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   .. ..- attr(*, \"assign\")= int [1:2] 0 1 ##   ..@ Y        : num [1:2] 1.22 2.51 ##   ..@ mu       : num [1:2] -1.41 2.25 ##   ..@ Q        : num [1:2, 1:2] 2 2.91 2.91 4.4 ##   .. ..- attr(*, \"dimnames\")=List of 2 ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"log(log(x))\" ##   ..@ const    : num 0 ##   ..@ data     :Formal class 'DataDual' [package \"crmPack\"] with 10 slots ##   .. .. ..@ w       : num(0)  ##   .. .. ..@ x       : num(0)  ##   .. .. ..@ y       : int(0)  ##   .. .. ..@ doseGrid: num [1:12] 25 50 75 100 125 150 175 200 225 250 ... ##   .. .. ..@ nGrid   : int 12 ##   .. .. ..@ xLevel  : int(0)  ##   .. .. ..@ placebo : logi FALSE ##   .. .. ..@ ID      : int(0)  ##   .. .. ..@ cohort  : int(0)  ##   .. .. ..@ nObs    : int 0 Effmodel2 <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = data2 ) str(Effmodel2) ## Formal class 'EffFlexi' [package \"crmPack\"] with 10 slots ##   ..@ eff        : num [1:2] 1.22 2.51 ##   ..@ eff_dose   : num [1:2] 25 300 ##   ..@ sigma2W    : Named num [1:2] 0.1 0.1 ##   .. ..- attr(*, \"names\")= chr [1:2] \"a\" \"b\" ##   ..@ sigma2betaW: Named num [1:2] 20 50 ##   .. ..- attr(*, \"names\")= chr [1:2] \"a\" \"b\" ##   ..@ use_fixed  : Named logi [1:2] FALSE FALSE ##   .. ..- attr(*, \"names\")= chr [1:2] \"sigma2W\" \"sigma2betaW\" ##   ..@ rw1        : logi FALSE ##   ..@ X          : int [1:2, 1:12] 1 0 0 0 0 0 0 0 0 0 ... ##   ..@ RW         : num [1:12, 1:12] 1 -2 1 0 0 0 0 0 0 0 ... ##   ..@ RW_rank    : int 10 ##   ..@ data       :Formal class 'DataDual' [package \"crmPack\"] with 10 slots ##   .. .. ..@ w       : num(0)  ##   .. .. ..@ x       : num(0)  ##   .. .. ..@ y       : int(0)  ##   .. .. ..@ doseGrid: num [1:12] 25 50 75 100 125 150 175 200 225 250 ... ##   .. .. ..@ nGrid   : int 12 ##   .. .. ..@ xLevel  : int(0)  ##   .. .. ..@ placebo : logi FALSE ##   .. .. ..@ ID      : int(0)  ##   .. .. ..@ cohort  : int(0)  ##   .. .. ..@ nObs    : int 0 Effsamples <- mcmc(data = data2, model = Effmodel, options) Effsamples2 <- mcmc(data = data2, model = Effmodel2, options) Effpostsamples <- mcmc(data = data2, model = Effmodel, options) Effpostsamples2 <- mcmc(data = data2, model = Effmodel2, options) newEffmodel <- update(object = Effmodel, data = data4) newEffmodel@theta1 ## [1] -2.81695 newEffmodel@theta2 ## [1] 2.709524 newEffmodel@nu ##         a         b  ## 3.0000000 0.9832955 newEffmodel2 <- update(object = Effmodel2, data = data4) newEffmodel2@RW ##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] ##  [1,]    1   -2    1    0    0    0    0    0    0     0     0     0 ##  [2,]   -2    5   -4    1    0    0    0    0    0     0     0     0 ##  [3,]    1   -4    6   -4    1    0    0    0    0     0     0     0 ##  [4,]    0    1   -4    6   -4    1    0    0    0     0     0     0 ##  [5,]    0    0    1   -4    6   -4    1    0    0     0     0     0 ##  [6,]    0    0    0    1   -4    6   -4    1    0     0     0     0 ##  [7,]    0    0    0    0    1   -4    6   -4    1     0     0     0 ##  [8,]    0    0    0    0    0    1   -4    6   -4     1     0     0 ##  [9,]    0    0    0    0    0    0    1   -4    6    -4     1     0 ## [10,]    0    0    0    0    0    0    0    1   -4     6    -4     1 ## [11,]    0    0    0    0    0    0    0    0    1    -4     5    -2 ## [12,]    0    0    0    0    0    0    0    0    0     1    -2     1 print(plot(Effpostsamples, newEffmodel, data4)) print(plot(Effpostsamples2, newEffmodel2, data4)) print(plot(data2, Effmodel)) ## Warning in fortify(data, ...): Arguments in `...` must be used. ## ✖ Problematic argument: ## • group = group ## ℹ Did you misspell an argument name? plotDualResponses(   DLEmodel = DLTmodel,   Effmodel = Effmodel, data = data2 ) ## Warning in fortify(data, ...): Arguments in `...` must be used. ## ✖ Problematic argument: ## • group = group ## ℹ Did you misspell an argument name? ## Arguments in `...` must be used. ## ✖ Problematic argument: ## • group = group ## ℹ Did you misspell an argument name? plotDualResponses(   DLEmodel = DLTmodel, DLEsamples = DLTsamples,   Effmodel = Effmodel, Effsamples = Effsamples, data = data2 ) plotGain(DLEmodel = newDLTmodel, Effmodel = newEffmodel, data = data4) GainNextBest <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 ) doseRecGain <- nextBest(GainNextBest,   doselimit = max(data4@doseGrid),   model = newDLTmodel,   model_eff = newEffmodel,   data = data4 ) doseRecGain$plot GainsamplesNextBest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(TDsamples) {     as.numeric(quantile(TDsamples, prob = 0.3))   },   mg_derive = function(Gstarsamples) {     as.numeric(quantile(Gstarsamples, prob = 0.5))   } ) doseRecGainSamples <- nextBest(GainsamplesNextBest,   doselimit = max(data4@doseGrid),   model = newDLTmodel,   samples = DLTpostsamples,   model_eff = newEffmodel,   samples_eff = Effpostsamples,   data = data4 ) ## [1] \"Estimated TD 30 = 18.6611868271308 not within dose grid\" doseRecGainSamples$plot myStopping7 <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) myStopping8 <- myStopping7 | StoppingMinPatients(72) stopTrial(   stopping = myStopping7, dose = doseRecGain$next_dose, model = newDLTmodel,   data = data4, Effmodel = newEffmodel ) ## [1] FALSE ## attr(,\"message\") ## [1] \"Gstar estimate is 79.7805 with 95% CI ( 21.5588 , 295.2361 ) and its ratio = 13.6945\"                ## [2] \"TDtargetEndOfTrial estimate is  42.6813 with 95% CI ( 11.0662 , 164.618 ) and its ratio= 14.8758\"    ## [3] \"TDatrgetEndOfTrial estimate is smaller with ratio = 14.8758 which is  greater than target_ratio = 5\" ## attr(,\"report_label\") ## [1] \"GStar 5 for 0.3 target prob\" stopTrial(   stopping = myStopping7,   dose = doseRecGainSamples$next_dose,   samples = DLTpostsamples,   model = newDLTmodel,   data = data4,   TDderive = function(TDsamples) {     quantile(TDsamples, prob = 0.3)   },   Effmodel = newEffmodel,   Effsamples = Effpostsamples,   Gstarderive = function(Gstarsamples) {     quantile(Gstarsamples, prob = 0.5)   } ) ## [1] FALSE ## attr(,\"message\") ## [1] \"Gstar estimate is 50 with 95% CI ( 25 , 300 ) and its ratio = 12\"                                           ## [2] \"TDtargetEndOfTrial estimate is  18.6612 with 95% CI ( 6e-04 , 10459.1345 ) and its ratio= 17110373.1537\"    ## [3] \"TDtargetEndOfTrial estimate is smaller with ratio = 17110373.1537  which is  greater than target_ratio = 5\" ## attr(,\"report_label\") ## [1] \"GStar 5 for 0.3 target prob\" design1 <- DualResponsesDesign(   nextBest = GainNextBest,   model = DLTmodel,   eff_model = Effmodel,   data = data2,   stopping = myStopping7,   increments = myIncrements1,   cohort_size = mySize,   startingDose = 25 )  design2 <- DualResponsesSamplesDesign(   nextBest = GainsamplesNextBest,   model = DLTmodel,   eff_model = Effmodel,   data = data2,   stopping = myStopping8,   increments = myIncrements1,   cohort_size = mySize,   startingDose = 25 ) design3 <- DualResponsesSamplesDesign(   nextBest = GainsamplesNextBest,   model = DLTmodel,   eff_model = Effmodel2,   data = data2,   stopping = myStopping8,   increments = myIncrements1,   cohort_size = mySize,   startingDose = 25 ) myTruthDLT <- probFunction(DLTmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  myTruthGain <- function(dose) {   return(myTruthEff(dose) * (1 - myTruthDLT(dose))) } TruthTD <- doseFunction(DLTmodel, phi1 = -53.66584, phi2 = 10.50499)  GAIN <- function(xi) {   -(-4.8218429 + 3.653058 * log(xi)) / (1 + exp(-53.66584 + 10.50499 * xi)) } Txi <- (optim(1, GAIN, method = \"BFGS\")$par) maxg <- (optim(1, GAIN, method = \"BFGS\")$value) gstar <- exp(Txi) td30 <- TruthTD(0.3) td35 <- TruthTD(0.35) DoseLevels <- seq(2, 300, 1) plot(DoseLevels, myTruthDLT(DoseLevels),   col = \"red\", type = \"l\", lwd = 3, ylab = \"Values\",   ylim = c(0, max(1, max(myTruthEff(DoseLevels)))) ) points(td30, 0.3, col = \"violet\", pch = 15, cex = 2) points(td35, 0.35, col = \"violet\", pch = 16, cex = 2) lines(DoseLevels, myTruthEff(DoseLevels), col = \"blue\", type = \"l\", lwd = 3) lines(DoseLevels, myTruthGain(DoseLevels), col = \"green3\", type = \"l\", lwd = 3) points(gstar, -maxg, col = \"green3\", pch = 17, cex = 2) legend(\"topright\",   bty = \"n\", cex = 1.2, c(     \"p(DLT)=0.3\", \"p(DLT)=0.35\", \"Max gain\", \"p(DLTs)\",     \"efficacy\", \"gain\"   ), text.col = c(\"violet\", \"violet\", \"green3\", \"red\", \"blue\", \"green3\"),   pch = c(15, 16, 17, NA, NA, NA), lty = c(NA, NA, NA, 1, 1, 1), col = c(\"violet\", \"violet\", \"green3\", \"red\", \"blue\", \"green3\") ) myTruthEff1 <- c(   -0.5478867, 0.1645417, 0.5248031, 0.7604467,   0.9333009, 1.0687031, 1.1793942, 1.2726408,   1.3529598, 1.4233411, 1.4858613, 1.5420182 )  d1 <- data2@doseGrid myTruthGain1 <- myTruthEff1 * (1 - myTruthDLT(d1)) maxg1 <- max(myTruthGain1) gstar1 <- data2@doseGrid[which.max(myTruthGain1)] DoseLevels1 <- seq(1, 300, 1) TruthTD <- doseFunction(DLTmodel, phi1 = -53.66584, phi2 = 10.50499) td30 <- TruthTD(0.3) td35 <- TruthTD(0.35) plot(DoseLevels1, myTruthDLT(DoseLevels1),   col = \"red\", type = \"l\",   lwd = 3, ylab = \"Values\", ylim = c(0, max(1, max(myTruthEff1))) ) points(td30, 0.3, col = \"violet\", pch = 15, cex = 2) points(td35, 0.35, col = \"violet\", pch = 16, cex = 2) lines(d1, myTruthEff1, col = \"blue\", type = \"l\", lwd = 3) lines(d1, myTruthGain1, col = \"green3\", type = \"l\", lwd = 3) points(gstar1, maxg1, col = \"green3\", pch = 17, cex = 2) legend(\"topright\",   bty = \"n\", cex = 1.2, c(     \"p(DLT)=0.3\", \"p(DLT)=0.35\",     \"Max gain\", \"p(DLTs)\", \"efficacy\", \"gain\"   ), text.col = c(     \"violet\", \"violet\",     \"green3\", \"red\", \"blue\", \"green3\"   ), pch = c(15, 16, 17, NA, NA, NA),   lty = c(NA, NA, NA, 1, 1, 1), col = c(\"violet\", \"violet\", \"green3\", \"red\", \"blue\", \"green3\") ) Sim1 <- simulate(   object = design1,   args = NULL,   trueDLE = myTruthDLT,   trueEff = myTruthEff,   trueNu = 1 / 0.025,   nsim = 10,   seed = 819,   parallel = FALSE ) Sim2 <- simulate(   object = design2,   args = NULL,   trueDLE = myTruthDLT,   trueEff = myTruthEff,   trueNu = 1 / 0.025,   nsim = 10,   seed = 819,   mcmcOptions = options,   parallel = FALSE ) Sim3 <- simulate(   object = design3,   args = NULL,   trueDLE = myTruthDLT,   trueEff = myTruthEff1,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   mcmcOptions = options,   nsim = 10,   seed = 819,   parallel = FALSE ) plot(Sim1) ## Note: method with signature 'PseudoSimulations#missing' chosen for function 'plot', ##  target signature 'PseudoDualSimulations#missing'. ##  \"GeneralSimulations#missing\" would also be valid plot(Sim2) plot(Sim3) Sum1 <- summary(Sim1,   trueDLE = myTruthDLT,   trueEff = myTruthEff ) Sum1 ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 16 (15, 19)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (3, 3)  ## Number of patients treated above the target p(DLE) used during a trial : mean 3 (3, 3)  ## Proportions of observed DLT in the trials : mean 21 % (20 %, 23 %)  ## Mean toxicity risks for the patients : mean 21 % (20 %, 21 %)  ## Doses selected as TDEOT : mean 100 (97.5, 102.5)  ## True toxicity at TDEOT : mean 1 % (0 %, 1 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 100  ## Observed toxicity rate at dose most often selected: 0 % ## Fitted probabilities of DLE at dose most often selected : mean 24 % (24 %, 24 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    98.18  123.81  123.81  122.23  123.81  133.63   ## The summary table of the final ratios of the TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    3.849   4.447   4.447   4.442   4.447   4.993   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    118.2   144.4   144.4   143.5   144.4   161.5   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    98.18  123.81  123.81  122.23  123.81  133.63   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    3.849   4.447   4.447   4.442   4.447   4.993   ##  ## Stop reason triggered: ##  GStar 5 for 0.3 target prob :  100 % ## Target Gstar, the dose which gives the maximum gain value was 130.0097  ## Target Gstar at dose Grid was 125  ## The summary table of the final Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    142.9   146.7   152.1   152.6   153.1   178.6   ## The summary table of the final ratios of the Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    6.807   6.985   7.188   7.691   7.472  10.729   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    98.18  123.81  123.81  122.23  123.81  133.63   ## The summary table of the final ratios of the optimal dose for stopping across ##         all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    3.849   4.447   4.447   4.442   4.447   4.993   ## Fitted expected efficacy level at dose most often selected : mean 0.9 (0.9, 1)  ## Stop reason triggered: ##  GStar 5 for 0.3 target prob :  100 % print(plot(Sum1)) Sum2 <- summary(Sim2,   trueDLE = myTruthDLT,   trueEff = myTruthEff ) Sum2 ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 45 (36, 51)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 8 (3, 12)  ## Number of patients treated above the target p(DLE) used during a trial : mean 8 (3, 12)  ## Proportions of observed DLT in the trials : mean 19 % (17 %, 20 %)  ## Mean toxicity risks for the patients : mean 19 % (15 %, 25 %)  ## Doses selected as TDEOT : mean 120 (100, 125)  ## True toxicity at TDEOT : mean 4 % (1 %, 5 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 125  ## Observed toxicity rate at dose most often selected: 6 % ## Fitted probabilities of DLE at dose most often selected : mean 25 % (23 %, 27 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    115.0   127.6   135.9   132.4   138.6   143.8   ## The summary table of the final ratios of the TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    133.2   151.0   155.9   154.2   159.3   168.8   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    115.0   127.6   135.9   132.4   138.6   143.8   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ##  ## Stop reason triggered: ##  GStar 5 for 0.3 target prob :  100 % ##  ≥ 72 patients dosed :  0 % ## Target Gstar, the dose which gives the maximum gain value was 130.0097  ## Target Gstar at dose Grid was 125  ## The summary table of the final Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    150.0   175.0   187.5   182.5   200.0   200.0   ## The summary table of the final ratios of the Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##      2.4     2.4     2.4     2.4     2.4     2.4   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    115.0   127.6   135.9   132.4   138.6   143.8   ## The summary table of the final ratios of the optimal dose for stopping across ##         all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ## Fitted expected efficacy level at dose most often selected : mean 1 (1, 1)  ## Stop reason triggered: ##  GStar 5 for 0.3 target prob :  100 % ##  ≥ 72 patients dosed :  0 % print(plot(Sum2)) Sum3 <- summary(Sim3,   trueDLE = myTruthDLT,   trueEff = myTruthEff1 ) Sum3 ## Summary of 10 simulations ##  ## Target probability of DLE p(DLE) used at the end of a trial was 30 % ## The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  ## TDEOT at dose Grid was 150  ## Target p(DLE) used during a trial was 35 % ## The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  ## TDDT at dose Grid was 150  ## Number of patients overall : mean 50 (39, 58)  ## Number of patients treated above the target p(DLE) used at the end of a trial : mean 8 (6, 12)  ## Number of patients treated above the target p(DLE) used during a trial : mean 8 (6, 12)  ## Proportions of observed DLT in the trials : mean 21 % (18 %, 24 %)  ## Mean toxicity risks for the patients : mean 20 % (15 %, 24 %)  ## Doses selected as TDEOT : mean 115 (100, 125)  ## True toxicity at TDEOT : mean 3 % (1 %, 5 %)  ## Proportion of trials selecting the TDEOT: 0 % ## Proportion of trials selecting the TDDT: 0 % ## Dose most often selected as TDEOT: 125  ## Observed toxicity rate at dose most often selected: 4 % ## Fitted probabilities of DLE at dose most often selected : mean 27 % (25 %, 28 %)  ## The summary table of the final TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    113.1   123.7   127.0   127.0   130.0   137.2   ## The summary table of the final ratios of the TDEOT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ## The summary table of the final TDDT across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    128.9   143.6   149.2   149.0   154.4   169.5   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    113.1   123.7   127.0   127.0   130.0   137.2   ## The summary table of the final ratios of the optimal dose for stopping across ##                   all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ##  ## Stop reason triggered: ##  GStar 5 for 0.3 target prob :  100 % ##  ≥ 72 patients dosed :  0 % ## Target Gstar, the dose which gives the maximum gain value was 125  ## Target Gstar at dose Grid was 125  ## The summary table of the final Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    250.0   250.0   250.0   262.5   275.0   300.0   ## The summary table of the final ratios of the Gstar across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    1.333   1.500   1.857   1.938   2.000   3.000   ## The summary table of dose levels, the optimal dose ##  to recommend for subsequent study across all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##    113.1   123.7   127.0   127.0   130.0   137.2   ## The summary table of the final ratios of the optimal dose for stopping across ##         all simulations ##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   ##        1       1       1       1       1       1   ## Fitted expected efficacy level at dose most often selected : mean 0.9 (0.9, 1)  ## Stop reason triggered: ##  GStar 5 for 0.3 target prob :  100 % ##  ≥ 72 patients dosed :  0 % print(plot(Sum3)) # nolint end"},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Describing `crmPack` Objects","text":"Objects created crmPack almost always S4 objects. Like S4 objects, default render particularly user-friendly way. Fortunately, little known feature knitr can put right little cost end user: simplest case, demonstrated , needs done reference object markdown Quarto chunk. Defined number toxicities far observed knit_printmethods provided crmPack intended fully customisable comprehensive. believe, however, cover vast majority use-cases easily extended using techniques described later vignette. Formatting objects currently works HMTL output. another format - PDF Microsoft Word - required, suggested workaround create HTML output print save document required format.","code":"cs <- CohortSizeDLT(intervals = 0:2, cohort_size = c(1, 3, 5)) cs ## An object of class \"CohortSizeDLT\" ## Slot \"intervals\": ## [1] 0 1 2 ##  ## Slot \"cohort_size\": ## [1] 1 3 5 cs"},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"how-is-this-done","dir":"Articles","previous_headings":"","what":"How is this done?","title":"Describing `crmPack` Objects","text":"running code console, result R function statement assigned object printed. (Unless, course, returned invisiblely.) process appears happen chunks markdown Quarto document evaluated. quite case. Instead, result passed S3 function called knit_print (Xie 2024). results running knit_print returned expression appear rendered document. simple demonstration concept, consider: actions knit_print entirely arbitrary, mechanism provides developers easy way provide nicely-rendered versions objects rendered knitr. provided methods (almost) crmPack classes.","code":"knit_print.DustySpringfield <- function(x, ...) {   \"I just don't know what to do with myself\" }  lyric <- 10  lyric ## [1] 10 class(lyric) <- \"DustySpringfield\"  lyric ## I just don't know what to do with myself"},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"using-knit_print-in-crmpack","dir":"Articles","previous_headings":"","what":"Using knit_print in crmPack","title":"Describing `crmPack` Objects","text":"default, needs done reference object printed markdown quarto chunk. equivalent knit_print(object). However, knit_print methods crmPack classes optional arguments can used customise way object rendered. change default value parameter knit_print function must called explicitly: knit_print(cs, tox_label = \"DLAE\").","code":""},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"common-customisations","dir":"Articles","previous_headings":"Using knit_print in crmPack","what":"Common customisations","title":"Describing `crmPack` Objects","text":"commonly needed customisations alter way participants toxicities described. handled label tox_label arguments knit_print. arguments can provided either scalar vector length 2. vector, first element taken describe single instance second number instances. scalar, converted vector, whose first element scalar value provided second scalar \"s\" appended1. , example: constant size 3 participants. constant size 3 subjects. Dose units defined units parameter. default, units printed. participants yet evaluable. dose grid 0.1, 0.3, 0.9, 2.5, 5, 10 15. participants yet evaluable. dose grid 0.1 mg/dL, 0.3 mg/dL, 0.9 mg/dL, 2.5 mg/dL, 5 mg/dL, 10 mg/dL 15 mg/dL. format used display dose levels (information classes) can changed fmt parameter: participants yet evaluable. dose grid 0.10 mg/dL, 0.30 mg/dL, 0.90 mg/dL, 2.50 mg/dL, 5.00 mg/dL, 10.00 mg/dL 15.00 mg/dL. biomarker_label biomarker_units allow representation biomarker customised. relationships dose toxicity dose PD biomarker modelled simultaneously. probit log normal model describe relationship dose toxicity: Φ−1(Tox|d)=f(X=1|θ,d)=α+β⋅log(d/d*) \\Phi^{-1}(Tox | d) = f(X = 1 | \\theta, d) = \\alpha + \\beta \\cdot log(d/d^*) d* denotes reference dose. prior θ given by𝛉=[αβ]∼N([0.001.00],[1.000.000.001.00]) \\boldsymbol\\theta = \\begin{bmatrix}\\alpha \\\\ \\beta\\end{bmatrix}\\sim N \\left(\\begin{bmatrix} 0.00 \\\\  1.00\\end{bmatrix} , \\begin{bmatrix} 1.00 &  0.00 \\\\ 0.00 &  1.00\\end{bmatrix} \\right) reference dose 1.00. PD biomarker response w dose d modelled w(d)∼N(f(d),σw2) w(d) \\sim N(f(d), \\sigma_w^2) f(d) first order random walk f(d)=βWi−βWi−1∼N(0,0.01×(di−di−1)) f(d) = \\beta_{W_i} - \\beta_{W_{- 1}}\\sim N(0, 0.01 \\times (d_i - d_{- 1})) relationships dose toxicity dose PD biomarker modelled simultaneously. probit log normal model describe relationship dose toxicity: Φ−1(Tox|d)=f(X=1|θ,d)=α+β⋅log(d/d*) \\Phi^{-1}(Tox | d) = f(X = 1 | \\theta, d) = \\alpha + \\beta \\cdot log(d/d^*) d* denotes reference dose. prior θ given by𝛉=[αβ]∼N([0.001.00],[1.000.000.001.00]) \\boldsymbol\\theta = \\begin{bmatrix}\\alpha \\\\ \\beta\\end{bmatrix}\\sim N \\left(\\begin{bmatrix} 0.00 \\\\  1.00\\end{bmatrix} , \\begin{bmatrix} 1.00 &  0.00 \\\\ 0.00 &  1.00\\end{bmatrix} \\right) reference dose 1.00. PD biomarker response w dose d modelled w(d)∼N(f(d),σw2) w(d) \\sim N(f(d), \\sigma_w^2) f(d) first order random walk f(d)=βWi−βWi−1∼N(0,0.01×(di−di−1)) f(d) = \\beta_{W_i} - \\beta_{W_{- 1}}\\sim N(0, 0.01 \\times (d_i - d_{- 1}))","code":"CohortSizeConst(3) knit_print(CohortSizeConst(3), label = \"subject\") d <- Data(doseGrid = c(0.1, 0.3, 0.9, 2.5, 5, 10, 15)) d knit_print(d, units = \"mg/dL\") knit_print(d, units = \"mg/dL\", fmt = \"%.2f\") x <- .DefaultDualEndpointRW() x knit_print(x, biomarker_name = \"CRP\", biomarker_units = \"mg/dL\")"},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"rendering-complex-classes","dir":"Articles","previous_headings":"","what":"Rendering complex classes","title":"Describing `crmPack` Objects","text":"crmPack classes slots whose values crmPack classes. CohortSizeMax simple example. cases, slot values passed knit_print turn. Defined dose used next cohort Defined number toxicities far observed knit_print methods sub-classes RuleDesign (related classes) offer slightly control. , overall header rendition object provided title parameter (whose value defaults “Design” slot values separated sub-headers. styling overall header sub-headers controlled level parameter. default value level 2L, level slots defined recursively one level parent slot2. Class-specific parameters passed slot-specific knit_print methods using ....","code":".DefaultCohortSizeMax() knit_print(.DefaultDesign())"},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"dose-toxicity-model","dir":"Articles","previous_headings":"Design","what":"Dose toxicity model","title":"Describing `crmPack` Objects","text":"logistic log normal model describe relationship dose toxicity: p(Tox|d)=f(X=1|θ,d)=eα+β⋅log(d/dref)1+eα+β⋅log(d/dref) p(Tox | d) = f(X = 1 | \\theta, d) = \\frac{e^{\\alpha + \\beta \\cdot log(d/d_{ref})}}{1 + e^{\\alpha + \\beta \\cdot log(d/d_{ref})}} dref denotes reference dose. prior θ given by𝛉=[αlog(β)]∼N([−0.851.00],[1.00−0.50−0.501.00]) \\boldsymbol\\theta = \\begin{bmatrix}\\alpha \\\\ log(\\beta)\\end{bmatrix}\\sim N \\left(\\begin{bmatrix}-0.85 \\\\  1.00\\end{bmatrix} , \\begin{bmatrix} 1.00 & -0.50 \\\\ -0.50 &  1.00\\end{bmatrix} \\right) reference dose 56.00.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"stopping-rule","dir":"Articles","previous_headings":"Design","what":"Stopping rule","title":"Describing `crmPack` Objects","text":"either following rules TRUE: following rules TRUE: ≥ 3 cohorts dosed: 3 cohorts treated. P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5: probability toxicity next best dose range [0.20, 0.35] least 0.50. ≥ 20 patients dosed: 20 participants treated.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"escalation-rule","dir":"Articles","previous_headings":"Design","what":"Escalation rule","title":"Describing `crmPack` Objects","text":"Defined highest dose administered far","code":""},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"use-of-placebo","dir":"Articles","previous_headings":"Design","what":"Use of placebo","title":"Describing `crmPack` Objects","text":"Placebo administered trial.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"dose-recommendation","dir":"Articles","previous_headings":"Design","what":"Dose recommendation","title":"Describing `crmPack` Objects","text":"dose recommended next cohort chosen following way. First, doses ineligible according increments rule discarded. Next, dose mean posterior probability toxicity overdose range - (0.35, 1] - 0.25 also discarded. Finally, dose amongst remaining highest chance mean posterior probability toxicity target toxicity range 0.2 0.35 (inclusive) selected.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"cohort-size","dir":"Articles","previous_headings":"Design","what":"Cohort size","title":"Describing `crmPack` Objects","text":"Defined dose used next cohort Defined number toxicities far observed","code":""},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"observed-data","dir":"Articles","previous_headings":"Design","what":"Observed data","title":"Describing `crmPack` Objects","text":"participants yet evaluable. dose grid 1, 3, 5, 10, 15, 20, 25, 40, 50, 80 100.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"starting-dose","dir":"Articles","previous_headings":"Design","what":"Starting dose","title":"Describing `crmPack` Objects","text":"starting dose 3. Slot headers can customised using sections parameter. sections named vector. Names valid slot names object rendered values requested slot headers. Outputnotshown.Output shown. possible omit slots rendition crmPack object. need , can either render required slots individually, override definition knit_print super class demonstrated .","code":"knit_print(   .DefaultDesign(),   level = 4,   sections = c(     \"nextBest\" = \"Selection of the dose for the following cohort\",     \"startingDose\" = \"Initial dose\"   ) )"},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"restoring-console-like-behaviour","dir":"Articles","previous_headings":"","what":"Restoring console-like behaviour","title":"Describing `crmPack` Objects","text":"restore default behaviour crmPack objects, simply wrap object call normal_print().","code":"normal_print(cs) ## An object of class \"CohortSizeDLT\" ## Slot \"intervals\": ## [1] 0 1 2 ##  ## Slot \"cohort_size\": ## [1] 1 3 5"},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"accessing-the-output-of-knit_print","dir":"Articles","previous_headings":"","what":"Accessing the output of knit_print","title":"Describing `crmPack` Objects","text":"One parameters knitr::knit_print asis, default value TRUE. asis effect setting chunk option output asis. achieved returning object class knit-asis. Setting asis FALSE display raw HTML code generated knit_print displayed. Alternatively, may allow easier manipulation return value. Defined number toxicities far observed chunk option output set asis…","code":"csOutput1 <- knit_print(CohortSizeDLT(intervals = 0:2, cohort_size = c(1, 3, 5))) class(csOutput1) ## [1] \"knit_asis\" csOutput1 csOutput2 <- knit_print(CohortSizeDLT(intervals = 0:2, cohort_size = c(1, 3, 5)), asis = FALSE) class(csOutput2) ## [1] \"character\" csOutput2 ## [1] \"<table>\\n<caption>Defined by the number of toxicities so far observed<\/caption>\\n <thead>\\n<tr>\\n<th style=\\\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \\\" colspan=\\\"2\\\"><div style=\\\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \\\">No of toxicities<\/div><\/th>\\n<th style=\\\"empty-cells: hide;border-bottom:hidden;\\\" colspan=\\\"1\\\"><\/th>\\n<\/tr>\\n  <tr>\\n   <th style=\\\"text-align:right;\\\"> Lower <\/th>\\n   <th style=\\\"text-align:right;\\\"> Upper <\/th>\\n   <th style=\\\"text-align:right;\\\"> Cohort size <\/th>\\n  <\/tr>\\n <\/thead>\\n<tbody>\\n  <tr>\\n   <td style=\\\"text-align:right;\\\"> 0 <\/td>\\n   <td style=\\\"text-align:right;\\\"> 1 <\/td>\\n   <td style=\\\"text-align:right;\\\"> 1 <\/td>\\n  <\/tr>\\n  <tr>\\n   <td style=\\\"text-align:right;\\\"> 1 <\/td>\\n   <td style=\\\"text-align:right;\\\"> 2 <\/td>\\n   <td style=\\\"text-align:right;\\\"> 3 <\/td>\\n  <\/tr>\\n  <tr>\\n   <td style=\\\"text-align:right;\\\"> 2 <\/td>\\n   <td style=\\\"text-align:right;\\\"> Inf <\/td>\\n   <td style=\\\"text-align:right;\\\"> 5 <\/td>\\n  <\/tr>\\n<\/tbody>\\n<\/table>\\n\\n\" cat(csOutput2) ## <table> ## <caption>Defined by the number of toxicities so far observed<\/caption> ##  <thead> ## <tr> ## <th style=\"border-bottom:hidden;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; \" colspan=\"2\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \">No of toxicities<\/div><\/th> ## <th style=\"empty-cells: hide;border-bottom:hidden;\" colspan=\"1\"><\/th> ## <\/tr> ##   <tr> ##    <th style=\"text-align:right;\"> Lower <\/th> ##    <th style=\"text-align:right;\"> Upper <\/th> ##    <th style=\"text-align:right;\"> Cohort size <\/th> ##   <\/tr> ##  <\/thead> ## <tbody> ##   <tr> ##    <td style=\"text-align:right;\"> 0 <\/td> ##    <td style=\"text-align:right;\"> 1 <\/td> ##    <td style=\"text-align:right;\"> 1 <\/td> ##   <\/tr> ##   <tr> ##    <td style=\"text-align:right;\"> 1 <\/td> ##    <td style=\"text-align:right;\"> 2 <\/td> ##    <td style=\"text-align:right;\"> 3 <\/td> ##   <\/tr> ##   <tr> ##    <td style=\"text-align:right;\"> 2 <\/td> ##    <td style=\"text-align:right;\"> Inf <\/td> ##    <td style=\"text-align:right;\"> 5 <\/td> ##   <\/tr> ## <\/tbody> ## <\/table>"},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"sec-override","dir":"Articles","previous_headings":"","what":"Providing your own knit_print method","title":"Describing `crmPack` Objects","text":"methods provided crmPack don’t want, ’s easy roll , using standard S3 techniques. formal arguments knitr::knit_print x .... Additional arguments can added .... example, consider knit_print.NextBestNCRM, currently returns paragraph text: dose recommended next cohort chosen following way. First, doses ineligible according increments rule discarded. Next, dose mean posterior probability toxicity overdose range - (0.35, 1] - 0.25 also discarded. Finally, dose amongst remaining highest chance mean posterior probability toxicity target toxicity range 0.2 0.35 (inclusive) selected. might feel better presented bulleted list. can achieve follows3: dose recommended next cohort chosen following way. First, doses ineligible according increments rule discarded. Next, dose mean posterior probability toxicity overdose range - (0.35, 1] - 0.25 also discarded. Finally, dose amongst remaining highest chance mean posterior probability toxicity target toxicity range 0.2 0.35 (inclusive) selected.","code":".DefaultNextBestNCRM() knit_print.NextBestNCRM <- function(x, ...) {   knitr::asis_output(     paste0(       \"The dose recommended for the next cohort will be chosen in the following \",       \"way.\\n\\n-  First, doses that are ineligible according to the increments rule \",       \"will be discarded.\\n-  Next, any dose for which the mean posterior probability of \",       \" toxicity being in the overdose range - (\",       x@overdose[1], \", \", x@overdose[2],       \"] - is \",       x@max_overdose_prob,       \" or more will also be discarded.\\n-  Finally, the dose amongst those remaining \",       \"which has the highest chance that the mean posterior probability of toxicity \",       \"is in the target toxicity range of \",       x@target[1],       \" to \",       x@target[2],       \" (inclusive) will be selected.\\n\\n\"     )   ) } registerS3method(\"knit_print\", \"NextBestNCRM\", knit_print.NextBestNCRM)  .DefaultNextBestNCRM()"},{"path":"https://openpharma.github.io/crmPack/articles/knit_print.html","id":"class-coverage","dir":"Articles","previous_headings":"","what":"Class coverage","title":"Describing `crmPack` Objects","text":"crmPack defines 124 classes. Custom knit_print methods exist 91 . remaining 33 classes, 23 virtual classes never directly instantiated end users. leaves 10 classes knit_print methods may useful. classes listed . majority classes relate simulation operating characteristics CRM trials. Reporting information likely need customisation beyond scope simple function4.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"naming-convention-motivation","dir":"Articles","previous_headings":"Class and slot changes","what":"Naming convention motivation","title":"Migrating from crmPack version 1.0.3","text":"close common R style guidelines (Wickham 2019) use consistent naming conventions within crmPack package, CamelCase notation used class names, method names constructor function names, snake_case notation used slot names throughout package.","code":""},{"path":[]},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"renamed-slots","dir":"Articles","previous_headings":"Class and slot changes","what":"Renamed slots","title":"Migrating from crmPack version 1.0.3","text":"Strikeout indicates class/slot removed.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"moved-dose-and-prob-functions-from-slots-to-methods","dir":"Articles","previous_headings":"","what":"Moved dose and prob Functions from Slots to Methods","title":"Migrating from crmPack version 1.0.3","text":"Moved dose prob functions model class slots model class methods. Example usage: dose/prob function true dose-DLT/DLT-dose relationship.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"generate-data-define-a-model-and-get-samples","dir":"Articles","previous_headings":"Moved dose and prob Functions from Slots to Methods","what":"Generate data, define a model and get samples","title":"Migrating from crmPack version 1.0.3","text":"","code":"library(crmPack) ## Loading required package: ggplot2 ## Registered S3 method overwritten by 'crmPack': ##   method       from   ##   print.gtable gtable ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100)) my_model <- LogisticNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2) ) my_options <- McmcOptions(burnin = 2, step = 2, samples = 20) my_samples <- mcmc(empty_data, my_model, my_options)"},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"dose","dir":"Articles","previous_headings":"Moved dose and prob Functions from Slots to Methods","what":"Dose","title":"Migrating from crmPack version 1.0.3","text":"example dose function can used case different inputs, .e. model’s parameters samples case fixed model’s parameters values.","code":"# Doses reaching a specific target probability of the occurrence of a DLT (equal to 0.3), # given a particular models and samples. # Every single dose corresponds to one particular sample in `my_samples`. dose(0.3, my_model, my_samples) ##  [1] 3.627066e+00 1.729391e+00 5.412067e-02 4.597568e-02 1.459530e+00 ##  [6] 2.354449e+00 4.922394e-04 1.995678e+00 1.083813e+01 7.295046e-03 ## [11] 1.151084e+00 3.980640e+00 6.639275e+05 1.329529e+00 2.148389e+00 ## [16] 2.110068e+00 5.707821e-01 1.832073e+00 5.604318e-01 7.969322e-02 # True dose-DLT relationship. # Say that -0.8 and 1 are the true values for models parameters alpha0 and alpha1 respectively. # The `true_dose_fun` takes one argument (target probability of the occurrence of a DLT) # and computes the corresponding dose, according to the model chosen and given a fixed values # of the model's parameters. true_dose_fun <- doseFunction(my_model, alpha0 = -0.8, alpha1 = 1) true_dose_fun(0.3) ## [1] 0.9538033"},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"prob","dir":"Articles","previous_headings":"Moved dose and prob Functions from Slots to Methods","what":"Prob","title":"Migrating from crmPack version 1.0.3","text":"","code":"# Toxicity probabilities for a given dose (equal to 10), model and samples. # Every single probability value corresponds to one particular sample in `my_samples`. prob(10, my_model, my_samples) ##  [1] 0.3560095 0.9757586 0.8823815 0.8666537 0.9852098 0.7021902 0.6409735 ##  [8] 0.9719922 0.3118609 0.5950865 0.9977517 0.1273838 0.4654049 0.8984306 ## [15] 0.6625308 0.6623657 0.9971038 0.9805380 0.9230932 0.7079049 # True DLT-dose relationship. # Say that -0.8 and 1 are the true values for models parameters alpha0 and alpha1 respectively. # The `true_prob_fun` takes one argument (the dose) and computes the corresponding # toxicity probability, according to the model chosen and given a fixed values # of the model's parameters. true_prob_fun <- probFunction(my_model, alpha0 = -0.8, alpha1 = 1) true_prob_fun(10) ## [1] 0.8179597"},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"new-random-number-generator-settings-for-the-mcmc","dir":"Articles","previous_headings":"","what":"New Random Number Generator settings for the MCMC","title":"Migrating from crmPack version 1.0.3","text":"Random Number Generator (RNG) settings used JAGS MCMC now configured solely McmcOptions class. RNG settings : RNG type RNG seed corresponds given RNG type. Find details help page McmcOptions class. RNG-related user settings R session level (us set.seed()) ignored MCMC sampler.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"new-no-argument-constructors","dir":"Articles","previous_headings":"","what":"New no-argument constructors","title":"Migrating from crmPack version 1.0.3","text":"aid software development, new -argument constructs sub-classes GeneralModel, Increments, NextBest Stopping introduced. names constructors take form .Default<classname>, <classname> name class created. constructors return valid, necessarily contextually sensible, objects required class. One reason objects returned may contextually sensible constructors take account associated doseGrid. examples use: following rules TRUE: ≥ 3 cohorts dosed: 3 cohorts treated. P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5: probability toxicity next best dose range [0.20, 0.35] least 0.50. ≥ 20 patients dosed: 20 participants treated. logistic log normal model describe relationship dose toxicity: p(Tox|d)=f(X=1|θ,d)=eα+β⋅d/d*1+eα+β⋅d/d* p(Tox | d) = f(X = 1 | \\theta, d) = \\frac{e^{\\alpha + \\beta \\cdot d/d^*}}{1 + e^{\\alpha + \\beta \\cdot d/d^*}} d* denotes reference dose. prior θ given by𝛉=[αβ]∼N([−0.851.00],[1.00−0.50−0.501.00]) \\boldsymbol\\theta = \\begin{bmatrix}\\alpha \\\\ \\beta\\end{bmatrix}\\sim N \\left(\\begin{bmatrix}-0.85 \\\\  1.00\\end{bmatrix} , \\begin{bmatrix} 1.00 & -0.50 \\\\ -0.50 &  1.00\\end{bmatrix} \\right) reference dose 1.00.","code":".DefaultStoppingAll() class_name <- \"LogisticNormal\" eval(parse(text = paste0(\".Default\", class_name, \"()\")))"},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"handling-of-na-or-placebo-returned-as-next-dose","dir":"Articles","previous_headings":"","what":"Handling of NA or placebo returned as next dose","title":"Migrating from crmPack version 1.0.3","text":"consistent handling study stopped facilitate analysis stop reasons operation characteristics, handling NA placebo returned nextBest methods changed. previous version crmPack stopping placebo NA returned nextBest method handled automatically generic Stopping method. now moved new stopping rule StoppingMissingDose. consequence, stopping rule StoppingMissingDose must specified nextBest methods can return NA, placebo used. Otherwise simulation may run error study stopped NA returned next dose. nextBest methods can return NA NextBestNCRM, NextBestNCRMLoss NextBestDualEndpoint.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"evaluation-of-stopping-rules-at-a-specific-dose","dir":"Articles","previous_headings":"","what":"Evaluation of stopping rules at a specific dose","title":"Migrating from crmPack version 1.0.3","text":"Without specification, stopping rules evaluated dose returned used nextBest method. new stopping rule StoppingSpecificDose possible evaluate stopping rules dose. usage see documentation StoppingSpecificDose.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"classes","dir":"Articles","previous_headings":"Further details in class and methods name changes","what":"Classes","title":"Migrating from crmPack version 1.0.3","text":"Strikeout indicates class/slot removed.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/migration_from_the_old_crmPack.html","id":"methods","dir":"Articles","previous_headings":"Further details in class and methods name changes","what":"Methods","title":"Migrating from crmPack version 1.0.3","text":"Strikeout indicates method/argument removed.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/ordinal-crm.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Ordinal CRM","text":"original CRM model introduced (O’Quigley, Pepe, Fisher 1990) dichotomises toxicity events either “toxic” “DLT”. ordinal CRM generalises model classifying toxicities ordinal scale arbitrary number categories (though use three four unusual). approach particularly useful non-oncology settings, greater interest adverse events dose limiting nonetheless undesirable.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/ordinal-crm.html","id":"ordinal-data","dir":"Articles","previous_headings":"Implementation","what":"Ordinal data","title":"Ordinal CRM","text":"crmPack uses DataOrdinal class record data observed ordinal CRM trial. OrdinalData class differs Data class contains extra slot, yCategories, defines number toxicity grades labels.example: defines DataOrdinal object three toxicity grades, labelled “tox`”, “Sub-tox AE” “DLT”. Note yCategories slot must integer vector values ordered 0 length(yCategories) - 1. labels must unique. first entry, must value 0, always regarded “event” category. See [LogisticLogNormalOrdinal class] . update, plot dose_grid_range methods work exactly Data objects:","code":"empty_ordinal_data <- DataOrdinal(   doseGrid = c(seq(from = 10, to = 100, by = 10)),   yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L),   placebo = FALSE ) dose_grid_range(empty_ordinal_data) #> [1]  10 100  ordinal_data <- update(empty_ordinal_data, x = 10, y = 0) ordinal_data <- update(ordinal_data, x = 20, y = 0) ordinal_data <- update(ordinal_data, x = 30, y = 0) ordinal_data <- update(ordinal_data, x = 40, y = 0) ordinal_data <- update(ordinal_data, x = 50, y = c(0, 1, 0)) ordinal_data <- update(ordinal_data, x = 60, y = c(0, 1, 2))  plot(ordinal_data)"},{"path":"https://openpharma.github.io/crmPack/articles/ordinal-crm.html","id":"the-logisticlognormalordinal-class","dir":"Articles","previous_headings":"Implementation","what":"The LogisticLogNormalOrdinal class","title":"Ordinal CRM","text":"crmPack fits constrained logistic log normal model ordinal data. logit probability toxicity grade given dose modelled log odds space linear regression common slope different intercept toxicity grade. Note, unlike model classes, LogisticLogNormalOrdinal requires diagonal covariance matrix. constraints $alpha;s - intercept parameters - imposes correlation model’s parameters. Thus, covariance structure requested end user honoured model. Let pk(d) probability response patient treated dose d category k higher, k=0, …, K; d=1, …, D. log⁡(p1−p)=αk+β⋅log⁡(ddref) \\log \\left( \\frac{p}{1-p}\\right) = \\alpha_k + \\beta \\cdot \\log \\left( \\frac{d}{d_{ref}} \\right)   k=1, …, K [p0(d) = 1 definition] dref reference dose. αs constrained α1 > α2 > … > αK. priors model’s parameters : αk∼N(μαk,σαk2) \\alpha_k \\sim N(\\mu_{\\alpha_k}, \\sigma_{\\alpha_k}^2) log⁡(β)∼N(μβ,σβ2) \\log(\\beta) \\sim N(\\mu_\\beta, \\sigma_\\beta^2) LogisticLogOrdinal initialised exactly way LogisticLogNormal object: entries mean cov parameters define hyper priors α1 αK-1 β order.","code":"ordinal_model <- LogisticLogNormalOrdinal(   mean = c(3, 4, 0),   cov = diag(c(4, 3, 1)),   ref_dose = 55 )"},{"path":"https://openpharma.github.io/crmPack/articles/ordinal-crm.html","id":"model-fitting","dir":"Articles","previous_headings":"Implementation","what":"Model fitting","title":"Ordinal CRM","text":"mcmc works expected ordinal models: warning message expected can ignored. suppressed future version crmPack. See issue 748. Samples object returned mcmc standard Samples object. names entries data slot can passed fit method, using grade parameter specify toxicity grade cumulative probabilities toxicity required: cumulative flag can used request grade-specific probabilities. Note , grade == K - 1, cumulative grade-specific probabilities toxicities identical. plot method also takes grade cumulative parameters.","code":"opts <- .DefaultMcmcOptions()  samples <- mcmc(ordinal_data, ordinal_model, opts) #> Warning in rjags::jags.model(file = model_file, data = model_data, inits = #> c(model_inits, : Unused variable \"y\" in data names(samples@data) #> [1] \"alpha1\" \"alpha2\" \"beta\" fit(samples, ordinal_model, ordinal_data, grade = 1L) #>    dose     middle        lower     upper #> 1    10 0.03880315 6.241319e-10 0.2556231 #> 2    20 0.07841403 3.568753e-06 0.3608493 #> 3    30 0.13645903 4.851025e-04 0.4493741 #> 4    40 0.22621736 1.330691e-02 0.5392550 #> 5    50 0.36358896 1.093423e-01 0.6806627 #> 6    60 0.52235691 1.916629e-01 0.8570273 #> 7    70 0.63371551 2.202763e-01 0.9629062 #> 8    80 0.70145965 2.391788e-01 0.9915638 #> 9    90 0.74558339 2.643557e-01 0.9977714 #> 10  100 0.77646309 2.775551e-01 0.9993920 fit(samples, ordinal_model, ordinal_data, grade = 2L) #>    dose     middle        lower     upper #> 1    10 0.02005602 2.099178e-10 0.1427515 #> 2    20 0.04112010 1.105223e-06 0.1991930 #> 3    30 0.07316890 1.922449e-04 0.2601096 #> 4    40 0.12539276 5.298874e-03 0.3414226 #> 5    50 0.21432905 4.954085e-02 0.4647270 #> 6    60 0.34934711 9.180424e-02 0.6775838 #> 7    70 0.47717673 1.098473e-01 0.9090324 #> 8    80 0.56477820 1.287615e-01 0.9794005 #> 9    90 0.62422252 1.408356e-01 0.9953369 #> 10  100 0.66669977 1.549968e-01 0.9985328 fit(samples, ordinal_model, ordinal_data, grade = 1L, cumulative = FALSE) #>    dose     middle        lower     upper #> 1    10 0.01874712 2.037312e-10 0.1432691 #> 2    20 0.03729393 8.067689e-07 0.2036041 #> 3    30 0.06329013 1.047966e-04 0.2832037 #> 4    40 0.10082460 1.092612e-03 0.3370543 #> 5    50 0.14925991 5.163570e-03 0.4407697 #> 6    60 0.17300979 6.363397e-03 0.4796038 #> 7    70 0.15653878 5.258420e-03 0.4681408 #> 8    80 0.13668145 2.434388e-03 0.4518151 #> 9    90 0.12136088 9.294406e-04 0.4319597 #> 10  100 0.10976332 2.819086e-04 0.4281909 fit(samples, ordinal_model, ordinal_data, grade = 2L, cumulative = FALSE) #>    dose     middle        lower     upper #> 1    10 0.02005602 2.099178e-10 0.1427515 #> 2    20 0.04112010 1.105223e-06 0.1991930 #> 3    30 0.07316890 1.922449e-04 0.2601096 #> 4    40 0.12539276 5.298874e-03 0.3414226 #> 5    50 0.21432905 4.954085e-02 0.4647270 #> 6    60 0.34934711 9.180424e-02 0.6775838 #> 7    70 0.47717673 1.098473e-01 0.9090324 #> 8    80 0.56477820 1.287615e-01 0.9794005 #> 9    90 0.62422252 1.408356e-01 0.9953369 #> 10  100 0.66669977 1.549968e-01 0.9985328 plot(samples, ordinal_model, ordinal_data, grade = 2L) plot(samples, ordinal_model, ordinal_data, grade = 1L) plot(samples, ordinal_model, ordinal_data, grade = 1L, cumulative = FALSE)"},{"path":"https://openpharma.github.io/crmPack/articles/ordinal-crm.html","id":"rules-classes-for-ordinal-models","dir":"Articles","previous_headings":"Implementation","what":"Rules classes for ordinal models","title":"Ordinal CRM","text":"class Rule (, CohortSize, Increments, NextBest Stopping), crmPack provides single wrapper class allows Rule applied trials using ordinal CRM models. wrapper class name <Rule>Ordinal takes two parameters, rule grade. rule defines standard crmPck Rule grade toxicity grade rule applied. example Rules based different toxicity grades can combined produce complex rules. define two Increments rules, one based toxicity grade 1, toxicity grade 2. Recall two sub toxic AEs one DLT reported example data set. Thus, rule based sub-toxic AEs allows maximum increment 0.67 three events reported, giving maximum permitted dose 100.2. one DLT reported, second rule allows increment 0.5, giving maximum permitted dose 90. two grade-specific rules can combined single rule using IncrementsMin:","code":"dlt_rule <- CohortSizeDLT(intervals = 0:2, cohort_size = c(1, 3, 5)) ordinal_rule_1 <- CohortSizeOrdinal(grade = 1L, rule = dlt_rule) ordinal_rule_2 <- CohortSizeOrdinal(grade = 2L, rule = dlt_rule)  size(ordinal_rule_1, 50, empty_ordinal_data) #> [1] 1 size(ordinal_rule_2, 50, empty_ordinal_data) #> [1] 1 size(ordinal_rule_1, 50, ordinal_data) #> [1] 5 size(ordinal_rule_2, 50, ordinal_data) #> [1] 3 ordinal_rule_1 <- IncrementsOrdinal(   grade = 1L,   rule = IncrementsRelativeDLT(intervals = 0:2, increments = c(3, 1.5, 0.67)) ) maxDose(ordinal_rule_1, ordinal_data) #> [1] 100.2 ordinal_rule_2 <- IncrementsOrdinal(   grade = 2L,   rule = IncrementsRelativeDLT(intervals = 0:1, increments = c(3, 0.5)) ) maxDose(ordinal_rule_2, ordinal_data) #> [1] 90 trial_rule <- IncrementsMin(list(ordinal_rule_1, ordinal_rule_2)) maxDose(trial_rule, ordinal_data) #> [1] 90"},{"path":"https://openpharma.github.io/crmPack/articles/ordinal-crm.html","id":"on-the-need-for-a-diagonal-covariance-matrix","dir":"Articles","previous_headings":"","what":"On the need for a diagonal covariance matrix","title":"Ordinal CRM","text":"Consider standard logistic log Normal CRM model: can estimate prior using empty Data object… obtain correlation model’s parameters [recalling prior defined terms log(alpha1)]… requested covariance -0.5 got -0.5416755.2. Pretty good! Now look ordinal CRM model non-zero correlation parameters. begin, take copy current LogisticLogNormalOrdinal model give non-diagonal covariance matrix accessing params@cov slot directly, deliberately avoiding object validation. NB poor practice recommended. done purely illustration. Fit revised model obtain prior. Finally, look covariance matrix, remembering use log(beta) rather beta… correlations nothing like requested. due constraints imposed intercepts model. situation likely worsen number toxicity categories increases. open issue - #755 -examine options allowing end users specify correlation structures ordinal CRM models. like contribute, please .","code":"model <- LogisticLogNormal(   mean = c(-3, 1),   cov = matrix(c(4, -0.5, -0.5, 3), ncol = 2),   ref_dose = 45 )  model@params@cov #>      [,1] [,2] #> [1,]  4.0 -0.5 #> [2,] -0.5  3.0 data <- Data(doseGrid = seq(10, 100, 10)) options <- McmcOptions(   samples = 30000,   rng_kind = \"Mersenne-Twister\",   rng_seed = 8191316 ) samples <- mcmc(data, model, options) d <- as.matrix(cbind(samples@data$alpha0, log(samples@data$alpha1))) sigmaHat <- cov(d) sigmaHat #>            [,1]       [,2] #> [1,]  4.0094331 -0.5416752 #> [2,] -0.5416752  3.0363958 ordinal_model_temp <- ordinal_model ordinal_model_temp@params@cov <- matrix(c(4, -0.5, -0.5, -0.5, 3, -0.5, -0.5, -0.5, 1), ncol = 3)  ordinal_model_temp@params@cov #>      [,1] [,2] [,3] #> [1,]  4.0 -0.5 -0.5 #> [2,] -0.5  3.0 -0.5 #> [3,] -0.5 -0.5  1.0 ordinal_data <- DataOrdinal(doseGrid = seq(10, 100, 10)) ordinal_samples <- mcmc(ordinal_data, ordinal_model_temp, options) #> Warning in rjags::jags.model(file = model_file, data = model_data, inits = #> c(model_inits, : Unused variable \"tox\" in data ordinalD <- as.matrix(   cbind(     ordinal_samples@data$alpha1,     ordinal_samples@data$alpha2,     log(ordinal_samples@data$beta)   ) ) sigmaHat <- cov(ordinalD) sigmaHat #>             [,1]        [,2]         [,3] #> [1,]  4.00158899 2.768345336 -0.001112980 #> [2,]  2.76834534 2.924696828  0.008697924 #> [3,] -0.00111298 0.008697924  1.012033823"},{"path":"https://openpharma.github.io/crmPack/articles/ordinal-crm.html","id":"some-observations","dir":"Articles","previous_headings":"","what":"Some observations","title":"Ordinal CRM","text":"currently considering need making grade-specific functionality available across crmPack methods. specific use case currently supported, please contact us. need ordinal CRM dual endpoint models, please let us know. crmPack supported ordinal CRM outset, classes support standard, binary, CRM models sub-classes general ordinal implementations. consider taking approach adding support ordinal CRM models existing code. decided purely defensive conservative reasons. introduced ordinal classes parents existing classes, changes code base much substantial concerned might miss implicit assumptions dimensionality existing models. therefore chose implement ordinal classes siblings, rather parents, existing classes. approach minimises risk breaking existing end-user code risk slightly greater complexity using new classes.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/ordinal-crm.html","id":"environment","dir":"Articles","previous_headings":"","what":"Environment","title":"Ordinal CRM","text":"","code":"#> R version 4.5.0 (2025-04-11) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.2 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               #>  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     #>  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    #>  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  #>  [9] LC_ADDRESS=C               LC_TELEPHONE=C             #> [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: Etc/UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] crmPack_2.0.0.9002 ggplot2_4.0.0      #>  #> loaded via a namespace (and not attached): #>  [1] sass_0.4.10          generics_0.1.4       futile.options_1.0.1 #>  [4] xml2_1.4.0           lattice_0.22-7       stringi_1.8.7        #>  [7] digest_0.6.37        magrittr_2.0.4       evaluate_1.0.5       #> [10] grid_4.5.0           RColorBrewer_1.1-3   mvtnorm_1.3-3        #> [13] fastmap_1.2.0        jsonlite_2.0.0       backports_1.5.0      #> [16] formatR_1.14         gridExtra_2.3        viridisLite_0.4.2    #> [19] scales_1.4.0         textshaping_1.0.3    jquerylib_0.1.4      #> [22] cli_3.6.5            rlang_1.1.6          futile.logger_1.4.3  #> [25] parallelly_1.45.1    withr_3.0.2          cachem_1.1.0         #> [28] yaml_2.3.10          parallel_4.5.0       tools_4.5.0          #> [31] coda_0.19-4.1        checkmate_2.3.3      dplyr_1.1.4          #> [34] lambda.r_1.2.4       kableExtra_1.4.0     vctrs_0.6.5          #> [37] R6_2.6.1             lifecycle_1.0.4      stringr_1.5.2        #> [40] GenSA_1.1.14.1       fs_1.6.6             htmlwidgets_1.6.4    #> [43] ragg_1.5.0           rjags_4-17           pkgconfig_2.0.3      #> [46] desc_1.4.3           pkgdown_2.1.3        pillar_1.11.1        #> [49] bslib_0.9.0          gtable_0.3.6         glue_1.8.0           #> [52] systemfonts_1.2.3    xfun_0.53            tibble_3.3.0         #> [55] tidyselect_1.2.1     rstudioapi_0.17.1    knitr_1.50           #> [58] dichromat_2.0-0.1    farver_2.1.2         htmltools_0.5.8.1    #> [61] labeling_0.4.3       rmarkdown_2.29       svglite_2.2.1        #> [64] compiler_4.5.0       S7_0.2.0"},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Parallel computing with extensions","text":"One big advantages crmPack existing R implementations flexible framework based S4 classes methods system (Chambers 2008). Users can extend existing functionality easily specific needs study (Sabanes Bove et al. 2019). User defined extensions classes methods can easily created used together existing crmPack classes methods setting study performing analysis observed data. long parallel computing used, special care needs taken utilizing native user defined classes methods. trial simulations need performed derive operational characteristics study setup, run times may become long single core processing. run time depends mainly number study replications MCMC samples. cases long run times, utilizing parallel computing, .e., using multiple CPU cores, can overcome challenge decrease run times significantly. Parallel computing supported crmPack design, .e., whenever simulation call invoked parameters parallel = TRUE nCores = one CPU, core initialized crmPack package global environment. Due nature S4 object system, user defined classes method defined global environment just made available core initializing core global environment. User defined classes method needs executed core initialized warrant full functionality S4 objects. following paragraphs provide example user defined extensions can used utilizing parallel computing within crmPack.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"high-level-usage","dir":"Articles","previous_headings":"","what":"High level usage","title":"Parallel computing with extensions","text":"use user written extension parallel computing crmPack, user written code needs embedded function. function stored value global option fixed name crmpack_extensions. existence global option evaluated parallel computing requested. case option crmpack_extensions exists, content submitted node cluster, user written S4 classes methods available along crmPack package. following code show high level, option utilized.","code":"options(   crmpack_extensions = function() {     # ..... user code .....   } )"},{"path":"https://openpharma.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"important-information-for-usage","dir":"Articles","previous_headings":"","what":"Important information for usage","title":"Parallel computing with extensions","text":"operation characteristics design needs derived utilizing parallel computing, simulation function must executed parameter parallel = TRUE nCores = number greater one. case, evaluated global option name crmpack_extensions exists. true, value global option crmpack_extensions executed core time initialization, .e., character string equal global option crmpack_extensions executed core cluster, code available use parallel computing. Please note wrapper function holds user extensions convenient way hand class method definitions user constructor function crmpack_extensions option. However, constructor function must available environment called. extensions directly coded within wrapper function, <<- operator must used new user defined constructor function defined within wrapper function. <<- operator force function become visible within global environment. Another possibility store user extensions file sourced within wrapper function. case user defined constructor function can assigned regular <- operator, source parse content file environment. avoid errors important understand packages attached current environment available workers environment. .e., even though code may work without problems used single core processing, may fail parallel execution functions attached workers environment. Therefore necessary make sure called functions available workers environment. can achieved including library statement within wrapper function using double colon operator ::. described usage options detailed example.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"information-for-debugging","dir":"Articles","previous_headings":"","what":"Information for debugging","title":"Parallel computing with extensions","text":"expected good practice, new written extension first tested validated one CPU core, utilizing global option crmpack_extensions. important understand character string value global option crmpack_extensions executed directly core checked validity correctness. case code run errors, returned error message using parallel computing may misleading may help identify root cause problem. Debugging newly written code much easier without using parallel computing.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"worked-out-example","dir":"Articles","previous_headings":"","what":"Worked out example","title":"Parallel computing with extensions","text":"Let us assume want utilize two-parameter logistic regression model, slope parameter positive values, normal prior truncated slope parameter, slope can positive values. case want set prior distribution slope parameter truncated normal distribution bounded zero lower end. model representation part crmPack package can easily added shown . Please note example extra code directly inserted option crmpack_extensions function. mentioned , user write test code first without embedding function set equal option crmpack_extensions, assure errors occur whole execution results expected. new code defined embedded function, can store function value global option, name crmpack_extensions. Please note <<-operator used assign LogisticNormalTruncPrior function global environment. assertion functions package checkmate referenced double colon operator example. case package checkmate attached within function, .e., statement library(checkmate) used code , direct reference checkmate:: can removed. Either way works parallel computing makes sure functions can used current environment workers parallel study simulations performed. Now able use newly created model LogisticNormalTruncPrior set study. First, get value global option crmpack_extensions, function defined . execute function within global environment, constructor function corresponding classes methods prob dose become available. Next can set study new model desired design features. setting model design features, useful check model decisions case DLT observed certain dose level study simulations performed. check can also serve additional test new written code. examine runs expected, study simulations can performed. demonstrate difference single core processing multiple core processing, two scenarios processed single core processing, followed 5 scenarios utilizing parallel computing. regard run times example, please see note end vignette. simulations single core processing running successful, full operation characteristics utilizing parallel computing can derived.","code":"library(crmPack)  my_own_extension <- function() {   # Attach the package checkmate with library(checkmate) here, to avoid usage of   # the :: operator in the code below.    # LogisticNormalTruncPrior ----    ## class ----    #' `LogisticNormalTruncPrior`   #'   #' @description `r lifecycle::badge(\"experimental\")`   #'   #' [`LogisticNormalTruncPrior`] is the class for the usual logistic regression   #'  model with bivariate normal prior on the intercept and slope.   #'   #' @aliases LogisticNormalTruncPrior   #' @export   #'   #' @slot mean1 the mean of the intercept   #' @slot mean2 the mean of the slope   #' @slot var1 the variance of the intercept   #' @slot var2 the variance of the slope   #'   .LogisticNormalTruncPrior <- setClass(     Class = \"LogisticNormalTruncPrior\",     contains = \"GeneralModel\",     slots = c(       mean1 = \"numeric\",       mean2 = \"numeric\",       var1 = \"numeric\",       var2 = \"numeric\"     )   )    ## constructor ----    #' @rdname LogisticNormalTruncPrior-class    #' Initialization function for the `LogisticNormalTruncPrior` class   #'   #' @param mean1 the mean of the intercept   #' @param mean2 the mean of the slope   #' @param var1 the variance of the intercept   #' @param var2 the variance of the slope   #' @return the \\code{\\linkS4class{LogisticNormalTruncPrior}} object   #'   #' @export   #' @keywords methods   LogisticNormalTruncPrior <<- function(mean1, mean2, var1, var2) {     .LogisticNormalTruncPrior(       mean1 = mean1,       mean2 = mean2,       var1 = var1,       var2 = var2,       datamodel = function() {         for (i in 1:nObs) {           y[i] ~ dbern(mean[i])           logit(mean[i]) <- alpha0 + alpha1 * x[i]         }       },       priormodel = function() {         alpha0 ~ dnorm(mean1, 1 / var1)         alpha1 ~ dnorm(mean2, 1 / var2) %_% I(0, )       },       datanames = c(\"nObs\", \"y\", \"x\"),       modelspecs = function() {         list(           mean1 = mean1,           mean2 = mean2,           var1 = var1,           var2 = var2         )       },       init = function() {         list(alpha0 = mean1, alpha1 = mean2)       },       sample = c(\"alpha0\", \"alpha1\")     )   }    ## dose ----    #' @describeIn dose compute the dose level reaching a specific toxicity   #'   probability.   #'   #' @aliases dose-LogisticNormalTruncPrior   #' @export   #'   setMethod(     f = \"dose\",     signature = signature(       x = \"numeric\",       model = \"LogisticNormalTruncPrior\",       samples = \"Samples\"     ),     definition = function(x, model, samples) {       checkmate::assert_probabilities(x)       checkmate::assert_subset(c(\"alpha0\", \"alpha1\"), names(samples))       assert_length(x, len = size(samples))        alpha0 <- samples@data$alpha0       alpha1 <- samples@data$alpha1       (logit(x) - alpha0) / alpha1     }   )    ## prob ----    #' @describeIn prob compute the toxicity probability of a specific dose.   #'   #' @aliases prob-LogisticNormalTruncPrior   #' @export   #'   setMethod(     f = \"prob\",     signature = signature(       dose = \"numeric\",       model = \"LogisticNormalTruncPrior\",       samples = \"Samples\"     ),     definition = function(dose, model, samples) {       checkmate::assert_numeric(         dose,         lower = 0L, any.missing = FALSE, min.len = 1       )       checkmate::assert_subset(c(\"alpha0\", \"alpha1\"), names(samples))       assert_length(dose, len = size(samples))        alpha0 <- samples@data$alpha0       alpha1 <- samples@data$alpha1       1 / (1 + exp(-alpha0 - alpha1 * dose))     }   ) } # Store the function into the global option crmpack_extensions. options(crmpack_extensions = my_own_extension) # Execute the user written extensions. getOption(\"crmpack_extensions\")() # Create the dose grid. emptydata <- Data(   doseGrid = c(     10, 15, 20, 30, 40, 60, 80, 120, 160, 240, 320,     480, 640, 960, 1280, 1920, 2400, 3000, 4000   ),   placebo = FALSE )  # Create data for basic testing of the setup. my_data <- Data(   x = c(10, 20, 40, 80, 80, 160, 160),   y = c(0, 0, 0, 0, 0, 1, 1),   cohort = c(1, 2, 3, 4, 4, 5, 5),   ID = 1:7,   doseGrid = emptydata@doseGrid )  # Setup the model. my_model <- LogisticNormalTruncPrior(   mean1 = -3,   mean2 = 0.00075,   var1 = 1,   var2 = 0.000009 )  # Options used for simulations. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 100,   rng_kind = \"Mersenne-Twister\",   rng_seed = 94 )  # Create mcmc samples. my_samples <- mcmc(my_data, my_model, my_options)  # Plot the dose toxicity curve. plot(my_samples, my_model, my_data)  # Specify increments. my_increments <- IncrementsRelativeDLT(   intervals = c(0, 1),   increments = c(1, 0.5) )  # Maximum dose. this_max_dose <- maxDose(my_increments, my_data)  # Next best dose. my_next_best <- NextBestMinDist(target = 0.3) this_next_dose <- nextBest(   my_next_best, this_max_dose, my_samples, my_model, my_data )$value  # Stopping rule. my_stopping <- StoppingPatientsNearDose(nPatients = 9, percentage = 0)  # Stop trial based on criteria and observed data. stopTrial(my_stopping, this_next_dose, my_samples, my_model, my_data)  # Cohorts size. my_size <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  # Design. my_design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 10 ) # Examine the design. examine(my_design, my_options) # Set up scenarios scenario_setup <- function(intercept, mtd_prob, mtd_dose) {   probFunction(     my_model,     alpha0 = logit(intercept),     alpha1 = (logit(mtd_prob) - logit(intercept)) / mtd_dose   ) }  safe_scenario <- scenario_setup(0.05, 0.3, 20000) late_scenario <- scenario_setup(0.05, 0.3, 2000) early_scenario <- scenario_setup(0.05, 0.3, 700) toxic_scenario <- scenario_setup(0.6, 0.3, -300) peak_scenario <- function(     dose,     scenario = cbind(emptydata@doseGrid, c(rep(0.05, 11), rep(0.80, 8)))) {   scenario[match(dose, scenario[, 1]), 2] }  # Helper function that outputs the elapsed time. report_time <- function(report_text) {   cat(     format(Sys.time(), usetz = TRUE),     report_text,     \"done - elapsed time from start:\",     round(difftime(Sys.time(), start_time, units = \"mins\"), digits = 1),     \"\\n\"   ) }  # Helper function that simulates a specific truth. get_oc <- function(truth) {   simulate(     my_design,     args = NULL,     truth = truth,     nsim = my_nsim,     mcmcOptions = my_options,     parallel = do_parallel,     nCores = parallelly::availableCores()   ) }  # get operation characteristics without utilizing parallel computing for # selected truth (to reduce the run time). time_no_parallel <- system.time({   start_time <- Sys.time()   cat(format(Sys.time(), usetz = TRUE), \"start\", \"\\n\")    my_nsim <- 10   do_parallel <- FALSE    safe <- get_oc(safe_scenario)    report_time(\"safe (single core processing)\")    late <- get_oc(late_scenario)    report_time(\"late (single core processing)\") }) # Get full operation characteristics utilizing parallel computing. time <- system.time({   start_time <- Sys.time()   cat(format(Sys.time(), usetz = TRUE), \"start\", \"\\n\")    my_nsim <- 10   do_parallel <- TRUE    safe <- get_oc(safe_scenario)    report_time(\"safe\")    late <- get_oc(late_scenario)    report_time(\"late\")    early <- get_oc(early_scenario)    report_time(\"early\")    toxic <- get_oc(toxic_scenario)    report_time(\"toxic\")    peak <- get_oc(peak_scenario)    report_time(\"peak\") })"},{"path":"https://openpharma.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"alternative-read-user-code-from-external-file","dir":"Articles","previous_headings":"","what":"Alternative: read user code from external file","title":"Parallel computing with extensions","text":"alternative may convenient store user extensions external file source file wrapper function. advantage, <<- operator necessary user constructor functions can replaced usual assignment <-.","code":"if (FALSE) {   # Store code example form above in external file and   # remove the wrapper function structure.   dump(\"my_own_extension\", file = \"user_extension.R\")   file_con <- file(\"user_extension.R\")   tmp <- readLines(file_con)[-c(1:3, 135)]   tmp <- gsub(\"<<-\", \"<-\", tmp)   writeLines(tmp, file_con)    # Source the stored file in the wrapper function.   my_own_extension2 <- function() {     source(\"user_extension.R\")   }    options(crmpack_extensions = my_own_extension2)   getOption(\"crmpack_extensions\")()    # Run the rest of the code from above example }"},{"path":"https://openpharma.github.io/crmPack/articles/parallel_computing_with_extensions.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"Parallel computing with extensions","text":"analyses presented vignette used chains short length well limited number trial simulations. purely convenience. Study simulations real trials use considerably longer chains much higher number trial simulations. example apparent small number study simulations, overhead initializing cluster parallel computing, leads longer run time simulations comparison single core processing. However, relevant number study simulations, substantial run time benefit utilizing parallel computation can easily seen.","code":""},{"path":[]},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"setting-up-the-data","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Setting up the data","title":"Rolling CRM Example","text":"","code":"library(crmPack) ## Loading required package: ggplot2 ## Registered S3 method overwritten by 'crmPack': ##   method       from   ##   print.gtable gtable ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example data <- DataDA(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   ID = as.integer(1:8),   cohort = as.integer(c(1, 2, 3, 4, 5, 6, 6, 6)),   doseGrid =     c(       0.1, 0.5, 1.5, 3, 6,       seq(from = 10, to = 80, by = 2)     ),   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = rep(0, 8),   Tmax = 60 )  emptydata <- DataDA(   doseGrid = c(     0.1, 0.5, 1, 1.5, 3, 6,     seq(from = 10, to = 80, by = 2)   ),   Tmax = 60 )"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"structure-of-the-model-class","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Structure of the model class","title":"Rolling CRM Example","text":"","code":"npiece_ <- 10 Tmax_ <- 60  lambda_prior <- function(k) {   npiece_ / (Tmax_ * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(as.matrix(c(1:npiece_), 1, npiece_), 2, lambda_prior))),   c_par = 2 )"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"obtain-the-posterior","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Obtain the posterior","title":"Rolling CRM Example","text":"","code":"options <- McmcOptions(   burnin = 10,   step = 2,   samples = 1e2 )  set.seed(94) samples <- mcmc(data, model, options)"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"use-ggmcmc-to-diagnose","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Use ggmcmc to diagnose","title":"Rolling CRM Example","text":"","code":"library(ggmcmc) ## Loading required package: dplyr ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union ## Loading required package: tidyr alpha0samples <- get(samples, \"alpha0\")  print(ggs_traceplot(alpha0samples)) print(ggs_autocorrelation(alpha0samples))"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"plot-the-model-fit","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Plot the model fit","title":"Rolling CRM Example","text":"","code":"plot(samples, model, data, hazard = TRUE) plot(samples, model, data, hazard = FALSE)"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"prior-mean-curve","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"prior mean curve","title":"Rolling CRM Example","text":"","code":"emptydata <- DataDA(doseGrid = c(   0.1, 0.5, 1.5, 3, 6,   seq(from = 10, to = 80, by = 2) ), Tmax = 60)  Priorsamples <- mcmc(emptydata, model, options)  plot(Priorsamples, model, emptydata, hazard = FALSE)"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"escalation-rules","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Escalation rules","title":"Rolling CRM Example","text":"Need fill (use rule section 8 “using package crmPack: introductory examples”)","code":"myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  nextMaxDose <- maxDose(myIncrements, data = data)  myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3)) mySize2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3)) mySize <- maxSize(mySize1, mySize2)  myStopping1 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) myStopping2 <- StoppingMinPatients(nPatients = 50) myStopping <- (myStopping1 | myStopping2)"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"recommended-dose-for-the-next-cohort","dir":"Articles","previous_headings":"Example 1: Recommend a dose for the next cohort","what":"Recommended dose for the next cohort","title":"Rolling CRM Example","text":"","code":"doseRecommendation <- nextBest(myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  doseRecommendation$plot doseRecommendation$value ## [1] 0.5"},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"set-up-safety-window-and-dadesign-to-be-completed","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Set up safety window and DADesign to be completed","title":"Rolling CRM Example","text":"","code":"mysafetywindow <- SafetyWindowConst(c(6, 2), 7, 7)  design <- DADesign(   model = model,   increments = myIncrements,   nextBest = myNextBest,   stopping = myStopping,   cohort_size = mySize,   data = emptydata,   safetyWindow = mysafetywindow,   startingDose = 3 )"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"set-up-true-curves","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Set up true curves","title":"Rolling CRM Example","text":"","code":"myTruth <- probFunction(model, alpha0 = 2, alpha1 = 3) curve(myTruth(x), from = 0, to = 100, ylim = c(0, 1)) onset <- 15 exp_cond.cdf <- function(x) {   1 - (pexp(x, 1 / onset, lower.tail = FALSE) - pexp(28, 1 / onset, lower.tail = FALSE)) / pexp(28, 1 / onset) }"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"perform-the-simulations","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Perform the simulations","title":"Rolling CRM Example","text":"","code":"mySims <- simulate(design,   args = NULL,   truthTox = myTruth,   truthSurv = exp_cond.cdf, # piece_exp_cond.cdf,   trueTmax = 80,   nsim = 2,   seed = 819,   mcmcOptions = options,   firstSeparate = TRUE,   deescalate = FALSE,   parallel = FALSE )"},{"path":"https://openpharma.github.io/crmPack/articles/rolling-crm.html","id":"interpret-the-simulation-results","dir":"Articles","previous_headings":"Example 2: Run a simulation to evaluate operating characteristics","what":"Interpret the simulation results","title":"Rolling CRM Example","text":"Use similar way section 9.2 “using package crmPack: introductory examples” document","code":"a <- summary(mySims, truth = myTruth) b <- mySims@data[[1]]  plot(mySims) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## ℹ The deprecated feature was likely used in the crmPack package. ##   Please report the issue at <https://github.com/openpharma/crmPack/issues>. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. plot(b) mySims@stop_reasons[[2]] ## [[1]] ## [1] \"Probability for target toxicity is 61 % for dose 38 and thus above the required 50 %\" ##  ## [[2]] ## [1] \"Number of patients is 20 and thus below the prespecified minimum number 50\" # nolint end"},{"path":"https://openpharma.github.io/crmPack/articles/simulations.html","id":"simulation-setting","dir":"Articles","previous_headings":"","what":"Simulation setting","title":"Simulation study example","text":"simulation study setting defined.","code":"id <- 1 onset <- 3 a0 <- 2 a1 <- 3 refDose <- 56  # True dose-DLT relationship myTruth <- function(dose) {   StandLogDose <- log(dose / refDose)   plogis(a0 + a1 * StandLogDose) }  # The conditional CDF of the PEM if (onset == 30) {   onset <- 15   exp_cond.cdf <- function(x) {     (pexp(42 - x, 1 / onset, lower.tail = FALSE) - pexp(Tmax_, 1 / onset, lower.tail = FALSE)) / pexp(Tmax_, 1 / onset)   } } else {   exp_cond.cdf <- function(x) {     1 - (pexp(x, 1 / onset, lower.tail = FALSE) - pexp(Tmax_, 1 / onset, lower.tail = FALSE)) / pexp(Tmax_, 1 / onset)   } }"},{"path":"https://openpharma.github.io/crmPack/articles/simulations.html","id":"design-definition","dir":"Articles","previous_headings":"","what":"Design definition","title":"Simulation study example","text":"dose escalation designs defined: example TITE-CRM used. Similarly code can adapted rolling-CRM.","code":"library(crmPack) ## Loading required package: ggplot2 ## Registered S3 method overwritten by 'crmPack': ##   method       from   ##   print.gtable gtable ## Type crmPackHelp() to open help browser ## Type crmPackExample() to open example Tmax_ <- 42  model <- TITELogisticLogNormal(   mean = c(1.33, 1.49),   cov = matrix(c(1.826, 0.0209, 0.0209, 0.0245), nrow = 2),   ref_dose = refDose )  myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(10, 3) )  myNextBest <- NextBestMTD(   target = 0.3,   derive =     function(mtd_samples) {       mean(mtd_samples)     } )  myStopping <- StoppingMinPatients(nPatients = 48)  mySize <- CohortSizeConst(size = 3)  emptydata <- DataDA(doseGrid = seq(from = 2, to = 50, by = 2), Tmax = Tmax_)  mysafetywindow <- SafetyWindowConst(c(7, 7), 7, 7)  design <- DADesign(   model = model,   increments = myIncrements,   nextBest = myNextBest,   stopping = myStopping,   cohort_size = mySize,   data = emptydata,   safetyWindow = mysafetywindow,   startingDose = 8 )"},{"path":"https://openpharma.github.io/crmPack/articles/simulations.html","id":"simulation-run","dir":"Articles","previous_headings":"","what":"Simulation run","title":"Simulation study example","text":"order obtain stable results, increase simulation parameters appropriately (step, samples, nsim).","code":"options <- McmcOptions(   burnin = 20,   step = 1,   samples = 50 ) mySims <- simulate(design,   args = NULL,   truthTox = myTruth,   truthSurv = exp_cond.cdf,   trueTmax = 42,   nsim = 10,   seed = 819,   mcmcOptions = options,   parallel = FALSE )  # nolint end"},{"path":"https://openpharma.github.io/crmPack/articles/tidy_method.html","id":"introducing-tidy-methods-to-crmpack","dir":"Articles","previous_headings":"","what":"Introducing tidy methods to crmPack","title":"Using tidy","text":"latest release crmPack introduces broom-like tidy methods crmPack classes. methods convert underlying S4 classes (lists ) tibbles. facilitate reporting aspects CRM trials well making easier integrate crmPack packages ggplot2.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/tidy_method.html","id":"basic-approach","dir":"Articles","previous_headings":"Introducing tidy methods to crmPack","what":"Basic approach","title":"Using tidy","text":"following general approach take tidying crmPack classes: slots functions converted tibbles list tibbles. slot’s value list, rules applied element list turn. slot’s value scalar, slot converted 1x1 tibble. ease downstream operations row_binding. object tidied contains multiple slots (potentially) different lengths, result list tibbles. list may nested multiple levels. (See, example, LogisticLogNormal.) Exception: slot name plural contains vector list, column name singular. See, example, CohortSizeParts . value slot set, zero-row tibble returned. value slot scalar attributes, attributes added columns tibble, whose name name attribute whose value value attribute every row tibble. Vector attributes can added, default, nested tibble. nested tibble 1 row x n column, column names defined name attribute values given value corresponding attribute. tbl_<className> prepended class (list ) tidy tibble(s).","code":""},{"path":"https://openpharma.github.io/crmPack/articles/tidy_method.html","id":"exceptions","dir":"Articles","previous_headings":"Introducing tidy methods to crmPack","what":"Exceptions","title":"Using tidy","text":"vector slot (series vector slots) define range ()example, intervals slot various CohortSize Increments classes, naming convention described followed. Instead, columns named min max define extent range.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/tidy_method.html","id":"examples","dir":"Articles","previous_headings":"Introducing tidy methods to crmPack","what":"Examples","title":"Using tidy","text":"CohortSizeConst trivial example illustrates default approach classes. IncrementsRelative illustrate ranges handled. CohortSizeMax contains slot whose value list. Samples class likely useful making presentations yet supported crmPack directly.","code":"CohortSizeConst(size = 3) %>% tidy() #> # A tibble: 1 × 1 #>    size #>   <int> #> 1     3 IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) %>%   tidy() #> # A tibble: 2 × 3 #>     min   max increment #>   <dbl> <dbl>     <dbl> #> 1     0    20      1    #> 2    20   Inf      0.33 cs_max <- maxSize(   CohortSizeConst(3),   CohortSizeDLT(intervals = 0:1, cohort_size = c(1, 3)) ) cs_max %>% tidy() #> [[1]] #> # A tibble: 1 × 1 #>    size #>   <int> #> 1     3 #>  #> [[2]] #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0     1           1 #> 2     1   Inf           3 #>  #> attr(,\"class\") #> [1] \"tbl_CohortSizeMax\" \"tbl_CohortSizeMax\" \"list\" options <- McmcOptions(   burnin = 100,   step = 1,   samples = 2000 )  emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov =     matrix(c(1, -0.5, -0.5, 1),       nrow = 2     ),   ref_dose = 56 ) samples <- mcmc(emptydata, model, options) tidySamples <- samples %>% tidy() tidySamples %>% head() #> $data #> # A tibble: 2,000 × 10 #>    Iteration Chain alpha0 alpha1 nChains nParameters nIterations nBurnin nThin #>        <int> <int>  <dbl>  <dbl>   <int>       <int>       <int>   <int> <int> #>  1         1     1 -1.68   0.566       1           1        2100     100     1 #>  2         2     1 -0.744  1.27        1           1        2100     100     1 #>  3         3     1 -0.684  1.37        1           1        2100     100     1 #>  4         4     1 -1.74   2.06        1           1        2100     100     1 #>  5         5     1 -0.583  1.50        1           1        2100     100     1 #>  6         6     1 -0.928  0.791       1           1        2100     100     1 #>  7         7     1 -1.03   2.48        1           1        2100     100     1 #>  8         8     1 -2.24   4.46        1           1        2100     100     1 #>  9         9     1 -0.327  0.762       1           1        2100     100     1 #> 10        10     1 -1.70   1.76        1           1        2100     100     1 #> # ℹ 1,990 more rows #> # ℹ 1 more variable: parallel <lgl> #>  #> $options #> # A tibble: 1 × 5 #>   iterations burnin  step rng_kind rng_seed #>        <int>  <int> <int> <chr>       <int> #> 1       2100    100     1 NA             NA"},{"path":"https://openpharma.github.io/crmPack/articles/tidy_method.html","id":"using-tidy-crmpack-data","dir":"Articles","previous_headings":"Introducing tidy methods to crmPack","what":"Using tidy crmPack data","title":"Using tidy","text":"Tidy crmPack data can easily reported using knitr similar packages obvious way.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/tidy_method.html","id":"cohort-size","dir":"Articles","previous_headings":"Introducing tidy methods to crmPack > Using tidy crmPack data","what":"Cohort size","title":"Using tidy","text":"cohort size trial determined dose used current cohort according rules described table : Rules selecting cohort size presentations directly supported crmPack can easily produced. , create plots dose-specific PDFs prior probabilities toxicity first DLT observed fictional trial.","code":"CohortSizeRange(   intervals = c(0, 50, 300),   cohort_size = c(1, 3, 5) ) %>%   tidy() %>%   kable(     col.names = c(\"Min\", \"Max\", \"Cohort size\"),     caption = \"Rules for selecting the cohort size\"   ) %>%   add_header_above(c(\"Dose\" = 2, \" \" = 1)) options <- McmcOptions(   burnin = 5000,   step = 1,   samples = 40000 )  data <- Data(   doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100),   x = c(1, 3, 5, 10, 15, 15, 15),   y = c(0, 0, 0, 0, 0, 1, 0),   ID = 1L:7L,   cohort = as.integer(c(1:4, 5, 5, 5)) )  model <- LogisticLogNormal(   mean = c(-1, 0),   cov =     matrix(c(3, -0.1, -0.1, 4),       nrow = 2     ),   ref_dose = 56 ) samples <- mcmc(data, model, options) tidySamples <- samples %>% tidy()  # The magrittr pipe is necessary here tidySamples$data %>%   expand(     nesting(!!!.[1:10]),     Dose = data@doseGrid[2:11]   ) %>%   mutate(Prob = probFunction(model, alpha0 = alpha0, alpha1 = alpha1)(Dose)) %>%   ggplot() +   geom_density(aes(x = Prob, colour = as.factor(Dose)), adjust = 1.5) +   labs(     title = \"Posterior dose-specific PDFs for p(Tox)\",     caption = \"Dose 1 omitted as p(Tox) is essentially 0\",     x = \"p(Tox)\"   ) +   scale_colour_discrete(\"Dose\") +   theme_light() +   theme(     axis.ticks.y = element_blank(),     axis.text.y = element_blank(),     axis.title.y = element_blank()   )"},{"path":"https://openpharma.github.io/crmPack/articles/tidy_method.html","id":"environment","dir":"Articles","previous_headings":"","what":"Environment","title":"Using tidy","text":"","code":"sessionInfo() #> R version 4.5.0 (2025-04-11) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.2 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               #>  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     #>  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    #>  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  #>  [9] LC_ADDRESS=C               LC_TELEPHONE=C             #> [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: Etc/UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] dplyr_1.1.4        magrittr_2.0.4     tidyr_1.3.1        kableExtra_1.4.0   #> [5] knitr_1.50         crmPack_2.0.0.9002 ggplot2_4.0.0      #>  #> loaded via a namespace (and not attached): #>  [1] utf8_1.2.6           sass_0.4.10          generics_0.1.4       #>  [4] futile.options_1.0.1 xml2_1.4.0           lattice_0.22-7       #>  [7] stringi_1.8.7        digest_0.6.37        evaluate_1.0.5       #> [10] grid_4.5.0           RColorBrewer_1.1-3   mvtnorm_1.3-3        #> [13] fastmap_1.2.0        jsonlite_2.0.0       backports_1.5.0      #> [16] formatR_1.14         gridExtra_2.3        purrr_1.1.0          #> [19] viridisLite_0.4.2    scales_1.4.0         textshaping_1.0.3    #> [22] jquerylib_0.1.4      cli_3.6.5            rlang_1.1.6          #> [25] futile.logger_1.4.3  parallelly_1.45.1    withr_3.0.2          #> [28] cachem_1.1.0         yaml_2.3.10          parallel_4.5.0       #> [31] tools_4.5.0          coda_0.19-4.1        checkmate_2.3.3      #> [34] lambda.r_1.2.4       vctrs_0.6.5          R6_2.6.1             #> [37] lifecycle_1.0.4      stringr_1.5.2        GenSA_1.1.14.1       #> [40] fs_1.6.6             htmlwidgets_1.6.4    ragg_1.5.0           #> [43] rjags_4-17           pkgconfig_2.0.3      desc_1.4.3           #> [46] pkgdown_2.1.3        pillar_1.11.1        bslib_0.9.0          #> [49] gtable_0.3.6         glue_1.8.0           systemfonts_1.2.3    #> [52] xfun_0.53            tibble_3.3.0         tidyselect_1.2.1     #> [55] rstudioapi_0.17.1    dichromat_2.0-0.1    farver_2.1.2         #> [58] htmltools_0.5.8.1    labeling_0.4.3       rmarkdown_2.29       #> [61] svglite_2.2.1        compiler_4.5.0       S7_0.2.0"},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Trial Analysis","text":"vignette picks previous one (Trial Definition), ends. recap, trial defines six fundamental elements CRM trial ","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-dose-grid","dir":"Articles","previous_headings":"Introduction","what":"The dose grid","title":"Trial Analysis","text":"trial use dose grid consisting following doses: 1, 3, 9, 20, 30, 45, 60, 80 100. units doses defined irrelevant operation CRM.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-dose-toxicity-model","dir":"Articles","previous_headings":"Introduction","what":"The dose-toxicity model","title":"Trial Analysis","text":"trial uses logistic log Normal dose toxicity model log(pi1−pi)=α+βlog(di/d*) log(\\frac{p_i}{1 - p_i}) = \\alpha + \\beta log(d_i / d^*) prior joint distribution α\\alpha β\\beta [αlog(β)]∼N([−0.850],[1−0.5−0.51]).  \\begin{bmatrix} \\alpha \\\\ log(\\beta) \\end{bmatrix}   \\sim N\\begin{pmatrix} \\begin{bmatrix} -0.85\\\\0 \\end{bmatrix}   , \\begin{bmatrix} 1 & -0.5 \\\\ -0.5 & 1 \\end{bmatrix}    \\end{pmatrix}.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-increment-rule","dir":"Articles","previous_headings":"Introduction","what":"The increment rule","title":"Trial Analysis","text":"maximum increment doses greater 0 less 20 100 x (1 + 1)%, 200% highest dose used far, whereas 20 , maximum increment 100 x (1 + 0.5)%, 150% highest dose used far. Note 2-fold increment corresponds 3-fold escalation.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-dose-selection-rule","dir":"Articles","previous_headings":"Introduction","what":"The dose selection rule","title":"Trial Analysis","text":", choose use Neuenschwander’s rule (Neuenschwander, Branson, Gsponer 2008), dose next cohort dose (amongst doses eligible selection according escalation rule) highest posterior chance probability toxicity target range - [0.2, 0.35) - provided dose’s chance probability overdose range - [0.35, 1.0] - less 0.25.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-cohort-size","dir":"Articles","previous_headings":"Introduction","what":"The cohort size","title":"Trial Analysis","text":"Whilst dose next cohort 20 less DLTs observed, minimum cohort size 1. Otherwise, 3.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-stopping-rule","dir":"Articles","previous_headings":"Introduction","what":"The stopping rule","title":"Trial Analysis","text":"trial stop either Twenty patients recruited, . least three cohorts must treated probability current estimate MTD target toxicity range must least 0.5.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"trial-definition","dir":"Articles","previous_headings":"Introduction","what":"Trial definition","title":"Trial Analysis","text":"code define elements trial design given Trial Definition vignette.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"analysing-a-trial","dir":"Articles","previous_headings":"","what":"Analysing a trial","title":"Trial Analysis","text":"Given trial design constructed , process analysing real life instance trial simply matter providing model actual toxicity status participants treated far. escalation rules defined earlier allow use single patient run-either first DLT observed dose 20 administered.","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-single-patient-run-in","dir":"Articles","previous_headings":"Analysing a trial","what":"The single patient run-in","title":"Trial Analysis","text":"Assume first three patients - dosed 1, 3 5 - completed trial without incident, fourth patient - treated 10 - experienced DLT. provide information crmPack via Data object: Within Data object, doses patient treated given x slot toxicity status (Boolean toxicity represented truthy value) y slot. observed data easily visualised  , since plot method returns ggplot object, easily customised.  Now, update model obtain posterior estimate dose-toxicity curve: posterior estimate dose toxicity curve easily visualised:  visual representation model’s state obtained :  lower panel plot shows posterior probability dose overdose range. dashed horizontal black line shows acceptable risk overdose: Doses red lines go line considered toxic. upper panel shows probability dose target toxicity range. Clearly, doses 30 45 highest probability target toxicity range. However, risk overdose range unacceptable. Therefore, 20 dose recommended next cohort. can produce tabulation model state presentations, can see : highest dose far administered 20, escalation rule permits doses including 40 considered dose next cohort. However… Doses 30 considered unsafe remaining doses, 20 highest posterior probability target toxicity range DLT reported Items 1 4 list tell us size next cohort three. Items 2 3 together imply highest dose can used next cohort 20. Thus, model’s recommendation next cohort consist three patients, treated 20. can confirmed programmatically: However, given probability 20 overdose range just less threshold 0.25 (participant far treated 20 experienced DLT) perfectly reasonable clinical decision treat next cohort 10 - , indeed, dose 20. absolutely obligation follow CRM dose recommendation without consideration factors might affect choice appropriate dose next cohort. However, purpose exposition, treat next cohort 20, recommended model. can confirm trial’s stopping rules satisfied:","code":"firstFour <- Data(   x = c(1, 3, 9, 20),   y = c(0, 0, 0, 1),   ID = 1:4,   cohort = 1:4,   doseGrid = doseGrid ) plot(firstFour) plot(firstFour) + theme_light() vignetteMcmcOptions <- McmcOptions(burnin = 100, step = 2, samples = 1000) postSamples <- mcmc(   data = firstFour,   model = model,   options = vignetteMcmcOptions ) plot(postSamples, model, firstFour) nextBest(   my_next_best,   doselimit = 100,   samples = postSamples,   model = model,   data = empty_data )$plot tabulatePosterior <- function(mcmcSamples, observedData) {   as_tibble(     nextBest(       my_next_best,       doselimit = 100,       samples = mcmcSamples,       model = model,       data = observedData     )$probs   ) %>%     left_join(       tibble(         dose = observedData@x,         WithDLT = observedData@y       ) %>%         group_by(dose) %>%         summarise(           Treated = n(),           WithDLT = sum(WithDLT),           .groups = \"drop\"         ),       by = \"dose\"     ) %>%     replace_na(list(Treated = 0, WithDLT = 0)) %>%     select(dose, Treated, WithDLT, target, overdose) %>%     kableExtra::kable(       col.names = c(\"Dose\", \"Treated\", \"With DLT\", \"Target range\", \"Overdose range\"),       digits = c(0, 0, 0, 3, 3)     ) %>%     kableExtra::add_header_above(c(\" \" = 1, \"Participants\" = 2, \"Probability that dose is in \" = 2)) }  tabulatePosterior(postSamples, firstFour) nextMaxDose <- maxDose(my_increments, firstFour) nextMaxDose #> [1] 40  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples,   model = model,   data = firstFour ) doseRecommendation$value #> [1] 9 stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples,   model,   firstFour ) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 4 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 19 % for dose 9 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 4 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 4 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 19 % for dose 9 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 4 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] \"≥ 3 cohorts dosed\" #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 19 % for dose 9 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\" #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 4 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] \"≥ 20 patients dosed\" #>  #> attr(,\"report_label\") #> [1] NA"},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-first-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The first full cohort","title":"Trial Analysis","text":"Assume none three patients first full cohort report DLT: Update model: Tabulate posterior: trial stop? , dose used next cohort? trial continue, treating three patients next cohort 30.","code":"firstFullCohort <- Data(   x = c(1, 3, 9, 20, 20, 20, 20),   y = c(0, 0, 0, 1, 0, 0, 0),   ID = 1:7,   cohort = c(1:4, rep(5, 3)),   doseGrid = doseGrid ) postSamples1 <- mcmc(   data = firstFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples1, firstFullCohort) nextMaxDose <- maxDose(my_increments, firstFullCohort) nextMaxDose #> [1] 40  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples1,   model = model,   data = firstFullCohort ) doseRecommendation$value #> [1] 30  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples1,   model,   firstFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-second-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The second full cohort","title":"Trial Analysis","text":"Assume none three patients next cohort report DLT: Update model: Tabulate posterior: dose highest posterior probability target toxicity range now 45, dose also unacceptably high probability overdose range. Therefore, trial continue next cohort treated 30:","code":"secondFullCohort <- Data(   x = c(1, 3, 9, 20, 20, 20, 20, 30, 30, 30),   y = c(0, 0, 0, 1, 0, 0, 0, 0, 0, 0),   ID = 1:10,   cohort = c(1:4, rep(5, 3), rep(6, 3)),   doseGrid = doseGrid ) postSamples2 <- mcmc(   data = secondFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples2, secondFullCohort) nextMaxDose <- maxDose(my_increments, secondFullCohort) nextMaxDose #> [1] 45  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples2,   model = model,   data = secondFullCohort ) doseRecommendation$value #> [1] 30  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples2,   model,   secondFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-third-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The third full cohort","title":"Trial Analysis","text":"Assume none three patients third cohort report DLT: Update model: Tabulate posterior: 45 still dose highest posterior probability target toxicity range, probability overdose range now acceptable. Therefore, trial continue next cohort treated 45:","code":"thirdFullCohort <- Data(   x = c(1, 3, 9, rep(20, 4), rep(30, 6)),   y = c(0, 0, 0, 1, rep(0, 9)),   ID = 1:13,   cohort = c(1:4, rep(5, 3), rep(6, 3), rep(7, 3)),   doseGrid = doseGrid ) postSamples3 <- mcmc(   data = thirdFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples3, thirdFullCohort) nextMaxDose <- maxDose(my_increments, thirdFullCohort) nextMaxDose #> [1] 45  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples3,   model = model,   data = thirdFullCohort ) doseRecommendation$value #> [1] 45  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples3,   model,   thirdFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-fourth-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The fourth full cohort","title":"Trial Analysis","text":"Assume none three patients fourth cohort report DLT: Update model: Tabulate posterior: 60 now dose highest posterior probability target toxicity range, probability overdose range unacceptable. Therefore, trial continue next cohort treated 45:","code":"fourthFullCohort <- Data(   x = c(1, 3, 9, rep(20, 4), rep(30, 6), rep(45, 3)),   y = c(0, 0, 0, 1, rep(0, 12)),   ID = 1:16,   cohort = c(1:4, rep(5:8, each = 3)),   doseGrid = doseGrid ) postSamples4 <- mcmc(   data = fourthFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples4, fourthFullCohort) nextMaxDose <- maxDose(my_increments, fourthFullCohort) nextMaxDose #> [1] 67.5  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples4,   model = model,   data = fourthFullCohort ) doseRecommendation$value #> [1] 45  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples4,   model,   fourthFullCohort ) attributes(x) <- NULL x #> [1] FALSE"},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"the-fifth-full-cohort","dir":"Articles","previous_headings":"Analysing a trial","what":"The fifth full cohort","title":"Trial Analysis","text":"Assume two three patients fourth cohort report DLT: Update model: Tabulate posterior: 45 remains dose highest posterior probability target toxicity range, probability overdose range acceptable. Moreover, probability 45 target toxicity range 0.5 three cohorts treated total. Therefore, trial stop conclude 45 MTD:","code":"fifthFullCohort <- Data(   x = c(1, 3, 9, rep(20, 4), rep(30, 6), rep(45, 6)),   y = c(0, 0, 0, 1, rep(0, 13), 1, 1),   ID = 1:19,   cohort = c(1:4, rep(5:9, each = 3)),   doseGrid = doseGrid ) postSamples5 <- mcmc(   data = fifthFullCohort,   model = model,   options = vignetteMcmcOptions ) tabulatePosterior(postSamples5, fifthFullCohort) nextMaxDose <- maxDose(my_increments, fifthFullCohort) nextMaxDose #> [1] 67.5  doseRecommendation <- nextBest(   my_next_best,   doselimit = nextMaxDose,   samples = postSamples5,   model = model,   data = fifthFullCohort ) doseRecommendation$value #> [1] 45  x <- stopTrial(   my_stopping,   dose = doseRecommendation$value,   postSamples5,   model,   fifthFullCohort ) x #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 9 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 54 % for dose 45 and thus above the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 19 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 9 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 54 % for dose 45 and thus above the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 9 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] \"≥ 3 cohorts dosed\" #>  #> attr(,\"individual\")[[2]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 54 % for dose 45 and thus above the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\" #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 19 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] \"≥ 20 patients dosed\" #>  #> attr(,\"report_label\") #> [1] NA"},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"summarising-the-trial-results","dir":"Articles","previous_headings":"","what":"Summarising the trial results","title":"Trial Analysis","text":"crmPack provides wealth information trial’s results. following code snippets illustrate many possibilities trial might summarised.  {rfig.alt = \"plot posterior nineteen participants treated.  mean probability toxicity increases smoothly zero percent dose zero 55% dose 100.  confidence interval extends 0% 6% dose zero 22%  90% dose 100.\"} plot(postSamples5, model, fifthFullCohort) {rfig.alt = \"Two graphs arranged single column.  upper graph shoes green lines various heights show probability dose target toxicity range.  big arrow pointing bar dose 45, indicating dose highest probability target toxicity range.  lower graph similar series red lines, indicating probability dose overdose range.  horizontal black dashed line 25%, indicating highest acceptable probability overdose range.  red bars doses 60 extend 25%, indicating toxicity unacceptable.  toxicity doses 45 lie 25%.\"} doseRecommendation$plot little bit work, can obtain detailed summary plot posterior probabilities toxicity dose:","code":"plot(fifthFullCohort) slotNames(model) #> [1] \"params\"          \"ref_dose\"        \"datamodel\"       \"priormodel\"      #> [5] \"modelspecs\"      \"init\"            \"datanames\"       \"datanames_prior\" #> [9] \"sample\"  fullSamples <- tibble(   Alpha = postSamples5@data$alpha0,   Beta = postSamples5@data$alpha1 ) %>%   expand(nesting(Alpha, Beta), Dose = doseGrid) %>%   rowwise() %>%   mutate(P = probFunction(model, alpha0 = Alpha, alpha1 = Beta)(dose = Dose)) %>%   ungroup()  fullSummary <- fullSamples %>%   group_by(Dose) %>%   summarise(     Mean = mean(P),     Median = median(P),     Q = list(quantile(P, probs = c(0.05, 0.1, 0.25, 0.75, 0.9, 0.95), na.rm = TRUE))   ) %>%   unnest_wider(     col = Q,     names_repair = function(.x) {       ifelse(         str_detect(.x, \"\\\\d+%\"),         sprintf(\"Q%02.0f\", as.numeric(str_remove_all(.x, \"%\"))),         .x       )     }   ) #> Warning in sprintf(\"Q%02.0f\", as.numeric(str_remove_all(.x, \"%\"))): NAs #> introduced by coercion  fullSummary %>%   kableExtra::kable(     col.names = c(\"Dose\", \"Mean\", \"Median\", \"5th\", \"10th\", \"25th\", \"75th\", \"90th\", \"95th\"),     digits = c(0, rep(3, 8))   ) %>%   add_header_above(c(\" \" = 3, \"Quantiles\" = 6)) %>%   add_header_above(c(\" \" = 1, \"P(Toxicity)\" = 8)) fullSamples %>%   filter(Dose > 9) %>%   ggplot() +   geom_density(aes(x = P, color = as.factor(Dose))) +   theme_light() +   theme(     axis.text.y = element_blank(),     axis.title.y = element_blank(),     axis.ticks.y = element_blank()   ) +   labs(     title = \"Posterior PDFs for doses > 9\",     colour = \"Dose\"   ) fullSummary %>%   ggplot(aes(x = Dose)) +   geom_ribbon(aes(ymin = Q05, ymax = Q95), fill = \"steelblue\", alpha = 0.25) +   geom_ribbon(aes(ymin = Q10, ymax = Q90), fill = \"steelblue\", alpha = 0.25) +   geom_ribbon(aes(ymin = Q25, ymax = Q75), fill = \"steelblue\", alpha = 0.25) +   geom_line(aes(y = Mean), colour = \"black\") +   geom_line(aes(y = Median), colour = \"blue\") +   theme_light() +   labs(     title = \"Posterior Dose toxicity curve\",     colour = \"Dose\",     y = \"P(Toxicity)\"   ) #> Ignoring unknown labels: #> • colour : \"Dose\""},{"path":"https://openpharma.github.io/crmPack/articles/trial_analysis.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"Trial Analysis","text":"analyses presented vignette used chains short length. purely convenience. Analyses real trials use considerably longer chains. example, effective sample size approximately 40,000 required estimate percentage within ±1%.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/trial_definition.html","id":"defining-the-design","dir":"Articles","previous_headings":"","what":"Defining the design","title":"Trial Definition","text":"CRM study consists six basic elements: dose grid dose-toxicity model increment rule_1 dose recommendation rule1 cohort size1 stopping rule 1: Note crmPack, increment, dose selection cohort size rules collectively known escalation rules. many, many possible choices element. introduction, make simple choices value element. start loading crmPack package … … defining element turn.","code":"library(crmPack) #> Loading required package: ggplot2 #> Registered S3 method overwritten by 'crmPack': #>   method       from   #>   print.gtable gtable #> Type crmPackHelp() to open help browser #> Type crmPackExample() to open example"},{"path":"https://openpharma.github.io/crmPack/articles/trial_definition.html","id":"the-dose-grid","dir":"Articles","previous_headings":"Defining the design","what":"The dose grid","title":"Trial Definition","text":"First, list doses might used trial. commitment use every dose grid. define grid 9 doses ranging 1 100. crmPack agnostic respect units used measure doses. requirements dose grid ordered one dimensional. Additional doses can added whilst trial running. affect validity results trial prior addition, probably affect trial’s operating characteristics.","code":"# Define the dose grid. empty_data <- Data(doseGrid = c(1, 3, 9, 20, 30, 45, 60, 80, 100))"},{"path":"https://openpharma.github.io/crmPack/articles/trial_definition.html","id":"the-dose-toxicity-model","dir":"Articles","previous_headings":"Defining the design","what":"The dose toxicity model","title":"Trial Definition","text":"Next, define dose toxicity model. crmPack, LogisticLogNormal class fits model following form: log(pi1−pi)=α+βlog(di/d*)log(\\frac{p_i}{1 - p_i}) = \\alpha + \\beta log(d_i / d^*) d*d^* reference dose (specified ref_dose argument LogisticLogNormal function ) prior joint distribution α\\alpha β\\beta [αlog(β)]∼N([μαμβ],[σαασαβσβασββ]).\\begin{bmatrix} \\alpha \\\\ log(\\beta) \\end{bmatrix}   \\sim N\\begin{pmatrix} \\begin{bmatrix} \\mu_{\\alpha}\\\\ \\mu_{\\beta} \\end{bmatrix}   , \\begin{bmatrix} \\sigma_{\\alpha\\alpha} & \\sigma_{\\alpha\\beta} \\\\ \\sigma_{{\\beta\\alpha}} & \\sigma_{\\beta\\beta} \\end{bmatrix}    \\end{pmatrix}. mean covariance matrices defined mean cov parameters LogisticLogNormal call. code defines prior joint distribution α\\alpha log(β)log(\\beta) N([−0.850],[1−0.5−0.51]).  N\\begin{pmatrix} \\begin{bmatrix} -0.85\\\\0 \\end{bmatrix}   , \\begin{bmatrix} 1 & -0.5 \\\\ -0.5 & 1 \\end{bmatrix}    \\end{pmatrix}. easy obtain visual representation prior:","code":"# Initialize the CRM model. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 ) vignetteMcmcOptions <- McmcOptions(burnin = 100, step = 2, samples = 1000) prior_samples <- mcmc(   data = empty_data,   model = model,   options = vignetteMcmcOptions ) plot(prior_samples, model, empty_data)"},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/trial_definition.html","id":"the-maximum-increment","dir":"Articles","previous_headings":"Defining the design > The escalation rules","what":"The maximum increment","title":"Trial Definition","text":"Now, define maximum possible increment dose used current cohort dose used next, regardless likely toxicity. rule chosen defines maximum possible increment terms multiples highest dose far administered: doses greater 0 less 20, maximum increment 100% x 2, 200% highest dose used far (escalation 100% x (1 + 2) = 300% highest dose used far). doses 20 , maximum increment 100% x 0.5, 50% highest dose used far, dose 100% x (1 + 0.5) = 150% highest dose used far. Note 2-fold increment corresponds 3-fold escalation. tabular form, based dose grid defined , maximum permitted escalation , highest dose used far 9, highest dose dose grid can used next cohort 20, even 30 higher doses deemed safe NextBest rule. Next, define rule choosing best dose next cohort","code":"# Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 30),   increments = c(2, 0.5) )"},{"path":"https://openpharma.github.io/crmPack/articles/trial_definition.html","id":"the-nextbest-rule-for-recommending-the-best-dose-for-the-next-cohort","dir":"Articles","previous_headings":"Defining the design > The escalation rules","what":"The NextBest rule for recommending the best dose for the next cohort","title":"Trial Definition","text":", choose use Neuenschwander’s rule (Neuenschwander, Branson, Gsponer 2008), dose next cohort dose (amongst doses eligible selection according escalation rule) highest posterior chance probability toxicity target range - [0.2, 0.35) - provided dose’s chance probability toxicity overdose range - [0.35, 1.0] - less 0.25.","code":"# Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )"},{"path":"https://openpharma.github.io/crmPack/articles/trial_definition.html","id":"the-cohort-size","dir":"Articles","previous_headings":"Defining the design > The escalation rules","what":"The cohort size","title":"Trial Definition","text":"Now, define rule choosing size next cohort. Note, term “cohort size” somewhat anachronistic. hangover days 3+3 design. context CRM trials, best interpreted “largest permitted interval CRM model updates”. CRM trial, model can updated time mathematical need halt recruitment allow model updated. elect define cohort size using compound rule. dose used number DLTs far observed contribute decision. first part compound rule (my_size_1), based dose used, permits use single patient run-including dose 20. doses 20, minimum cohort size 3. second part compound rule (my_size_2) also permits single patient run-, long DLTs far observed. soon first DLT reported, minimum cohort size 3. determine actual size next cohort, larger number required two parts compound rule used. words, provided dose 20 DLTs observed, single patient cohort permitted. cases, required cohort size 3.","code":"# Choose the rule for the cohort size. my_size_1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size_2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size_1, my_size_2)"},{"path":"https://openpharma.github.io/crmPack/articles/trial_definition.html","id":"the-stopping-rules","dir":"Articles","previous_headings":"Defining the design","what":"The stopping rules","title":"Trial Definition","text":"Now create rules define trial’s objectives met (stopped futility). futility rule easiest explain: twenty patients recruited, study stop (my_stopping_3). success rule requires following conditions met: least three cohorts must treated probability current estimate MTD target toxicity range must least 0.5. trial stop either futility rule components success rule satisfied.","code":"# Choose the rule for stopping. my_stopping_1 <- StoppingMinCohorts(nCohorts = 3) my_stopping_2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping_3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping_1 & my_stopping_2) | my_stopping_3"},{"path":"https://openpharma.github.io/crmPack/articles/trial_definition.html","id":"the-overall-trial-design","dir":"Articles","previous_headings":"Defining the design","what":"The overall trial design","title":"Trial Definition","text":"Finally, combine six elements design, together starting dose, define trial. now ready use trial definition, either analyse real trial simulate long term operating characteristics design. processes described vignettes .","code":"# Initialize the design. design <- Design(   model = model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = empty_data,   startingDose = 3 )"},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/trial_sanity_checks.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Trial Design: basic sanity checks","text":"vignette contains example basic superficial examination operating characteristics basic CRM trial. design uses 2-parameter logistic regression model log normal prior distribution, custom rules choosing cohort size, deciding whether stop continue trial, defining maximum permitted increment selecting dose nest study. first step define trial design crmPack…","code":""},{"path":"https://openpharma.github.io/crmPack/articles/trial_sanity_checks.html","id":"study-definition","dir":"Articles","previous_headings":"","what":"Study definition","title":"Trial Design: basic sanity checks","text":"","code":"library(crmPack)   # Define the dose grid and an empty data object dose_grid <- c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100) empty_data <- Data(doseGrid = dose_grid)  # Initialize the CRM model. initial_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose. next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort size. cohort_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) cohort_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) cohort_size <- maxSize(cohort_size1, cohort_size2)  # Choose the rule for stopping. stopping_success1 <- StoppingMinCohorts(nCohorts = 3) stopping_success2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) stopping_futility <- StoppingMinPatients(nPatients = 20) stopping_trial <- (stopping_success1 & stopping_success2) | stopping_futility  # Choose the rule for dose increments. increment_rule <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- Design(   model = initial_model,   nextBest = next_best,   stopping = stopping_trial,   increments = increment_rule,   cohort_size = cohort_size,   data = empty_data,   startingDose = 3 )"},{"path":"https://openpharma.github.io/crmPack/articles/trial_sanity_checks.html","id":"incoherence-and-rigidity","dir":"Articles","previous_headings":"","what":"Incoherence and rigidity","title":"Trial Design: basic sanity checks","text":"examine function lists dose recommendations made CRM design first DLT reported. output shows, dose number DLTs reported, dose recommendation (nextBest dose) made model assumption earlier DLTs reported lower doses. Cheung (Cheung 2013) (p146) describes CRM trial* rigid exists dose escalation possible regardless number participants experience treated dose. (p164) defines CRM trial incoherent , among criteria, recommends dose escalation immediately following first report DLT. *: Strictly, Cheung defines incoherence rigidity terms trial’s dose-toxicity model. extend terms include trial’s design features, including escalation, dose selection, increments stopping rules. output examine shows initial design incoherent (recommendation increase dose used next cohort following first report DLT), rigid. rigid , even toxicities reported 25 mg, model unable recommend escalation trial’s futility stopping rule (defined stopping_futility ) satisfied. clearly unsatisfactory. problem lies increments rule, allows maximum escalation 33% one dose next doses 20 mg. dose grid used 1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100. ratio 20 25 1.25, 25 40 1.6. can confirm checking behaviour maxDose artificial data: Thus, initial dose rule permanently prevents escalation 25 mg highest permitted dose 25 mg 33.25 lowest dose dose grid 40. problem can solved least two ways: can either relax increments rule can introduce one intermediate doses. (, course, .) choose relax increments rule check , ceteris paribus, permits escalation every dose: Yes, . update design:","code":"examine(design) %>% kable() no_tox_below_25_data <- Data(   doseGrid = dose_grid,   x = c(1, 3, 5, 10, 15, 20, 25),   y = rep(0, 7),   ID = 1L:7L,   cohort = 1L:7L )  next_dose <- maxDose(increment_rule, no_tox_below_25_data) next_dose #> [1] 33.25 revised_increment_rule <- IncrementsRelative(   intervals = c(0, 20, 80),   increments = c(1, 0.67, 0.33) ) tibble(   HighestDoseUsed = dose_grid,   MaxPermittedDose = c(     NA,     sapply(       seq_along(dose_grid[-1]),       function(n) {         tmp <- dose_grid[-1]         d <- Data(           doseGrid = dose_grid,           x = tmp[1:n],           y = rep(0, n),           ID = as.integer(1:n),           cohort = as.integer(1:n)         )         maxDose(revised_increment_rule, d)       }     )   ) ) %>%   mutate(EscalationPermitted = lead(HighestDoseUsed < MaxPermittedDose)) %>%   kable() revised_design <- Design(   model = initial_model,   nextBest = next_best,   stopping = stopping_trial,   increments = revised_increment_rule,   cohort_size = cohort_size,   data = empty_data,   startingDose = 3 )"},{"path":"https://openpharma.github.io/crmPack/articles/trial_sanity_checks.html","id":"does-the-prior-make-sense","dir":"Articles","previous_headings":"","what":"Does the prior make sense?","title":"Trial Design: basic sanity checks","text":"Hmmm. now appear stuck 50 mg. ? Let’s examine state model escalation 50 mg without toxicity… Whilst increments rule allows escalation 83.5 mg, toxicity estimates provided model : current estimate toxicity 80 mg 0.79, well limit 0.25 defined dose recommendation rule (next_best). , several options. can introduce intermediate doses, thus slowing escalation allowing prior model time adapt (probably requiring larger trial), can modify prior allows faster, still reasonable, escalation. Let’s try creating minimally informative prior consistent first attempt. prior θ given by𝛉=[αβ]∼N([0.981.35],[1.920.050.050.00]) \\boldsymbol\\theta = \\begin{bmatrix}\\alpha \\\\ \\beta\\end{bmatrix}\\sim N \\left(\\begin{bmatrix} 0.98 \\\\  1.35\\end{bmatrix} , \\begin{bmatrix} 1.92 &  0.05 \\\\ 0.05 &  0.00\\end{bmatrix} \\right) minimally informative model prior distribution (αlog(β))∼N([0.9791.348],[1.9230.0450.0450.002])\\binom{\\alpha}{log(\\beta)} \\sim N \\left( \\left[\\begin{array}{rr} 0.979 \\\\  1.348 \\end{array}\\right], \\left[\\begin{array}{rr}  1.923 &  0.045 \\\\  0.045 &  0.002\\end{array}\\right]\\right) fix rigidity problem? Yes, . can now escalate dose 80, plateaux . First, two toxicity-free participants, rather just one, needed escalate 20 mg 25 mg. Similarly, four toxicity-free participants required escalate 25 mg 40 mg. fine tuning prior probably allow numbers reduced, purposes vignette, explore possibility. Now create data represent trial escalates without reports toxicity, fit revised model … importantly, results illustrate something obvious outset: expecting trial identify MTD definitively fewer 20 participants unrealistic (unless MTD much towards left hand - lower - end dose grid) takes almost 20 participants travel lower end dose grid upper. Ignoring plateauing mentioned previous paragraph, increments rule defined means need least one participant doses 1, 3, 5, 10, 15 20 mg, three 25, 40, 50, 80 100 mg. ’s total 6 x 1 + 5 x 3 = 21 participants. hit futility limit finish escalation dose grid, even DLTs reported. ’s simply realistic. final alteration increase futility rule 20 participants 40. new design allows us escalate full extent dose grid futility stopping rule kicks . refinement prior model may remove need additional cohorts escalation 20, 25 50 mg. leave exercise reader. now design worthy detailed investigation operating characteristics. next vignette series, yet written.","code":"examine(revised_design) %>% kable() no_tox_below_50_data <- Data(   doseGrid = dose_grid,   x = c(1, 3, 5, 10, 15, 20, 25, 40, 40, 40, 50, 50, 50),   y = rep(0, 13),   ID = 1L:13L,   cohort = c(1L:7L, rep(8L:9L, each = 3)) )  default_mcmc_options <- McmcOptions(burnin = 1000, step = 2, samples = 1000) no_tox_50_samples <- mcmc(no_tox_below_50_data, initial_model, default_mcmc_options) recommended_dose <- nextBest(   next_best,   doselimit = Inf,   samples = no_tox_50_samples,   model = initial_model,   data = no_tox_below_50_data ) recommended_dose$value #> [1] 50 recommended_dose$probs #>       dose target overdose #>  [1,]    1  0.000    0.000 #>  [2,]    3  0.000    0.000 #>  [3,]    5  0.000    0.000 #>  [4,]   10  0.002    0.000 #>  [5,]   15  0.003    0.000 #>  [6,]   20  0.008    0.000 #>  [7,]   25  0.013    0.000 #>  [8,]   40  0.038    0.007 #>  [9,]   50  0.154    0.017 #> [10,]   80  0.162    0.790 #> [11,]  100  0.073    0.913  maxDose(revised_increment_rule, no_tox_below_50_data) #> [1] 83.5 # Fitting the min_inf_model is slow. if (file.exists(\"minInfModel.Rds\")) {   min_inf_model <- readRDS(\"minInfModel.Rds\") } else {   min_inf_model <- MinimalInformative(     dose_grid,     56,     threshmin = 0.1,     threshmax = 0.4,     probmin = 0.05,     probmax = 0.05   )    as_tibble(min_inf_model$required) %>%     add_column(Dose = dose_grid) %>%     add_column(Type = \"Required\") %>%     bind_rows(       as_tibble(min_inf_model$quantiles) %>%         add_column(Dose = dose_grid) %>%         add_column(Type = \"Fitted\")     ) %>%     ggplot() +     geom_line(aes(x = Dose, y = median, colour = Type), linetype = \"solid\") +     geom_line(aes(x = Dose, y = lower, colour = Type), linetype = \"dotted\") +     geom_line(aes(x = Dose, y = upper, colour = Type), linetype = \"dotted\")    saveRDS(min_inf_model, \"minInfModel.Rds\") }  min_inf_model$model@params revised_model <- min_inf_model$model  revised_design1 <- Design(   model = revised_model,   nextBest = next_best,   stopping = stopping_trial,   increments = revised_increment_rule,   cohort_size = cohort_size,   data = empty_data,   startingDose = 3 )  examine(revised_design1) %>% kable() no_tox_data <- Data(   doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100),   x = c(c(1, 3, 5, 10, 15, 20), rep(c(25, 40, 50, 80, 100), each = 3)),   y = rep(0, 21),   cohort = as.integer(c(1:6, rep(7:11, each = 3))),   ID = as.integer(1:21) )  no_tox_samples <- mcmc(no_tox_data, revised_model, default_mcmc_options)  recommended_dose <- nextBest(   next_best,   doselimit = Inf,   samples = no_tox_samples,   model = initial_model,   data = no_tox_data ) recommended_dose$probs #>       dose target overdose #>  [1,]    1  0.000    0.000 #>  [2,]    3  0.000    0.000 #>  [3,]    5  0.000    0.000 #>  [4,]   10  0.000    0.000 #>  [5,]   15  0.000    0.000 #>  [6,]   20  0.000    0.000 #>  [7,]   25  0.000    0.000 #>  [8,]   40  0.004    0.000 #>  [9,]   50  0.042    0.001 #> [10,]   80  0.208    0.017 #> [11,]  100  0.248    0.084  stopTrial(stopping_trial, recommended_dose$value, no_tox_samples, initial_model, no_tox_data) #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 11 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 25 % for dose 100 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 21 and thus reached the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 11 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 25 % for dose 100 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 11 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] \"≥ 3 cohorts dosed\" #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 25 % for dose 100 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\" #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of patients is 21 and thus reached the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] \"≥ 20 patients dosed\" #>  #> attr(,\"report_label\") #> [1] NA revised_stopping_futility <- StoppingMinPatients(nPatients = 40) revised_stopping_trial <- (stopping_success1 & stopping_success2) | revised_stopping_futility  revised_design2 <- Design(   model = revised_model,   nextBest = next_best,   stopping = revised_stopping_trial,   increments = revised_increment_rule,   cohort_size = cohort_size,   data = empty_data,   startingDose = 3 )"},{"path":"https://openpharma.github.io/crmPack/articles/trial_sanity_checks.html","id":"final-observation","dir":"Articles","previous_headings":"","what":"Final observation","title":"Trial Design: basic sanity checks","text":"simulations used vignette used relatively short chains 1000 samples, purely interests speed. investigating properties real trial, much longer chain lengths used. example, estimate binomial probability accuracy ±1%, effective sample size (ESS) around 40,000 required.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/articles/trial_simulation.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Trial Simulation","text":"basic example shows run simulations CRM 2-parameter logistic regression model, using log normal prior distribution, custom cohort size, stopping maximum increments rules:","code":"library(crmPack)  # Define the dose grid. empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort size. my_size_1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size_2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size_1, my_size_2)  # Choose the rule for stopping. my_stopping_1 <- StoppingMinCohorts(nCohorts = 3) my_stopping_2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping_3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping_1 & my_stopping_2) | my_stopping_3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- Design(   model = model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = empty_data,   startingDose = 3 )  # Define the true function. my_truth <- function(dose) {   alpha0 <- 7   alpha1 <- 8   ref_dose <- 56   stand_log_dose <- log(dose / ref_dose)   plogis(alpha0 + alpha1 * stand_log_dose) }  # Run the simulation on the desired design. # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course. options <- McmcOptions(   burnin = 100,   step = 1,   samples = 2000 ) time <- system.time(my_sims <- simulate(design,   args = NULL,   truth = my_truth,   nsim = 1,   seed = 819,   mcmcOptions = options,   parallel = FALSE ))[3]"},{"path":"https://openpharma.github.io/crmPack/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel Sabanes Bove. Author, maintainer. Wai Yin Yeung. Author. Burak Kuersad Guenhan. Author. Giuseppe Palermo. Author. Thomas Jaki. Author. Jiawen Zhu. Author. Ziwei Liao. Author. Dimitris Kontos. Author. Marlene Schulte-Goebel. Author. Doug Kelkhoff. Author. Oliver Boix. Author. Robert Adams. Author. Clara Beck. Author. John Kirkpatrick. Author. F. Hoffmann-La Roche AG. Copyright holder, funder. Merck Healthcare KGaA. Copyright holder, funder. Bayer AG. Copyright holder, funder.","code":""},{"path":"https://openpharma.github.io/crmPack/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sabanés Bové D, Yeung WY, Palermo G, Jaki T (2019). “Model-Based Dose Escalation Designs R crmPack.” Journal Statistical Software, 89(10), 1–22. doi:10.18637/jss.v089.i10.","code":"@Article{,   title = {Model-Based Dose Escalation Designs in {R} with {crmPack}},   author = {Daniel {Saban\\'es Bov\\'e} and Wai Yin Yeung and Giuseppe Palermo and Thomas Jaki},   journal = {Journal of Statistical Software},   year = {2019},   volume = {89},   number = {10},   pages = {1--22},   doi = {10.18637/jss.v089.i10}, }"},{"path":"https://openpharma.github.io/crmPack/index.html","id":"crmpack","dir":"","previous_headings":"","what":"Object-Oriented Implementation of CRM Designs","title":"Object-Oriented Implementation of CRM Designs","text":"goal crmPack implement wide range model-based dose escalation designs, ranging classical modern continual reassessment methods (CRMs) based dose-limiting toxicity endpoints dual-endpoint designs taking account biomarker/efficacy outcome. focus Bayesian inference, making easy setup new design JAGS code. However, also possible implement 3+3 designs comparison models non-Bayesian estimation. whole package written modular form S4 class system, making flexible adaptation new models, escalation stopping rules.","code":""},{"path":"https://openpharma.github.io/crmPack/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Object-Oriented Implementation of CRM Designs","text":"can install development version crmPack GitHub : can install stable release version crmPack CRAN :","code":"devtools::install_github(\"openpharma/crmPack\") install.packages(\"crmPack\")"},{"path":"https://openpharma.github.io/crmPack/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Object-Oriented Implementation of CRM Designs","text":"package vignettes provide information various aspects CRM trial design, implementation, simulation analysis: Trial definition Trial analysis Sanity checking Simulation operating characteristics Ordinal CRM models Extending crmPack Tidy crmPack data Describing crmPack objects Markdown Quarto documents Migration old crmPack Sabanes Bove et al (2019) Model-based Dose Escalation Designs R crmPack. JSS 89:10 DOI 10.18637/jss.v089.i10","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSize — .DefaultCohortSize","title":"CohortSize — .DefaultCohortSize","text":"CohortSize class cohort sizes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSize-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSize — .DefaultCohortSize","text":"","code":".DefaultCohortSize()  .DefaultCohortSize()"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSize-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSize — .DefaultCohortSize","text":"Typically, end users use DefaultCohortSize() function. Typically, end users use DefaultCohortSize() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeConst-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeConst — CohortSizeConst-class","title":"CohortSizeConst — CohortSizeConst-class","text":"CohortSizeConst class fixed constant size cohort.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeConst-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeConst — CohortSizeConst-class","text":"","code":"CohortSizeConst(size)  .DefaultCohortSizeConst()"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeConst-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeConst — CohortSizeConst-class","text":"size (number) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeConst-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeConst — CohortSizeConst-class","text":"size (integer) cohort size.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeConst-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeConst — CohortSizeConst-class","text":"Typically, end users use .DefaultCohortSizeConst() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeConst-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeConst — CohortSizeConst-class","text":"","code":"# Cohort of size 3, constant along the study. my_size <- CohortSizeConst(size = 3)"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeDLT-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeDLT — CohortSizeDLT-class","title":"CohortSizeDLT — CohortSizeDLT-class","text":"CohortSizeDLT class cohort size based number DLTs.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeDLT — CohortSizeDLT-class","text":"","code":"CohortSizeDLT(intervals, cohort_size)  .DefaultCohortSizeDLT()"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeDLT — CohortSizeDLT-class","text":"intervals (numeric) see slot definition. cohort_size (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeDLT — CohortSizeDLT-class","text":"intervals (integer) vector left bounds relevant DLT intervals. cohort_size (integer) vector cohort sizes corresponding elements intervals.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeDLT — CohortSizeDLT-class","text":"Typically, end users use .DefaultCohortSizeDLT() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeDLT-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeDLT — CohortSizeDLT-class","text":"","code":"# Rule for having cohort of size 1 until no DLT is observed and having cohort # of size 3 as soon as 1 DLT is observed. my_size <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMax-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeMax — CohortSizeMax-class","title":"CohortSizeMax — CohortSizeMax-class","text":"CohortSizeMax class cohort size based maximum multiple cohort size rules. cohort_sizes slot stores set cohort size rules, objects class CohortSize. maximum individual cohort sizes taken give final cohort size.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMax-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeMax — CohortSizeMax-class","text":"","code":".DefaultCohortSizeMax()  CohortSizeMax(cohort_sizes)"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMax-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeMax — CohortSizeMax-class","text":"cohort_sizes (list) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMax-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeMax — CohortSizeMax-class","text":"cohort_sizes (list) list cohort size rules, .e. objects class CohortSize.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMax-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeMax — CohortSizeMax-class","text":"Typically, end users use .DefaultCohortSizeMax() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMax-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeMax — CohortSizeMax-class","text":"","code":"# Rule for cohort of size 1 for doses <30 and cohort of size 3 for doses >=30. my_size1 <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))  # Rule for cohort of size 1 until no DLT were observed and cohort of size 3 # as soon as 1 DLT is observed. my_size2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))  # Cohort size rules of class 'CohortSizeMax' which will then be combined with # the 'max' operation. mySize <- CohortSizeMax(cohort_sizes = list(my_size1, my_size2))"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMin-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeMin — CohortSizeMin-class","title":"CohortSizeMin — CohortSizeMin-class","text":"CohortSizeMin class cohort size based minimum multiple cohort size rules. cohort_sizes slot stores set cohort size rules, objects class CohortSize. minimum individual cohort sizes taken give final cohort size.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMin-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeMin — CohortSizeMin-class","text":"","code":"CohortSizeMin(cohort_sizes)  .DefaultCohortSizeMin()"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMin-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeMin — CohortSizeMin-class","text":"cohort_sizes (list) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMin-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeMin — CohortSizeMin-class","text":"cohort_sizes (list) list cohort size rules, .e. objects class CohortSize.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMin-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeMin — CohortSizeMin-class","text":"Typically, end users use .DefaultCohortSizeMin() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeMin-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeMin — CohortSizeMin-class","text":"","code":"# Rule for cohort of size 1 for doses <30 and cohort of size 3 for doses >=30. my_size1 <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))  # Rule for cohort of size 1 until no DLT were observed and cohort of size 3 # as soon as 1 DLT is observed. my_size2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))  # Cohort size rules of class 'CohortSizeMin' which will then be combined with # the 'min' operation. my_size <- CohortSizeMin(cohort_sizes = list(my_size1, my_size2))"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeOrdinal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeOrdinal — CohortSizeOrdinal-class","title":"CohortSizeOrdinal — CohortSizeOrdinal-class","text":"CohortSizeOrdinal class cohort size ordinal CRM trial.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeOrdinal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeOrdinal — CohortSizeOrdinal-class","text":"","code":"CohortSizeOrdinal(grade, rule)  .DefaultCohortSizeOrdinal()"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeOrdinal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeOrdinal — CohortSizeOrdinal-class","text":"grade (integer) see slot definition. rule (CohortSize) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeOrdinal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeOrdinal — CohortSizeOrdinal-class","text":"grade (integer) grade rule applied rule (CohortSize) CohortSize rule apply.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeOrdinal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeOrdinal — CohortSizeOrdinal-class","text":"Typically, end users use .DefaultCohortSizeOrdinal() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeOrdinal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeOrdinal — CohortSizeOrdinal-class","text":"","code":"CohortSizeOrdinal(   grade = 1L,   rule = CohortSizeRange(intervals = c(0, 30), cohort_size = c(1L, 3L)) ) #> An object of class \"CohortSizeOrdinal\" #> Slot \"grade\": #> [1] 1 #>  #> Slot \"rule\": #> An object of class \"CohortSizeRange\" #> Slot \"intervals\": #> [1]  0 30 #>  #> Slot \"cohort_size\": #> [1] 1 3 #>  #>"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeParts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeParts — CohortSizeParts-class","title":"CohortSizeParts — CohortSizeParts-class","text":"CohortSizeParts class cohort size changes second part dose escalation. works conjunction DataParts objects.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeParts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeParts — CohortSizeParts-class","text":"","code":"CohortSizeParts(cohort_sizes)  .DefaultCohortSizeParts()"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeParts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeParts — CohortSizeParts-class","text":"cohort_sizes (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeParts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeParts — CohortSizeParts-class","text":"cohort_sizes (integer) vector length two two sizes, one part 1, one part 2 respectively.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeParts-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeParts — CohortSizeParts-class","text":"Typically, end users use .DefaultCohortSizeParts() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeParts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeParts — CohortSizeParts-class","text":"","code":"# Part 1 cohort size = 1, Part 2 cohort size = 3. my_size <- CohortSizeParts(cohort_sizes = c(1, 3))"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeRange-class.html","id":null,"dir":"Reference","previous_headings":"","what":"CohortSizeRange — CohortSizeRange-class","title":"CohortSizeRange — CohortSizeRange-class","text":"CohortSizeRange class cohort size based dose range.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeRange-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CohortSizeRange — CohortSizeRange-class","text":"","code":"CohortSizeRange(intervals, cohort_size)  .DefaultCohortSizeRange()"},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeRange-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CohortSizeRange — CohortSizeRange-class","text":"intervals (numeric) see slot definition. cohort_size (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeRange-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"CohortSizeRange — CohortSizeRange-class","text":"intervals (numeric) vector left bounds relevant dose intervals. cohort_size (integer) integer vector cohort sizes corresponding elements intervals.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeRange-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CohortSizeRange — CohortSizeRange-class","text":"Typically, end users use .DefaultCohortSizeRange() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/CohortSizeRange-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CohortSizeRange — CohortSizeRange-class","text":"","code":"# Example for the rule having cohort of size 1 for doses <30 # and having cohort of size 3 for doses >=30.  my_size <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3))"},{"path":"https://openpharma.github.io/crmPack/reference/CrmPackClass.html","id":null,"dir":"Reference","previous_headings":"","what":"CrmPackClass — CrmPackClass-class","title":"CrmPackClass — CrmPackClass-class","text":"CrmPackClass virtual class, crmPack classes inherit.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DADesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DADesign — DADesign-class","title":"DADesign — DADesign-class","text":"class special requirements model data slots comparison parent class Design:","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DADesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DADesign — DADesign-class","text":"","code":"DADesign(model, data, safetyWindow, ...)  .DefaultDADesign()"},{"path":"https://openpharma.github.io/crmPack/reference/DADesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DADesign — DADesign-class","text":"model (GeneralModel) see slot definition. data (DataDA) see slot definition. safetyWindow (SafetyWindow) see slot definition. ... Arguments passed Design stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DADesign-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DADesign — DADesign-class","text":"safetyWindow slot instance SafetyWindow class. can customized specify duration safety window trial. safety window represents time period required observe toxicity data ongoing cohort opening next cohort. Note even opening next cohort, toxicity data collected analyzed make dose escalation decisions. specify constant safety window, use SafetyWindowConst constructor. example: mysafetywindow <- SafetyWindowConst(c(6, 2), 10, 20)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DADesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DADesign — DADesign-class","text":"model (GeneralModel) model use, see particular DALogisticLogNormal TITELogisticLogNormal make use time--DLT data. data (DataDA) dose grid, previous data, etc. safetyWindow (SafetyWindow) safety window apply cohorts.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DADesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DADesign — DADesign-class","text":"Typically, end users use .DefaultDADesign() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/DADesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DADesign — DADesign-class","text":"","code":"empty_data <- DataDA(   doseGrid = c(     0.1,     0.5,     1,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ),   Tmax = 60 )  npiece <- 10 t_max <- 60  lambda_prior <- function(k) {   npiece / (t_max * (npiece - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece,   l = as.numeric(t(apply(as.matrix(c(1:npiece), 1, npiece), 2, lambda_prior))),   c_par = 2 )  my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) )  my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  my_size <- maxSize(my_size1, my_size2)  my_stopping1 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 )  my_stopping2 <- StoppingMinPatients(nPatients = 50)  my_stopping <- (my_stopping1 | my_stopping2)  my_safety_window <- SafetyWindowConst(c(6, 2), 7, 7)  design <- DADesign(   model = model,   increments = my_increments,   nextBest = my_next_best,   stopping = my_stopping,   cohort_size = my_size,   data = empty_data,   safetyWindow = my_safety_window,   startingDose = 3 )"},{"path":"https://openpharma.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DALogisticLogNormal — DALogisticLogNormal-class","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"DALogisticLogNormal class logistic model bivariate (log) normal prior data augmentation. class inherits LogisticLogNormal class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"","code":"DALogisticLogNormal(npiece = 3, l, c_par = 2, cond_pem = TRUE, ...)  .DefaultDALogisticLogNormal()"},{"path":"https://openpharma.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"npiece (number) number pieces PEM. l (numeric) vector used lambda prior. c_par (numeric) parameter used lambda prior; according Liu's paper, c_par = 2 recommended. cond_pem (flag) conditional piecewise-exponential model used? (default). Otherwise unconditional model used. ... Arguments passed LogisticLogNormal mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"npiece (number) number pieces PEM. l (numeric) vector used lambda prior. c_par (numeric) parameter used lambda prior; according Liu's paper, c_par = 2 recommended. cond_pem (flag) conditional piecewise-exponential model used? (default). Otherwise unconditional model used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"still need include formula lambda prior. Typically, end users use .DefaultDALogisticLogNormal() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/DALogisticLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DALogisticLogNormal — DALogisticLogNormal-class","text":"","code":"npiece <- 10 Tmax <- 60 # nolintr  lambda_prior <- function(k) {   npiece / (Tmax * (npiece - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece,   l = as.numeric(t(apply(as.matrix(c(1:npiece), 1, npiece), 2, lambda_prior))),   c_par = 2 )"},{"path":"https://openpharma.github.io/crmPack/reference/DASimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the simulations output from DA based designs — DASimulations-class","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"class captures trial simulations DA based designs. comparison parent class Simulations, contains additional slots capture time DLT fits, additional parameters trial duration.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DASimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"","code":".DefaultDASimulations()"},{"path":"https://openpharma.github.io/crmPack/reference/DASimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"trialduration vector trial duration values simulations.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DASimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class for the simulations output from DA based designs — DASimulations-class","text":"Typically, end users use .DASimulations() function.  function noticeable execution time.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DASimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialization function for DASimulations — DASimulations","title":"Initialization function for DASimulations — DASimulations","text":"Initialization function DASimulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DASimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialization function for DASimulations — DASimulations","text":"","code":"DASimulations(trialduration, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/DASimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialization function for DASimulations — DASimulations","text":"trialduration see DASimulations ... additional parameters Simulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DASimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialization function for DASimulations — DASimulations","text":"DASimulations object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DLTLikelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood of DLTs in each interval — DLTLikelihood","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"helper function fitPEM methods .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DLTLikelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"","code":"DLTLikelihood(lambda, Tmax)"},{"path":"https://openpharma.github.io/crmPack/reference/DLTLikelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"lambda vector piecewise hazards Tmax end time interval DLTs","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DLTLikelihood.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood of DLTs in each interval — DLTLikelihood","text":"vector probabilities DLTs within intervals.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Data-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Data — Data-class","title":"Data — Data-class","text":"Data class data input. inherits GeneralData.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Data-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data — Data-class","text":"","code":"Data(   x = numeric(),   y = integer(),   ID = integer(),   cohort = integer(),   doseGrid = numeric(),   placebo = FALSE,   ... )  .DefaultData()"},{"path":"https://openpharma.github.io/crmPack/reference/Data-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data — Data-class","text":"x (numeric) doses patients. y (integer) vector toxicity events (0 1). can also supply numeric vectors, converted integer internally. ID (integer) unique patient IDs. can also supply numeric vectors, converted integer internally. cohort (integer) cohort (non-negative sorted) indices. can also supply numeric vectors, converted integer internally. doseGrid (numeric) possible doses. placebo (flag) TRUE first dose level doseGrid considered placebo. ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Data-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data — Data-class","text":"cohort can missing placebo equal FALSE.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Data-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Data — Data-class","text":"x (numeric) doses patients. y (integer) vector toxicity events (0 1 integers). doseGrid (numeric) vector possible doses (sorted), .e. dose grid. nGrid (integer) number gridpoints. xLevel (integer) levels doses patients given, w.r.t doseGrid. placebo (logical) TRUE first dose level doseGridis considered PLACEBO.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Data-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Data — Data-class","text":"ID cohort can missing. message issued variables filled default IDs best guesses cohort, .e. sorted (ascending order) sequence values {1, 2, ...}. Typically, end users use .DefaultData() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Data-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data — Data-class","text":"","code":"my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = as.integer(1:8),   cohort = as.integer(c(1, 2, 3, 4, 5, 6, 6, 6)),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ) ) my_data #> An object of class \"Data\" #> Slot \"x\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 #>  #> Slot \"y\": #> [1] 0 0 0 0 0 0 1 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 5 6 7 8 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"nObs\": #> [1] 8 #>"},{"path":"https://openpharma.github.io/crmPack/reference/DataDA-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataDA — DataDA-class","title":"DataDA — DataDA-class","text":"DataDA class time--DLT augmented data. inherits Data contains additional DLT free survival times.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataDA-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataDA — DataDA-class","text":"","code":"DataDA(   u = numeric(),   t0 = numeric(length(u)),   Tmax = 0 + .Machine$double.xmin,   ... )  .DefaultDataDA()"},{"path":"https://openpharma.github.io/crmPack/reference/DataDA-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataDA — DataDA-class","text":"u (numeric) continuous vector DLT free survival times. t0 (numeric) time initial dosing patient. Non-negative values sorted ascending order. Default vector 0s length equal length u. Tmax (number) DLT observation period. ... parameters passed Data().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataDA-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataDA — DataDA-class","text":"u (numeric) continuous vector DLT free survival times. t0 (numeric) time initial dosing patient. Non-negative values sorted ascending order. Tmax (number) DLT observation period.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataDA-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataDA — DataDA-class","text":"survival time refers time period subject experience DLT, referring deaths. Typically, end users use .DefaultDataDA() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataDA-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataDA — DataDA-class","text":"","code":"my_data <- DataDA(   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60,   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Set up an empty data set. empty_data <- DataDA(   doseGrid = c(0.1, 0.5, 1, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   Tmax = 60 ) empty_data #> An object of class \"DataDA\" #> Slot \"u\": #> numeric(0) #>  #> Slot \"t0\": #> numeric(0) #>  #> Slot \"Tmax\": #> [1] 60 #>  #> Slot \"x\": #> numeric(0) #>  #> Slot \"y\": #> integer(0) #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.0  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 #> [16] 28.0 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 #> [31] 58.0 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 42 #>  #> Slot \"xLevel\": #> integer(0) #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> integer(0) #>  #> Slot \"cohort\": #> integer(0) #>  #> Slot \"nObs\": #> [1] 0 #>"},{"path":"https://openpharma.github.io/crmPack/reference/DataDual-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataDual — DataDual-class","title":"DataDual — DataDual-class","text":"DataDual class dual endpoint data. inherits Data contains additional biomarker information.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataDual-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataDual — DataDual-class","text":"","code":"DataDual(w = numeric(), ...)  .DefaultDataDual()"},{"path":"https://openpharma.github.io/crmPack/reference/DataDual-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataDual — DataDual-class","text":"w (numeric) continuous vector biomarker values. ... parameters passed Data().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataDual-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataDual — DataDual-class","text":"w (numeric) continuous vector biomarker values.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataDual-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataDual — DataDual-class","text":"Typically, end users use .DefaultDataDual() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataDual-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataDual — DataDual-class","text":"","code":"my_data <- DataDual(   w = rnorm(8),   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ) ) #> Used default patient IDs! #> Used best guess cohort indices! my_data #> An object of class \"DataDual\" #> Slot \"w\": #> [1]  2.06502490 -1.63098940  0.51242695 -1.86301149 -0.52201251 -0.05260191 #> [7]  0.54299634 -0.91407483 #>  #> Slot \"x\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 #>  #> Slot \"y\": #> [1] 0 0 0 0 0 0 1 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 5 6 7 8 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 5 6 6 6 #>  #> Slot \"nObs\": #> [1] 8 #>"},{"path":"https://openpharma.github.io/crmPack/reference/DataGrouped-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataGrouped — DataGrouped-class","title":"DataGrouped — DataGrouped-class","text":"DataGrouped class two groups dose escalation data set, comprised monotherapy (mono) combination therapy (combo) arm. inherits Data contains additional group information.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataGrouped-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataGrouped — DataGrouped-class","text":"","code":"DataGrouped(group = character(), ...)  .DefaultDataGrouped()"},{"path":"https://openpharma.github.io/crmPack/reference/DataGrouped-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataGrouped — DataGrouped-class","text":"group (factor character) whether mono combo used. character coerced factor correct levels internally. ... parameters passed Data().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataGrouped-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataGrouped — DataGrouped-class","text":"group (factor) whether mono combo used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataGrouped-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataGrouped — DataGrouped-class","text":"Typically, end users use .DefaultDataGrouped() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataGrouped-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataGrouped — DataGrouped-class","text":"","code":"my_data <- DataGrouped(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   group = c(\"mono\", \"mono\", \"mono\", \"mono\", \"mono\", \"mono\", \"combo\", \"combo\") ) #> Used default patient IDs! #> Used best guess cohort indices!  # Set up an empty data set. empty_data <- DataGrouped(   doseGrid = c(0.1, 0.5, 1, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) empty_data #> An object of class \"DataGrouped\" #> Slot \"group\": #> factor() #> Levels: mono combo #>  #> Slot \"x\": #> numeric(0) #>  #> Slot \"y\": #> integer(0) #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.0  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 #> [16] 28.0 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 #> [31] 58.0 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 42 #>  #> Slot \"xLevel\": #> integer(0) #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> integer(0) #>  #> Slot \"cohort\": #> integer(0) #>  #> Slot \"nObs\": #> [1] 0 #>"},{"path":"https://openpharma.github.io/crmPack/reference/DataMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataMixture — DataMixture-class","title":"DataMixture — DataMixture-class","text":"DataMixture class data mixture sharing. inherits Data contains additional information mixture sharing.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataMixture — DataMixture-class","text":"","code":"DataMixture(xshare = numeric(), yshare = integer(), ...)  .DefaultDataMixture()"},{"path":"https://openpharma.github.io/crmPack/reference/DataMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataMixture — DataMixture-class","text":"xshare (numeric) doses share patients. yshare (integer) vector toxicity events (0 1) share patients. can also supply numeric vectors, converted integer internally. ... parameters passed Data().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataMixture — DataMixture-class","text":"xshare (numeric) doses share patients. yshare (integer) vector toxicity events (0 1) share patients. nObsshare (count) number share patients.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataMixture-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataMixture — DataMixture-class","text":"Typically, end users use .DefaultDataMixture() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataMixture — DataMixture-class","text":"","code":"my_data <- DataMixture(   xshare = c(12, 14, 16, 18.0),   yshare = c(0L, 1L, 1L, 1L),   nObsshare = 4L,   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) my_data #> An object of class \"DataMixture\" #> Slot \"xshare\": #> [1] 12 14 16 18 #>  #> Slot \"yshare\": #> [1] 0 1 1 1 #>  #> Slot \"nObsshare\": #> [1] 4 #>  #> Slot \"x\": #> [1] 0.1 0.5 1.5 #>  #> Slot \"y\": #> [1] 0 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 #>  #> Slot \"cohort\": #> [1] 1 2 3 #>  #> Slot \"nObs\": #> [1] 3 #>"},{"path":"https://openpharma.github.io/crmPack/reference/DataOrdinal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataOrdinal — DataOrdinal-class","title":"DataOrdinal — DataOrdinal-class","text":"DataOrdinal class ordinal toxicity data. inherits GeneralData describes toxicity responses ordinal rather binary scale.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataOrdinal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataOrdinal — DataOrdinal-class","text":"","code":"DataOrdinal(   x = numeric(),   y = integer(),   ID = integer(),   cohort = integer(),   doseGrid = numeric(),   placebo = FALSE,   yCategories = c(`No DLT` = 0L, DLT = 1L),   ... )  .DefaultDataOrdinal()"},{"path":"https://openpharma.github.io/crmPack/reference/DataOrdinal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataOrdinal — DataOrdinal-class","text":"x (numeric) doses patients. y (integer) vector toxicity events (0 1). can also supply numeric vectors, converted integer internally. ID (integer) unique patient IDs. can also supply numeric vectors, converted integer internally. cohort (integer) cohort (non-negative sorted) indices. can also supply numeric vectors, converted integer internally. doseGrid (numeric) possible doses. placebo (flag) TRUE first dose level doseGrid considered placebo. yCategories (named integer) names codes toxicity categories used data.  Category labels taken names vector.  names vector must unique values must sorted take values 0, 1, 2, ... ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataOrdinal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DataOrdinal — DataOrdinal-class","text":"cohort can missing placebo equal FALSE.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataOrdinal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataOrdinal — DataOrdinal-class","text":"class implemented sibling existing Data class (rather parent child) minimise risk unintended side effects existing classes methods. default setting yCategories slot replicates behaviour existing Data class. Typically, end users use .DefaultDataOrdinal() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataOrdinal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataOrdinal — DataOrdinal-class","text":"","code":"DataOrdinal(   x = c(10, 20, 30, 40, 50, 50, 50, 60, 60, 60),   y = as.integer(c(0, 0, 0, 0, 0, 1, 0, 0, 1, 2)),   ID = 1L:10L,   cohort = as.integer(c(1:4, 5, 5, 5, 6, 6, 6)),   doseGrid = c(seq(from = 10, to = 100, by = 10)),   yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L),   placebo = FALSE ) #> An object of class \"DataOrdinal\" #> Slot \"x\": #>  [1] 10 20 30 40 50 50 50 60 60 60 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 1 0 0 1 2 #>  #> Slot \"doseGrid\": #>  [1]  10  20  30  40  50  60  70  80  90 100 #>  #> Slot \"nGrid\": #> [1] 10 #>  #> Slot \"xLevel\": #>  [1] 1 2 3 4 5 5 5 6 6 6 #>  #> Slot \"yCategories\": #>     No tox Sub-tox AE        DLT  #>          0          1          2  #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 5 5 6 6 6 #>  #> Slot \"nObs\": #> [1] 10 #>"},{"path":"https://openpharma.github.io/crmPack/reference/DataParts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DataParts — DataParts-class","title":"DataParts — DataParts-class","text":"DataParts class data two study parts. inherits Data contains additional information two study parts.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataParts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DataParts — DataParts-class","text":"","code":"DataParts(part = integer(), nextPart = 1L, part1Ladder = numeric(), ...)  .DefaultDataParts()"},{"path":"https://openpharma.github.io/crmPack/reference/DataParts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DataParts — DataParts-class","text":"part (integer) part patients belong ? nextPart (count) part next cohort (1 2)? part1Ladder (numeric) escalation ladder part 1? shall ordered subset doseGrid. ... parameters passed Data().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataParts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DataParts — DataParts-class","text":"part (integer) part patients belong ? nextPart (count) part next cohort (1 2)? part1Ladder (numeric) escalation ladder part 1? shall ordered subset doseGrid.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataParts-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DataParts — DataParts-class","text":"Typically, end users use .DefaultDataParts() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DataParts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DataParts — DataParts-class","text":"","code":"my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) ) my_data #> An object of class \"DataParts\" #> Slot \"part\": #> [1] 1 1 1 #>  #> Slot \"nextPart\": #> [1] 1 #>  #> Slot \"part1Ladder\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 #>  #> Slot \"x\": #> [1] 0.1 0.5 1.5 #>  #> Slot \"y\": #> [1] 0 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 #>  #> Slot \"cohort\": #> [1] 1 2 3 #>  #> Slot \"nObs\": #> [1] 3 #>"},{"path":"https://openpharma.github.io/crmPack/reference/Design-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Design — Design-class","title":"Design — Design-class","text":"Design class rule-based designs. difference class parent RuleDesign class Design class contains additional model, stopping increments slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Design-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Design — Design-class","text":"","code":"Design(model, stopping, increments, pl_cohort_size = CohortSizeConst(0L), ...)  .DefaultDesign()"},{"path":"https://openpharma.github.io/crmPack/reference/Design-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design — Design-class","text":"model (GeneralModel) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition. ... Arguments passed RuleDesign nextBest (NextBest) see slot definition. cohort_size (CohortSize) see slot definition. data (Data) see slot definition. startingDose (number) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Design-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Design — Design-class","text":"model (GeneralModel) model used. stopping (Stopping) stopping rule(s) trial. increments (Increments) control increments dose levels. pl_cohort_size (CohortSize) rules cohort sizes placebo, planned (defaults constant 0 placebo patients).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Design-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Design — Design-class","text":"Typically, end users use .DefaultDesign() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Design-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Design — Design-class","text":"","code":"empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping1 & my_stopping2) | my_stopping3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = empty_data,   startingDose = 3 )"},{"path":"https://openpharma.github.io/crmPack/reference/DesignGrouped-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DesignGrouped — DesignGrouped-class","title":"DesignGrouped — DesignGrouped-class","text":"DesignGrouped combines two Design objects: one mono one combo arm joint dose escalation design.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DesignGrouped-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DesignGrouped — DesignGrouped-class","text":"","code":"DesignGrouped(   model,   mono,   combo = mono,   first_cohort_mono_only = TRUE,   same_dose_for_all = !same_dose_for_start,   same_dose_for_start = FALSE,   stop_mono_with_combo = FALSE,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/DesignGrouped-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DesignGrouped — DesignGrouped-class","text":"model (LogisticLogNormalGrouped) see slot definition. mono (Design) see slot definition. combo (Design) see slot definition. first_cohort_mono_only (flag) see slot definition. same_dose_for_all (flag) see slot definition. same_dose_for_start (flag) see slot definition. stop_mono_with_combo (flag) whether mono arm stopped combo arm stopped (makes sense real trial objective recommended combo dose). ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DesignGrouped-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DesignGrouped — DesignGrouped-class","text":"Note model slots inside mono combo parameters ignored (fit separate regression models mono combo arms). Instead, model parameter used fit joint regression model mono combo arms together. same_dose_for_start = TRUE useful option want use same_dose_for_all = FALSE combined first_cohort_mono_only = TRUE. allow randomize patients mono combo arms dose long selected dose cohorts stay . can therefore mitigate bias long possible mono combo arms.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DesignGrouped-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DesignGrouped — DesignGrouped-class","text":"model (LogisticLogNormalGrouped) model used, currently one class allowed. mono (Design) defines dose escalation rules mono arm, see details. combo (Design) defines dose escalation rules combo arm, see details. first_cohort_mono_only (flag) whether first test one mono agent cohort, DLT data collected, proceed second cohort onwards concurrent mono combo cohorts. same_dose_for_all (flag) whether lower dose separately determined mono combo doses used next dose mono combo cohorts. same_dose_for_start (flag) indicates whether, mono combo used cohort first time, dose used . Note different same_dose_for_all always force . same_dose_for_all = TRUE, therefore ignored. See Details.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DesignGrouped-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DesignGrouped — DesignGrouped-class","text":"Typically, end-users use .DefaultDesignGrouped() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DesignGrouped-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DesignGrouped — DesignGrouped-class","text":"","code":"empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the joint model. my_model <- LogisticLogNormalGrouped(   mean = c(-0.85, 0, 1, 0),   cov = diag(1, 4),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping1 & my_stopping2) | my_stopping3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Rules to be used for both arms. one_arm <- Design(   model = .DefaultModelLogNormal(), # Ignored.   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = empty_data,   startingDose = 3 )  # Initialize the design. design <- DesignGrouped(   model = my_model,   mono = one_arm )  # Alternative options: Here e.g. # - use both mono in first cohort and afterwards have mono and combo in parallel, # - in general allow different dose levels for the cohorts, # - but for the start (i.e. second cohort) have the same dose for mono and combo. # - Stop mono arm too, when combo arm is stopped.  design2 <- DesignGrouped(   model = my_model,   mono = one_arm,   first_cohort_mono_only = TRUE,   same_dose_for_all = FALSE,   same_dose_for_start = TRUE,   stop_mono_with_combo = TRUE )"},{"path":"https://openpharma.github.io/crmPack/reference/DesignOrdinal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DesignOrdinal — DesignOrdinal-class","title":"DesignOrdinal — DesignOrdinal-class","text":"DesignOrdinal class rule-based ordinal designs. difference class parent RuleDesignOrdinal class DesignOrdinal class contains additional model, stopping, increments pl_cohort_size slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DesignOrdinal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DesignOrdinal — DesignOrdinal-class","text":"","code":"DesignOrdinal(   model,   stopping,   increments,   pl_cohort_size = CohortSizeOrdinal(1L, CohortSizeConst(0L)),   ... )  .DefaultDesignOrdinal()"},{"path":"https://openpharma.github.io/crmPack/reference/DesignOrdinal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DesignOrdinal — DesignOrdinal-class","text":"model (LogisticLogNormalOrdinal) see slot definition. stopping (StoppingOrdinal) see slot definition. increments (IncrementsOrdinal) see slot definition. pl_cohort_size (CohortSizeOrdinal) see slot definition. ... Arguments passed RuleDesignOrdinal next_best (NextBestOrdinal) see slot definition. cohort_size (CohortSizeOrdinal) see slot definition. data (DataOrdinal) see slot definition. starting_dose (number) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DesignOrdinal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DesignOrdinal — DesignOrdinal-class","text":"model (LogisticLogNormalOrdinal) model used. stopping (StoppingOrdinal) stopping rule(s) trial. increments (IncrementsOrdinal) control increments dose levels. pl_cohort_size (CohortSizeOrdinal) rules cohort sizes placebo, planned (defaults constant 0 placebo patients).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DesignOrdinal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DesignOrdinal — DesignOrdinal-class","text":"Typically, end users use .DefaultDesignOrdinal() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DesignOrdinal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DesignOrdinal — DesignOrdinal-class","text":"","code":"my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- CohortSizeOrdinal(1L, maxSize(my_size1, my_size2))  my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping3 <- StoppingMinPatients(nPatients = 20) my_stopping <- StoppingOrdinal(1L, (my_stopping1 & my_stopping2) | my_stopping3)  # Initialize the design. design <- DesignOrdinal(   model = LogisticLogNormalOrdinal(     mean = c(-3, -4, 1),     cov = diag(c(3, 4, 1)),     ref_dose = 50   ),   next_best = NextBestOrdinal(     1L,     NextBestNCRM(       target = c(0.2, 0.35),       overdose = c(0.35, 1),       max_overdose_prob = 0.25     )   ),   stopping = my_stopping,   increments = IncrementsOrdinal(     1L,     IncrementsRelative(       intervals = c(0, 20),       increments = c(1, 0.33)     )   ),   cohort_size = my_size,   data = DataOrdinal(     doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100),     yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L)   ),   starting_dose = 3 )"},{"path":"https://openpharma.github.io/crmPack/reference/DualDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualDesign — DualDesign-class","title":"DualDesign — DualDesign-class","text":"DualDesign class dual-endpoint CRM design. class special requirements model data slots comparison parent class Design.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualDesign — DualDesign-class","text":"","code":"DualDesign(model, data, ...)  .DefaultDualDesign()"},{"path":"https://openpharma.github.io/crmPack/reference/DualDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualDesign — DualDesign-class","text":"model (DualEndpoint) see slot definition. data (DataDual) see slot definition. ... Arguments passed Design stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualDesign — DualDesign-class","text":"model (DualEndpoint) model used. data (DataDual) specifies dose grid, previous data, etc.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualDesign — DualDesign-class","text":"nextBest slot can class, allows easy comparison recommendation methods use biomarker information. Typically, end users use .DefaultDualDesign() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualDesign — DualDesign-class","text":"","code":"empty_data <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) my_stopping <- my_stopping1 | StoppingMinPatients(40)  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- DualDesign(   model = my_model,   data = empty_data,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   startingDose = 3 )"},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpoint-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpoint — DualEndpoint-class","title":"DualEndpoint — DualEndpoint-class","text":"DualEndpoint general class dual endpoint model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpoint-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpoint — DualEndpoint-class","text":"","code":"DualEndpoint(mean, cov, ref_dose = 1, use_log_dose = FALSE, sigma2W, rho)  .DefaultDualEndpoint()"},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpoint-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpoint — DualEndpoint-class","text":"mean (numeric) probit toxicity model, prior mean vector. cov (matrix) probit toxicity model, prior covariance matrix. precision matrix internally calculated inverse cov. ref_dose (number) probit toxicity model, reference dose \\(x*\\) (strictly positive number). use_log_dose (flag) probit toxicity model, whether log transformation (standardized) dose used? sigma2W (numeric) biomarker variance. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rho (numeric) either fixed value correlation (-1 1), named vector two elements named b Beta prior transformation kappa = (rho + 1) / 2, (0, 1). example, = 1, b = 1 leads uniform prior rho.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpoint-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpoint — DualEndpoint-class","text":"idea dual-endpoint models model dose-toxicity relationship, also model, time, relationship PD biomarker dose. sub-classes class define dose-biomarker relationship parametrized. class shall contain common features reduce duplicate code. (class however, must virtual need create objects construction subclass objects.) dose-toxicity relationship modeled probit regression model $$probit[p(x)] = betaZ1 + betaZ2 * x/x*,$$ $$probit[p(x)] = betaZ1 + betaZ2 * log(x/x*),$$ case option use_log_dose TRUE. , \\(p(x)\\) probability observing DLT given dose \\(x\\) \\(x*\\) reference dose. prior $$(betaZ1, log(betaZ2)) ~ Normal(mean, cov).$$ biomarker response \\(w\\) dose \\(x\\), assume $$w(x) ~ Normal(f(x), sigma2W),$$ \\(f(x)\\) function dose \\(x\\), specified sub-classes. biomarker variance \\(sigma2W\\) can fixed assigned Inverse-Gamma prior distribution; see details slot sigma2W. Finally, two endpoints \\(y\\) (binary DLT variable) \\(w\\) (biomarker) can correlated, assuming correlation level \\(rho\\) underlying continuous latent toxicity variable \\(z\\) biomarker \\(w\\). , correlation can fixed assigned prior distribution scaled Beta family; see details slot rho. Please see example vignette typing crmPackExample() full example.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpoint-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpoint — DualEndpoint-class","text":"betaZ_params (ModelParamsNormal) probit toxicity model, contains prior mean, covariance matrix precision matrix internally calculated inverse covariance matrix. ref_dose (positive_number) probit toxicity model, reference dose. use_log_dose (flag) probit toxicity model, whether log transformation (standardized) dose used? sigma2W (numeric) biomarker variance. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rho (numeric) either fixed value correlation (-1 1), named vector two elements named b Beta prior transformation kappa = (rho + 1) / 2, (0, 1). example, = 1, b = 1 leads uniform prior rho. use_fixed (logical) indicates whether fixed value sigma2W rho (parameter separately) used . slot needed internal purposes must touched user.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpoint-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualEndpoint — DualEndpoint-class","text":"Typically, end users use .DefaultDualEndpoint() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpointBeta — DualEndpointBeta-class","title":"DualEndpointBeta — DualEndpointBeta-class","text":"DualEndpointBeta class dual endpoint model beta function dose-biomarker relationship.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpointBeta — DualEndpointBeta-class","text":"","code":"DualEndpointBeta(E0, Emax, delta1, mode, ref_dose_beta = 1, ...)  .DefaultDualEndpointBeta()"},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpointBeta — DualEndpointBeta-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. delta1 (numeric) either fixed positive number two parameters uniform distribution, can take positive values. mode (numeric) either fixed positive number two parameters uniform distribution, can take positive values. ref_dose_beta (number) reference dose \\(x*\\) (strictly positive number). Note different ref_dose inherited DualEndpoint model). ... parameters passed DualEndpoint().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpointBeta — DualEndpointBeta-class","text":"class extends DualEndpoint class dose-biomarker relationship \\(f(x)\\) modelled parametric, rescaled beta density function: $$f(x) = E0 + (Emax - E0) * Beta(delta1, delta2) * (x/x*)^{delta1} * (1 - x/x*)^{delta2},$$ \\(x*\\) maximum dose (end dose range considered), \\(delta1\\) \\(delta2\\) two beta function parameters, \\(E0\\), \\(Emax\\) minimum maximum levels, respectively. ease interpretation, use parametrization based \\(delta1\\) mode, $$mode = delta1 / (delta1 + delta2),$$ multiplying \\(x*\\) gives mode dose grid. parameters can currently assigned uniform distributions fixed advance. Note E0 Emax can negative values uniform distributions reaching negative range, delta1 mode must positive uniform distributions positive range.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpointBeta — DualEndpointBeta-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. delta1 (numeric) either fixed positive number two parameters uniform distribution, can take positive values. mode (numeric) either fixed positive number two parameters uniform distribution, can take positive values. ref_dose_beta (positive_number) reference dose \\(x*\\) (note different ref_dose inherited DualEndpoint model).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualEndpointBeta — DualEndpointBeta-class","text":"Typically, end users use .DefaultDualEndpointBeta() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualEndpointBeta — DualEndpointBeta-class","text":"","code":"my_model <- DualEndpointBeta(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   ref_dose = 10,   use_log_dose = TRUE,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   E0 = c(0, 100),   Emax = c(0, 500),   delta1 = c(0, 5),   mode = c(1, 15),   ref_dose_beta = 1000 )"},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointEmax-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpointEmax — DualEndpointEmax-class","title":"DualEndpointEmax — DualEndpointEmax-class","text":"DualEndpointEmax class dual endpoint model Emax function dose-biomarker relationship.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpointEmax — DualEndpointEmax-class","text":"","code":"DualEndpointEmax(E0, Emax, ED50, ref_dose_emax = 1, ...)  .DefaultDualEndpointEmax()"},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpointEmax — DualEndpointEmax-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. ED50 (numeric) either fixed number two uniform distribution parameters. ref_dose_emax (number) reference dose \\(x*\\) (strictly positive number). Note different ref_dose inherited DualEndpoint model). ... parameters passed DualEndpoint().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpointEmax — DualEndpointEmax-class","text":"class extends DualEndpoint class dose-biomarker relationship \\(f(x)\\) modelled parametric Emax function: $$f(x) = E0 + [(Emax - E0) * (x/x*)]/[ED50 + (x/x*)],$$ \\(x*\\) reference dose, \\(E0\\) \\(Emax\\) minimum maximum levels biomarker, \\(ED50\\) dose achieving half maximum effect \\(0.5 * Emax\\). parameters can currently assigned uniform distributions fixed.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpointEmax — DualEndpointEmax-class","text":"E0 (numeric) either fixed number two uniform distribution parameters. Emax (numeric) either fixed number two uniform distribution parameters. ED50 (numeric) either fixed number two uniform distribution parameters. ref_dose_emax (positive_number) reference dose \\(x*\\) (note different ref_dose inherited DualEndpoint model).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualEndpointEmax — DualEndpointEmax-class","text":"Typically, end users use .DefaultDualEndpointEmax() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointEmax-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualEndpointEmax — DualEndpointEmax-class","text":"","code":"my_model <- DualEndpointEmax(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   E0 = c(0, 100),   Emax = c(0, 500),   ED50 = c(10, 200),   ref_dose_emax = 1000 )"},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointRW-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualEndpointRW — DualEndpointRW-class","title":"DualEndpointRW — DualEndpointRW-class","text":"DualEndpointRW class dual endpoint model random walk prior biomarker.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointRW-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualEndpointRW — DualEndpointRW-class","text":"","code":"DualEndpointRW(sigma2betaW, rw1 = TRUE, ...)  .DefaultDualEndpointRW()"},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointRW-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualEndpointRW — DualEndpointRW-class","text":"sigma2betaW (numeric) prior variance factor random walk prior biomarker model. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rw1 (flag) specifying random walk prior biomarker level. TRUE, random walk first order used. Otherwise, random walk second order used. ... parameters passed DualEndpoint().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointRW-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"DualEndpointRW — DualEndpointRW-class","text":"class extends DualEndpoint class dose-biomarker relationship \\(f(x)\\) modelled non-parametric random walk first second order. means, first order random walk assume $$betaW_i - betaW_i-1 ~ Normal(0, (x_i - x_i-1) * sigma2betaW),$$ \\(betaW_i = f(x_i)\\) biomarker mean \\(\\)-th dose gridpoint \\(x_i\\). second order random walk, second-order differences instead first-order differences biomarker means follow normal distribution \\(0\\) mean \\(2 * (x_i - x_i-2) * sigma2betaW\\) variance. variance parameter \\(sigma2betaW\\) important steers smoothness function \\(f(x)\\), .e.: large, \\(f(x)\\) wiggly; small, \\(f(x)\\) smooth. parameter can either fixed value assigned inverse gamma prior distribution.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointRW-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualEndpointRW — DualEndpointRW-class","text":"sigma2betaW (numeric) prior variance factor random walk prior biomarker model. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. rw1 (flag) specifying random walk prior biomarker level. TRUE, random walk first order used. Otherwise, random walk second order used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointRW-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualEndpointRW — DualEndpointRW-class","text":"Non-equidistant dose grids can used now, difference \\(x_i - x_i-1\\) included modelling assumption . Please note due impropriety random walk prior distributions, possible produce MCMC samples empty data objects (.e., sample prior). bug, theoretical feature model. Typically, end users use .DefaultDualEndpointRW() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/DualEndpointRW-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualEndpointRW — DualEndpointRW-class","text":"","code":"my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   sigma2betaW = 0.01,   rw1 = TRUE )"},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualResponsesDesign.R — DualResponsesDesign-class","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"class design based DLE responses using LogisticIndepBeta model without DLE efficacy samples. contains slots RuleDesign TDsamplesDesign classes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"","code":"DualResponsesDesign(eff_model, data, ...)  .DefaultDualResponsesDesign()"},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"eff_model (ModelEff) see slot definition. data (DataDual) see slot definition. ... Arguments passed TDDesign model (ModelTox) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"data (DataDual) data set. eff_model (ModelEff) pseudo efficacy model used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"Typically, end users use .DefaultDualResponsesDesign() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualResponsesDesign.R — DualResponsesDesign-class","text":"","code":"empty_data <- DataDual(doseGrid = seq(25, 300, 25))  tox_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data )  eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = empty_data )  my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  my_increments <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) )  my_size <- CohortSizeConst(size = 3) my_stopping <- StoppingMinPatients(nPatients = 36)  design <- DualResponsesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = tox_model,   eff_model = eff_model,   data = empty_data,   stopping = my_stopping,   increments = my_increments )"},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"class design based DLE responses using LogisticIndepBeta model DLE efficacy samples. contain slots RuleDesign TDsamplesDesign class objects.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"","code":"DualResponsesSamplesDesign(eff_model, data, ...)  .DefaultDualResponsesSamplesDesign()"},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"eff_model (ModelEff) see slot definition. data (DataDual) see slot definition. ... Arguments passed TDsamplesDesign model (ModelTox) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"data (DataDual) data set. eff_model (ModelEff) pseudo efficacy model used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"Typically, end users use .DefaultDualResponsesSamplesDesign() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualResponsesSamplesDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualResponsesSamplesDesign — DualResponsesSamplesDesign-class","text":"","code":"empty_data <- DataDual(doseGrid = seq(25, 300, 25))  tox_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data ) options <- McmcOptions(burnin = 100, step = 2, samples = 200) tox_samples <- mcmc(empty_data, tox_model, options)  eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = empty_data ) eff_samples <- mcmc(empty_data, eff_model, options)  my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  my_increments <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) ) my_size <- CohortSizeConst(size = 3) my_stopping <- StoppingMinPatients(nPatients = 36)  design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = tox_model,   eff_model = eff_model,   data = empty_data,   stopping = my_stopping,   increments = my_increments )"},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualSimulations — DualSimulations-class","title":"DualSimulations — DualSimulations-class","text":"class captures trial simulations dual-endpoint model based designs. comparison parent class Simulations, contains additional slots capture dose-biomarker fits, sigma2W rho estimates.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualSimulations — DualSimulations-class","text":"","code":"DualSimulations(rho_est, sigma2w_est, fit_biomarker, ...)  .DefaultDualSimulations()"},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulations-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DualSimulations — DualSimulations-class","text":"rho_est (numeric) see DualSimulations sigma2w_est (numeric)DualSimulations fit_biomarker (list) see DualSimulations ... additional parameters Simulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualSimulations — DualSimulations-class","text":"rho_est (numeric) vector final posterior median rho estimates sigma2w_est (numeric) vector final posterior median sigma2W estimates fit_biomarker (list) final dose-biomarker curve fits","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualSimulations — DualSimulations-class","text":"Typically, end users use .DefaultDualSimulations() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulations-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DualSimulations — DualSimulations-class","text":"","code":"data_list <- list(   Data(     x = 1:2,     y = 0:1,     doseGrid = 1:2,     ID = 1L:2L,     cohort = 1L:2L   ),   Data(     x = 3:4,     y = 0:1,     doseGrid = 3:4,     ID = 1L:2L,     cohort = 1L:2L   ) )  doses <- c(1, 2) seed <- as.integer(123)  fit <- list(   c(0.1, 0.2),   c(0.3, 0.4) )  stop_report <- matrix(c(TRUE, FALSE), nrow = 2)  stop_reasons <- list(\"A\", \"B\")  additional_stats <- list(a = 1, b = 1)  dual_simulations_obj <- DualSimulations(   rho_est = c(0.25, 0.35),   sigma2w_est = c(0.15, 0.25),   fit_biomarker = list(c(0.3, 0.4), c(0.4, 0.5)),   fit = fit,   stop_report = stop_report,   stop_reasons = stop_reasons,   additional_stats = additional_stats,   data = data_list,   doses = doses,   seed = seed )"},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"DualSimulationsSummary — DualSimulationsSummary-class","title":"DualSimulationsSummary — DualSimulationsSummary-class","text":"class captures summary dual-endpoint simulations output. comparison parent class SimulationsSummary, additional slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulationsSummary-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DualSimulationsSummary — DualSimulationsSummary-class","text":"","code":".DefaultDualSimulationsSummary()"},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"DualSimulationsSummary — DualSimulationsSummary-class","text":"biomarker_fit_at_dose_most_selected (numeric) fitted biomarker level often selected dose. mean_biomarker_fit (list) list average, lower (2.5%) upper (97.5%) quantiles mean fitted biomarker level dose","code":""},{"path":"https://openpharma.github.io/crmPack/reference/DualSimulationsSummary-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"DualSimulationsSummary — DualSimulationsSummary-class","text":"Typically, end users use .DefaultDualSimulationsSummary() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/EffFlexi-class.html","id":null,"dir":"Reference","previous_headings":"","what":"EffFlexi — EffFlexi-class","title":"EffFlexi — EffFlexi-class","text":"EffFlexi class efficacy model flexible form prior expressed form pseudo data. class, flexible form used describe relationship efficacy responses dose levels specified $$(W | betaW, sigma2W) ~ Normal(X * betaW, sigma2W * ),$$ \\(W\\) vector efficacy responses, \\(betaW\\) column vector mean efficacy responses dose levels, \\(X\\) design matrix entries \\(I_i,j\\) equal 1 subject \\(\\) allocated dose \\(j\\), \\(0\\) otherwise. \\(sigma2W\\) variance efficacy responses can either fixed number number inverse gamma distribution. flexible form aims capture different shapes dose-efficacy curve. addition, first (RW1) second order (RW2) random walk model can used smoothing data. random walk model used model first second order differences mean efficacy responses neighboring dose levels mean efficacy responses. RW1 model given $$betaW_j - betaW_j-1) ~ Normal(0, sigma2betaW),$$ RW2 $$betaW_j-2 - 2 * betaW_j-1 + beta_j ~ Normal(0, sigma2betaW),$$ \\(betaW_j\\) vector mean efficacy responses dose j, \\(sigma2betaW\\) prior variance can either fixed number number inverse gamma distribution. eff eff_dose pseudo efficacy responses dose levels pseudo efficacy responses observed. , eff eff_dose must vectors length least 2. positions elements specified eff eff_dose must correspond vectors.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/EffFlexi-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EffFlexi — EffFlexi-class","text":"","code":"EffFlexi(eff, eff_dose, sigma2W, sigma2betaW, rw1 = TRUE, data)  .DefaultEffFlexi()"},{"path":"https://openpharma.github.io/crmPack/reference/EffFlexi-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EffFlexi — EffFlexi-class","text":"eff (numeric) pseudo efficacy responses. Elements eff must correspond elements eff_dose. eff_dose (numeric) dose levels correspond pseudo efficacy responses eff. sigma2W (numeric) prior variance efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters inverse gamma distribution. sigma2betaW (numeric) prior variance random walk model used smoothing. either fixed value named vector two positive numbers, shape (), rate (b) parameters inverse gamma distribution. rw1 (flag) used smoothing data efficacy model. TRUE, first-order random walk model used mean efficacy responses. Otherwise, random walk second order used. data (DataDual) observed data update estimates model parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/EffFlexi-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"EffFlexi — EffFlexi-class","text":"model output updated value updated values parameters inverse gamma distributions \\(sigma2W\\) \\(sigma2betaW\\). EffFlexi inherits slots ModelEff class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/EffFlexi-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"EffFlexi — EffFlexi-class","text":"eff (numeric) pseudo efficacy responses. element must represent responses treated based one subject. must vector length least 2 order elements must correspond values specified eff_dose. eff_dose (numeric) pseudo efficacy dose levels pseudo efficacy responses observed. must vector length least 2 order elements must correspond values specified eff. sigma2W (numeric) prior variance flexible efficacy form. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. sigma2betaW (numeric) prior variance random walk model mean efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. use_fixed (logical) indicates whether fixed value sigma2W sigma2betaW (parameter separately) used . slot needed internal purposes must touched user. rw1 (flag) used smoothing data efficacy model. TRUE, first-order random walk model used mean efficacy responses. Otherwise, random walk second order used. X (matrix) design matrix efficacy responses. based pseudo observed efficacy responses. RW (matrix) difference matrix random walk model. slot needed internal purposes must used user. RW_rank (integer) rank difference matrix. slot needed internal purposes must used user.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/EffFlexi-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"EffFlexi — EffFlexi-class","text":"Typically, end users use .DefaultEffFlexi() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/EffFlexi-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"EffFlexi — EffFlexi-class","text":"","code":"# Obtain prior estimates for the efficacy model in flexible form, given the pseudo data. # First define an empty data set by defining the dose levels used in the study. # There are 12 dose levels used in the study, ranging from 25 to 300 mg with # increments of 25. emptydata <- DataDual(doseGrid = seq(25, 300, 25))  # Define the pseudo data, i.e.: fixed 2 dose levels 25 and 300 mg (`eff_dose`) # and the efficacy responses 1.223 and 2.513 observed at these two dose levels (`eff`). # The prior variance of the pseudo efficacy responses can be either a fixed value # or two parameters for the inverse gamma distribution, the shape (a) and the # rate (b) (`sigma2W`). # The prior variance of the random walk model can be either a fixed value or two # parameters for the inverse gamma distribution, the shape (a) and the rate (b) # (`sigma2betaW`). my_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  # Obtain estimates from the model given some observed data is available. data <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = emptydata@doseGrid ) #> Used default patient IDs! #> Used best guess cohort indices!  my_model1 <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = data )"},{"path":"https://openpharma.github.io/crmPack/reference/Effloglog-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Effloglog — Effloglog-class","title":"Effloglog — Effloglog-class","text":"Effloglog class linear log-log efficacy model using pseudo data prior. describes relationship continuous efficacy responses corresponding dose levels log-log scale. efficacy log-log model given $$y_i = theta1 + theta2 * log(log(x_i)) + epsilon_i,$$ \\(y_i\\) efficacy response subject \\(\\), \\(x_i\\) dose level treated subject \\(\\) \\(epsilon_i\\) random error term efficacy model subject \\(\\). error term \\(epsilon_i\\) random variable follows normal distribution mean \\(0\\) variance \\(nu^{-1}\\), assumed subjects. three parameters model, intercept \\(theta1\\), slope \\(theta2\\) precision \\(nu\\) efficacy responses, also known inverse variance pseudo efficacy responses. can fixed constant gamma distribution. Therefore, single scalar value vector two positive numbers values must specified nu slot. observed efficacy responses available, output, nu display updated value precision updated values parameters gamma distribution. Effloglog inherits slots ModelEff class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Effloglog-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effloglog — Effloglog-class","text":"","code":"Effloglog(eff, eff_dose, nu, data, const = 0)  .DefaultEffloglog()"},{"path":"https://openpharma.github.io/crmPack/reference/Effloglog-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Effloglog — Effloglog-class","text":"eff (numeric) pseudo efficacy responses. Elements eff must correspond elements eff_dose. eff_dose (numeric) dose levels correspond pseudo efficacy responses eff. nu (numeric) precision (inverse variance) efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. data (DataDual) observed data update estimates model parameters. const (number) constant value added dose level dose level value less equal 1 special form linear log-log applied (Yeung et al. (2015).).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Effloglog-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Effloglog — Effloglog-class","text":"prior model specified form pseudo data. First, least two dose levels fixed. , using e.g. experts' opinion, efficacy values correspond dose levels can obtained, eff eff_dose arguments represent prior form pseudo data. eff represents pseudo efficacy values. eff_dose represents dose levels pseudo efficacy values observed. Hence, positions elements specified eff eff_dose must correspond vectors. Since least 2 pseudo efficacy values needed obtain modal estimates intercept slope parameters, eff eff_dose must vectors length least 2. joint prior distribution intercept \\(theta1\\) slope \\(theta2\\) model follows bivariate normal distribution mean \\(mu\\) covariance matrix \\((nu * Q)^{-1}\\). mean \\(mu\\) \\(2 x 1\\) column vector contains prior modal estimates intercept slope. Scalar \\(nu\\) precision pseudo efficacy responses \\(Q\\) prior posterior (given observed, DLT data available) precision matrix. specified \\(Q = X0^T * X0 + X^T * X\\), \\(X0\\) design matrix based pseudo dose levels , \\(X\\) design matrix based dose levels corresponding DLT efficacy responses observed (). Hence, \\(X0\\) (\\(X\\)) size \\(r x 2\\), \\(r >= 2\\) pseudo efficacy responses specified (\\(r\\) DLT efficacy responses observed data).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Effloglog-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Effloglog — Effloglog-class","text":"eff (numeric) pseudo efficacy responses. element must represent responses treated based one subject. must vector length least 2 order elements must correspond values specified eff_dose. eff_dose (numeric) pseudo efficacy dose levels pseudo efficacy responses observed. must vector length least 2 order elements must correspond values specified eff. nu (numeric) parameter prior precision pseudo efficacy responses. either fixed value named vector two positive numbers, shape (), rate (b) parameters gamma distribution. use_fixed (flag) indicates whether nu specified fixed value vector two parameters gamma distribution. slot internal purposes must used user. theta1 (number) intercept efficacy log-log model. slot used output display resulting prior posterior modal estimates obtained based pseudo observed () data. theta2 (number) slope efficacy log-log model. slot used output display resulting prior posterior modal estimates obtained based pseudo observed () data. Pcov (matrix) refers \\(2 x 2\\) covariance matrix estimators intercept \\(theta1\\) slope \\(theta2\\) parameters model. used output display resulting prior posterior covariance matrix \\(theta1\\) \\(theta2\\) obtained, based pseudo observed () data. slot needed internal purposes. X (matrix) design matrix based either pseudo dose levels observed dose levels (without DLT). used output display design matrix pseudo observed efficacy responses. Y (numeric) vector either contains pseudo efficacy responses observed efficacy responses (without DLT). mu (numeric) vector prior posterior modal estimates intercept (\\(theta1\\)) slope (\\(theta2\\)). slot used output display mean prior posterior bivariate normal distribution \\(theta1\\) \\(theta2\\). Q (matrix) prior posterior (given observed, DLT data available) precision matrix. specified \\(Q = X0^T * X0 + X^T * X\\), \\(X0\\) design matrix based pseudo dose levels , \\(X\\) design matrix based dose levels corresponding observed, DLT efficacy values (). const (number) non-negative number (default 0), leading model form described . general, model form \\(y_i = theta1 + theta2 * log(log(x_i + const)) + epsilon_i\\), dose levels greater \\(1 - const\\) can considered described Yeung et al. (2015).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Effloglog-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Effloglog — Effloglog-class","text":"Typically, end users use .DefaultEffloglog() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Effloglog-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Effloglog — Effloglog-class","text":"","code":"# Obtain prior modal estimates given the pseudo data. # First we use an empty data set such that only the dose levels under # investigations are given. In total, 12 dose levels are under investigation # ranging from 25 to 300 mg with increments of 25 (i.e 25, 50, 75, ..., 300). emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  # Define the pseudo data as first by fixing two dose levels 25 and 300 mg (`eff_dose`). # Then, the efficacy responses observed at these two dose levels are 1.223 and 2.513 (`eff`). # We specify the prior precision of the pseudo efficacy responses (`nu`) as a vector # with the shape (a) and the rate (b) parameters for the gamma distribution. # Obtain modal estimates and other estimates from the model (no observations, # only pseudo data). my_model1 <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # Observed data. my_data <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = emptydata@doseGrid ) #> Used default patient IDs! #> Used best guess cohort indices!  # Obtain posterior modal estimates and other estimates from the model given some # observed data. my_model2 <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data )"},{"path":"https://openpharma.github.io/crmPack/reference/FractionalCRM-class.html","id":null,"dir":"Reference","previous_headings":"","what":"FractionalCRM — FractionalCRM-class","title":"FractionalCRM — FractionalCRM-class","text":"FractionalCRM class fractional CRM model based one parameter CRM (normal prior log-power parameter) well Kaplan-Meier based estimation conditional probability experience DLT non-complete observations. fractional CRM model follows paper code Guosheng Yin et al.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/FractionalCRM-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"FractionalCRM — FractionalCRM-class","text":"","code":"FractionalCRM(...)  .DefaultFractionalCRM()"},{"path":"https://openpharma.github.io/crmPack/reference/FractionalCRM-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"FractionalCRM — FractionalCRM-class","text":"... Arguments passed OneParLogNormalPrior skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. dose_grid (numeric) dose grid. must must sorted vector length skel_probs. sigma2 (number) prior variance log power parameter alpha.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/FractionalCRM-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"FractionalCRM — FractionalCRM-class","text":"Typically, end users use .DefaultTITELogisticLogNormal() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/FractionalCRM-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"FractionalCRM — FractionalCRM-class","text":"","code":"my_model <- FractionalCRM(   skel_probs = c(0.1, 0.2, 0.3, 0.4),   dose_grid = c(10, 30, 50, 100),   sigma2 = 2 )"},{"path":"https://openpharma.github.io/crmPack/reference/GeneralData-class.html","id":null,"dir":"Reference","previous_headings":"","what":"GeneralData — GeneralData-class","title":"GeneralData — GeneralData-class","text":"GeneralData class general data input.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralData-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GeneralData — GeneralData-class","text":"","code":".DefaultDataGeneral()"},{"path":"https://openpharma.github.io/crmPack/reference/GeneralData-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"GeneralData — GeneralData-class","text":"ID (integer) unique patient IDs. cohort (integer) cohort (non-negative sorted) indices. nObs (integer) number observations, single value.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralData-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"GeneralData — GeneralData-class","text":"Typically, end users use .DefaultDataGeneral() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralModel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"GeneralModel — GeneralModel-class","title":"GeneralModel — GeneralModel-class","text":"GeneralModel general model class, specific model-like classes inherit.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralModel-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GeneralModel — GeneralModel-class","text":"","code":".DefaultGeneralModel()"},{"path":"https://openpharma.github.io/crmPack/reference/GeneralModel-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"GeneralModel — GeneralModel-class","text":"datamodel (function) function representing JAGS data model specification. priormodel (function) function representing JAGS prior specification. modelspecs (function) function computing list data model prior model specifications required specified completely (e.g. prior parameters, reference dose, etc.), based data slots required arguments function. Apart data arguments, function can specified one additional (optional) argument from_prior type logical length one. from_prior flag can used differentiate output modelspecs, value taken directly from_prior argument mcmc method invokes modelspecs function. , from_prior TRUE, priormodel JAGS model used (datamodel used) mcmc, hence modelspecs function return parameters required priormodel . value from_prior FALSE, JAGS models datamodel priormodel used MCMC sampler, hence modelspecs function return parameters required datamodel priormodel. init (function) function computing list starting values parameters required initialized MCMC sampler, based data slots required arguments function. datanames (character) names data slots used datamodel JAGS function. names specified . datanames_prior (character) names data slots used priormodel JAGS function. names specified . sample (character) names parameters like save MCMC samples.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralModel-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"GeneralModel — GeneralModel-class","text":"datamodel must obey convention data input called exactly way corresponding data class. prior distributions parameters contained model function priormodel. background can used simulate prior distribution, obtaining data. Typically, end users use .DefaultGeneralModel() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"GeneralSimulations @description  This class captures trial simulations. Here also the random generator state before starting the simulation is saved, in order to be able to reproduce the outcome. For this just use set.seed with the seed as argument before running simulate,Design-method. — GeneralSimulations-class","title":"GeneralSimulations @description  This class captures trial simulations. Here also the random generator state before starting the simulation is saved, in order to be able to reproduce the outcome. For this just use set.seed with the seed as argument before running simulate,Design-method. — GeneralSimulations-class","text":"GeneralSimulations @description  class captures trial simulations. also random generator state starting simulation saved, order able reproduce outcome. just use set.seed seed argument running simulate,Design-method.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GeneralSimulations @description  This class captures trial simulations. Here also the random generator state before starting the simulation is saved, in order to be able to reproduce the outcome. For this just use set.seed with the seed as argument before running simulate,Design-method. — GeneralSimulations-class","text":"","code":"GeneralSimulations(data, doses, seed)  .DefaultGeneralSimulations()"},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulations-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GeneralSimulations @description  This class captures trial simulations. Here also the random generator state before starting the simulation is saved, in order to be able to reproduce the outcome. For this just use set.seed with the seed as argument before running simulate,Design-method. — GeneralSimulations-class","text":"data (list) see slot definition. doses (numeric) see slot definition. seed (integer) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"GeneralSimulations @description  This class captures trial simulations. Here also the random generator state before starting the simulation is saved, in order to be able to reproduce the outcome. For this just use set.seed with the seed as argument before running simulate,Design-method. — GeneralSimulations-class","text":"data (list) produced Data objects. doses (numeric) final dose recommendations. seed (integer) random generator state starting simulation.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"GeneralSimulations @description  This class captures trial simulations. Here also the random generator state before starting the simulation is saved, in order to be able to reproduce the outcome. For this just use set.seed with the seed as argument before running simulate,Design-method. — GeneralSimulations-class","text":"Typically, end users use .DefaultGeneralSimulations() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulations-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GeneralSimulations @description  This class captures trial simulations. Here also the random generator state before starting the simulation is saved, in order to be able to reproduce the outcome. For this just use set.seed with the seed as argument before running simulate,Design-method. — GeneralSimulations-class","text":"","code":"data <- list(   Data(x = 1:3, y = c(0, 1, 0), doseGrid = 1:3, ID = 1L:3L, cohort = 1L:3L),   Data(x = 4:6, y = c(0, 1, 0), doseGrid = 4:6, ID = 1L:3L, cohort = 1L:3L) )  doses <- c(1, 2)  seed <- 123L  simulations <- GeneralSimulations(data, doses, seed)"},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"GeneralSimulationsSummary — GeneralSimulationsSummary-class","title":"GeneralSimulationsSummary — GeneralSimulationsSummary-class","text":"class captures summary general simulations output. Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulationsSummary-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GeneralSimulationsSummary — GeneralSimulationsSummary-class","text":"","code":".DefaultGeneralSimulationsSummary()  .DefaultPseudoSimulationsSummary()"},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"GeneralSimulationsSummary — GeneralSimulationsSummary-class","text":"target (numeric) target toxicity interval target_dose_interval (numeric) corresponding target dose interval nsim (integer) number simulations prop_dlts () numeric array (multi-dimensional) list representing proportions DLTs trials mean_tox_risk (numeric) mean toxicity risks patients dose_selected (numeric) doses selected MTD tox_at_doses_selected (numeric) true toxicity doses selected prop_at_target (numeric) Proportion trials selecting target MTD dose_most_selected (numeric) dose often selected MTD obs_tox_rate_at_dose_most_selected (numeric) observed toxicity rate dose often selected n_obs () numeric array (multi-dimensional) list representing number patients overall. n_above_target (integer) number patients treated target tox interval dose_grid (numeric) dose grid used placebo (logical) set TRUE (default FALSE) design placebo","code":""},{"path":"https://openpharma.github.io/crmPack/reference/GeneralSimulationsSummary-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"GeneralSimulationsSummary — GeneralSimulationsSummary-class","text":"Typically, end users use .DefaultGeneralSimulationsSummary() function. Typically, end users use .DefaultPseudoSimulationsSummary() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Increments-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Increments — Increments-class","title":"Increments — Increments-class","text":"Increments virtual class controlling increments, specific increments classes inherit.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Increments-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Increments — Increments-class","text":"","code":".DefaultIncrements()"},{"path":"https://openpharma.github.io/crmPack/reference/Increments-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Increments — Increments-class","text":"Typically, end users use .DefaultIncrements() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsDoseLevels — IncrementsDoseLevels-class","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"IncrementsDoseLevels class increments control based number dose levels.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"","code":"IncrementsDoseLevels(levels = 1L, basis_level = \"last\")  .DefaultIncrementsDoseLevels()"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"levels (count) see slot definition. basis_level (string) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"levels (count) maximum number dose levels increment next dose. defaults 1, means dose skipping allowed, .e. next dose can maximum one level higher current base dose. current base dose level dose level used increment (see basis_level parameter). basis_level (string) defines current base dose level. can take one two possible values: last max. last specified (default), current base dose level set last dose given. max specified, current base dose level set maximum dose level given.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"Typically, end users use .DefaultIncrementsDoseLevels() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsDoseLevels-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsDoseLevels — IncrementsDoseLevels-class","text":"","code":"# The rule for dose increments which allows for maximum skip one dose level, # that is 2 dose levels higher than the last dose given. my_increments <- IncrementsDoseLevels(levels = 2, basis_level = \"last\")"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsHSRBeta — IncrementsHSRBeta-class","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"IncrementsHSRBeta class limiting increments using Hard Safety Rule based Bin-Beta model. Increment control based number observed DLTs number subjects dose level. probability toxicity calculated using Bin-Beta model prior (,b). probability exceeds threshold given dose, dose doses excluded escalation. hard safety rule limits escalation based observed data per dose level, independent underlying model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"","code":"IncrementsHSRBeta(target = 0.3, prob = 0.95, a = 1, b = 1)  .DefaultIncrementsHSRBeta()"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"target (proportion) see slot definition. prob (proportion) see slot definition. (number) see slot definition. b (number) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"target (proportion) target toxicity, except 0 1. prob (proportion) threshold probability (except 0 1) dose toxic. (number) shape parameter \\(> 0\\) probability distribution Beta (,b). b (number) shape parameter \\(b > 0\\) probability distribution Beta (,b).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"Typically, end users use .DefaultIncrementsHSRBeta() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsHSRBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsHSRBeta — IncrementsHSRBeta-class","text":"","code":"# Limit the escalation with a hard safety criteria to the doses that are below # the first dose that is toxic with a probability of 0.95. my_increments <- IncrementsHSRBeta(target = 0.3, prob = 0.95)"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMaxToxProb-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsMaxToxProb — IncrementsMaxToxProb-class","title":"IncrementsMaxToxProb — IncrementsMaxToxProb-class","text":"IncrementsMaxToxProb class increments control based probability toxicity","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMaxToxProb-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsMaxToxProb — IncrementsMaxToxProb-class","text":"","code":"IncrementsMaxToxProb(prob)  .DefaultIncrementsMaxToxProb()"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMaxToxProb-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsMaxToxProb — IncrementsMaxToxProb-class","text":"prob (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMaxToxProb-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsMaxToxProb — IncrementsMaxToxProb-class","text":"prob (numeric) See Usage Notes .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMaxToxProb-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsMaxToxProb — IncrementsMaxToxProb-class","text":"Typically, end users use .DefaultIncrementsMaxToxProb() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMaxToxProb-class.html","id":"usage-notes","dir":"Reference","previous_headings":"","what":"Usage Notes","title":"IncrementsMaxToxProb — IncrementsMaxToxProb-class","text":"binary models, prob scalar probability. ordinal models, prob named vector containing maximum permissible probability toxicity grade.  names match names yCategories slot associated DataOrdinal object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMaxToxProb-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsMaxToxProb — IncrementsMaxToxProb-class","text":"","code":"# For use with binary models and data IncrementsMaxToxProb(prob = 0.35) #> An object of class \"IncrementsMaxToxProb\" #> Slot \"prob\": #> [1] 0.35 #>   # For use with ordinal models and data IncrementsMaxToxProb(prob = c(\"DLAE\" = 0.2, \"DLT\" = 0.05)) #> An object of class \"IncrementsMaxToxProb\" #> Slot \"prob\": #> DLAE  DLT  #> 0.20 0.05  #>"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMin-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsMin — IncrementsMin-class","title":"IncrementsMin — IncrementsMin-class","text":"IncrementsMin class combines multiple increment rules minimum operation. Slot increments_list contains increment rules, objects class Increments. minimum individual increments taken give final maximum increment.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMin-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsMin — IncrementsMin-class","text":"","code":"IncrementsMin(increments_list)  .DefaultIncrementsMin()"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMin-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsMin — IncrementsMin-class","text":"increments_list (list) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMin-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsMin — IncrementsMin-class","text":"increments_list (list) list increment rules.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMin-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsMin — IncrementsMin-class","text":"Typically, end users use .DefaultIncrementsMin() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsMin-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsMin — IncrementsMin-class","text":"","code":"# As example, here we are combining 2 different increment rules.  # The first rule is the following: # maximum doubling the dose if no DLTs were observed at the current dose # or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose # or maximum increasing the dose by 1.22 if 3 or more DLTs were observed. my_increments_1 <- IncrementsRelativeDLT(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # The second rule is the following: # maximum doubling the dose if the current dose is <20 # or only maximum increasing the dose by 1.33 if the current dose is >=20. my_increments_2 <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Now we combine the 2 rules. comb_increments <- IncrementsMin(   increments_list = list(my_increments_1, my_increments_2) )"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsOrdinal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsOrdinal — IncrementsOrdinal-class","title":"IncrementsOrdinal — IncrementsOrdinal-class","text":"IncrementsOrdinal class applying standard Increments rule results ordinal CRM trial.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsOrdinal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsOrdinal — IncrementsOrdinal-class","text":"","code":"IncrementsOrdinal(grade, rule)  .DefaultIncrementsOrdinal()"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsOrdinal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsOrdinal — IncrementsOrdinal-class","text":"grade (numeric) see slot definition. rule (Increments) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsOrdinal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsOrdinal — IncrementsOrdinal-class","text":"grade (integer) toxicity grade rule applied. rule (Increments) standard Increments rule applied","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsOrdinal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsOrdinal — IncrementsOrdinal-class","text":"Typically, end users use .DefaultIncrementsOrdinal() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsOrdinal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsOrdinal — IncrementsOrdinal-class","text":"","code":"IncrementsOrdinal(   grade = 1L,   rule = IncrementsRelative(     intervals = c(0, 20),     increments = c(1, 0.33)   ) ) #> An object of class \"IncrementsOrdinal\" #> Slot \"grade\": #> [1] 1 #>  #> Slot \"rule\": #> An object of class \"IncrementsRelative\" #> Slot \"intervals\": #> [1]  0 20 #>  #> Slot \"increments\": #> [1] 1.00 0.33 #>  #>"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelative-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelative — IncrementsRelative-class","title":"IncrementsRelative — IncrementsRelative-class","text":"IncrementsRelative class increments control based relative differences intervals.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelative-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelative — IncrementsRelative-class","text":"","code":"IncrementsRelative(intervals, increments)  .DefaultIncrementsRelative()"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelative-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelative — IncrementsRelative-class","text":"intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelative-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsRelative — IncrementsRelative-class","text":"intervals (numeric) vector left bounds relevant intervals. example, intervals  = c(0, 50, 100) specifies three intervals: \\((0, 50)\\), \\([50, 100)\\) \\([100, +Inf)\\). means, right bound intervals exclusive interval last interval goes last value infinity. increments (numeric) vector length maximum allowable relative increments intervals.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelative-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsRelative — IncrementsRelative-class","text":"Typically, end users use .DefaultIncrementsRelative() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelative-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelative — IncrementsRelative-class","text":"","code":"# This is the example of a rule for: # maximum doubling the dose if the current dose is <20 # or only maximum increasing the dose by 1.33 if the current dose is >=20. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"IncrementsRelativeDLT class increments control based relative differences terms DLTs.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"","code":"IncrementsRelativeDLT(intervals, increments)  .DefaultIncrementsRelativeDLT()"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"intervals (integer) vector left bounds relevant DLT intervals. example, intervals  = c(0, 1, 3) specifies three intervals (sets DLTs: first, 0 DLT; second 1 2 DLTs; third one, least 3 DLTs. means, right bound intervals exclusive interval last interval goes last value infinity. increments (numeric) vector maximum allowable relative increments corresponding intervals. must length length intervals.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"considers DLTs across cohorts observed far. Typically, end users use .DefaultIncrementsRelativeDLT() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLT-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelativeDLT — IncrementsRelativeDLT-class","text":"","code":"# This is the example of a rule for: # maximum doubling the dose if no DLTs were observed in the whole study so far # or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed so far # or maximum increasing the dose by 1.22 if 3 or more DLTs were observed so far. my_increments <- IncrementsRelativeDLT(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"IncrementsRelativeDLTCurrent class increments control based relative differences current DLTs. class based number DLTs observed current cohort, cumulatively cohorts far.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"","code":"IncrementsRelativeDLTCurrent(intervals = c(0L, 1L), increments = c(2L, 1L))  .DefaultIncrementsRelativeDLTCurrent()"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"Typically, end users use .DefaultIncrementsRelativeDLTCurrent() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeDLTCurrent-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelativeDLTCurrent — IncrementsRelativeDLTCurrent-class","text":"","code":"# As example, here is the rule for: # maximum doubling the dose if no DLTs were observed at the current dose # or maximum increasing the dose by 1.33 if 1 or 2 DLTs were observed at the current dose # or maximum increasing the dose by 1.22 if 3 or more DLTs were observed.  my_increments <- IncrementsRelativeDLTCurrent(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"IncrementsRelativeParts — IncrementsRelativeParts-class","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"IncrementsRelativeParts class increments control based relative differences intervals, special rules part 1 beginning part 2.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"","code":"IncrementsRelativeParts(dlt_start, clean_start, ...)  .DefaultIncrementsRelativeParts()"},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"dlt_start (count) see slot definition. clean_start (count) see slot definition. ... Arguments passed IncrementsRelative intervals (numeric) see slot definition. increments (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"class works conjunction DataParts objects. part 2 just started next cohort, next maximum dose either dlt_start (e.g. -1) shift last part 1 dose case DLT part 1, clean_start shift (e.g. -1) case DLTs part 1, given clean_start <= 0 (see description clean_start slot details). part 1 still next cohort, next dose level next higher dose level part1Ladder slot data object. part 2 started , usual relative increment rules apply, see IncrementsRelative.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"dlt_start (integer) scalar, dose level increment starting part 2 case least one DLT event part 1. clean_start (integer) scalar, dose level increment starting part 2 case DLTs part 1. clean_start <= 0, part 1 ladder used find maximum next dose. Otherwise, relative increment rules applied find next maximum dose level.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"require clean_start >= dlt_start. However, precondition prerequisite function (except class' validation function) works objects class. rather motivated semantics. , observe DLT part 1, aggressive case clean part 1 without DLT. Typically, end users use .DefaultIncrementsRelativeParts() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/IncrementsRelativeParts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IncrementsRelativeParts — IncrementsRelativeParts-class","text":"","code":"my_increments <- IncrementsRelativeParts(dlt_start = 0, clean_start = 1)"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticIndepBeta — LogisticIndepBeta-class","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"LogisticIndepBeta class two-parameters logistic regression dose-limiting events (DLE) model prior expressed form pseudo data. model describes relationship binary DLE responses dose levels. specifically, represents relationship probabilities occurrence DLE corresponding dose levels log scale. model specified $$p(x) = exp(phi1 + phi2 * log(x)) / (1 + exp(phi1 + phi2 * log(x)))$$ \\(p(x)\\) probability occurrence DLE dose \\(x\\). two parameters model intercept \\(phi1\\) slope \\(phi2\\). LogisticIndepBeta inherits slots ModelTox class. context pseudo data, following three arguments used, binDLE, DLEdose DLEweights. DLEdose represents fixed dose levels pseudo DLE responses binDLE observed. DLEweights represents total number subjects treated per dose level DLEdose. binDLE represents number subjects observed DLE per dose level DLEdose. Hence, three vectors must length order elements vectors binDLE, DLEdose DLEweights must kept, element given vector corresponds elements remaining two vectors (see example insight). Finally, since least two DLE pseudo responses needed obtain prior modal estimates (maximum likelihood estimates) model parameters, binDLE, DLEdose DLEweights must vectors least length 2.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"","code":"LogisticIndepBeta(binDLE, DLEdose, DLEweights, data)  .DefaultLogisticIndepBeta()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"binDLE (numeric) number subjects observed DLE, pseudo DLE responses, depending dose levels DLEdose. Elements binDLE must correspond elements DLEdose DLEweights. DLEdose (numeric) dose levels pseudo DLE responses. Elements DLEdose must correspond elements binDLE DLEweights. DLEweights (numeric) total number subjects treated dose levels DLEdose, pseudo weights. Elements DLEweights must correspond elements binDLE DLEdose. data (Data) input data update estimates model parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"pseudo data can interpreted obtain observations trial starts. can used express prior, .e. initial beliefs model parameters. pseudo data expressed following way. First, fix least two dose levels, ask experts' opinion many subjects treated dose levels number subjects observed DLE. dose level, number subjects observed DLE, divided total number subjects treated, probability occurrence DLE particular dose level. probabilities occurrence DLE based pseudo data independent follow Beta distributions. Therefore, joint prior probability density function probabilities can obtained. Hence, change variable, joint prior probability density function two parameters model can also obtained. addition, conjugate joint prior density function two parameters model used. details form joint prior posterior probability density functions, please refer Whitehead Willamson (1998).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"binDLE (numeric) vector total numbers DLE responses. must least length 2 order elements must correspond values specified DLEdose DLEweights. DLEdose (numeric) vector dose levels corresponding must least length 2 order elements must correspond values specified binDLE DLEweights. DLEweights (integer) total number subjects treated pseudo dose level DLEdose. must least length 2 order elements must correspond values specified binDLE DLEdose. phi1 (number)  intercept model. slot used output display resulting prior posterior modal estimate intercept obtained based pseudo data () observed data/responses. phi2 (number)  slope model. slot used output display resulting prior posterior modal estimate slope obtained based pseudo data () observed data/responses. Pcov (matrix) refers 2x2 covariance matrix intercept (\\(phi1\\)) slope parameters (\\(phi2\\)) model. used output display resulting prior posterior covariance matrix \\(phi1\\) \\(phi2\\) obtained, based pseudo data () observed data responses. slot needed internal purposes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"Typically, end users use .DefaultLogisticIndepBeta() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticIndepBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticIndepBeta — LogisticIndepBeta-class","text":"","code":"# Obtain prior modal estimates given the pseudo data. # First we used an empty data set such that only the dose levels under # investigations are given. In total, 12 dose levels are under investigation # ranging from 25 to 300 mg with increments of 25 (i.e 25, 50, 75, ..., 300). emptydata <- Data(doseGrid = seq(25, 300, 25))  # Fix two dose levels 25 and 300 mg (DLEdose). # Total number of subjects treated in each of these levels is 3, (DLEweights). # The number of subjects observed with a DLE is 1.05 at dose 25 mg and 1.8 at dose 300 mg (binDLE). my_model1 <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEdose = c(25, 300),   DLEweights = c(3, 3),   data = emptydata )  # Use observed DLE responses to obtain posterior modal estimates. my_data <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = emptydata@doseGrid ) #> Used default patient IDs! #> Used best guess cohort indices!  my_model2 <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEdose = c(25, 300),   DLEweights = c(3, 3),   data = my_data )"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadane-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticKadane — LogisticKadane-class","title":"LogisticKadane — LogisticKadane-class","text":"LogisticKadane class logistic model parametrization Kadane et al. (1980).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadane-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticKadane — LogisticKadane-class","text":"","code":"LogisticKadane(theta, xmin, xmax)  .DefaultLogisticKadane()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadane-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticKadane — LogisticKadane-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadane-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticKadane — LogisticKadane-class","text":"Let rho0 = p(xmin) probability DLT minimum dose xmin, let gamma dose target toxicity probability theta, .e. \\(p(gamma) = theta\\). can easily shown logistic regression model intercept $$[gamma * logit(rho0) - xmin * logit(theta)] / [gamma - xmin]$$ slope $$[logit(theta) - logit(rho0)] / [gamma - xmin].$$ priors $$gamma ~ Unif(xmin, xmax).$$ $$rho0 ~ Unif(0, theta).$$","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadane-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticKadane — LogisticKadane-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadane-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticKadane — LogisticKadane-class","text":"slots class, required creating model, target toxicity, well minimum maximum dose range. Note can different minimum maximum dose grid data later . Typically, end-users use .DefaultLogisticKadane() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadane-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticKadane — LogisticKadane-class","text":"","code":"my_model <- LogisticKadane(theta = 0.33, xmin = 1, xmax = 200)"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"LogisticKadaneBetaGamma class logistic model parametrization Kadane et al. (1980), using beta gamma distribution model priors.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"","code":"LogisticKadaneBetaGamma(theta, xmin, xmax, alpha, beta, shape, rate)  .DefaultLogisticKadaneBetaGamma()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range. alpha (number) first shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. beta (number) second shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. shape (number) shape parameter Gamma prior distribution gamma dose target toxicity probability theta. rate (number) rate parameter Gamma prior distribution gamma dose target toxicity probability theta.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"Let rho0 = p(xmin) probability DLT minimum dose xmin, let gamma dose target toxicity probability theta, .e. \\(p(gamma) = theta\\). can easily shown logistic regression model intercept $$[gamma * logit(rho0) - xmin * logit(theta)] / [gamma - xmin]$$ slope $$[logit(theta) - logit(rho0)] / [gamma - xmin].$$ prior gamma, $$gamma ~ Gamma(shape, rate).$$. prior rho0 = p(xmin), $$rho0 ~ Beta(alpha, beta).$$","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"theta (proportion) target toxicity probability. xmin (number) minimum dose range. xmax (number) maximum dose range. alpha (number) first shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. beta (number) second shape parameter Beta prior distribution rho0 = p(xmin) probability DLT minimum dose xmin. shape (number) shape parameter Gamma prior distribution gamma dose target toxicity probability theta. rate (number) rate parameter Gamma prior distribution gamma dose target toxicity probability theta.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"slots class, required creating model, LogisticKadane class. addition, shape parameters Beta prior distribution rho0 shape rate parameters Gamma prior distribution gamma, required creating prior model. Typically, end users use .Default() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/LogisticKadaneBetaGamma-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticKadaneBetaGamma — LogisticKadaneBetaGamma-class","text":"","code":"my_model <- LogisticKadaneBetaGamma(   theta = 0.3,   xmin = 0,   xmax = 7,   alpha = 1,   beta = 19,   shape = 0.5625,   rate = 0.125 )"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormal — LogisticLogNormal-class","title":"LogisticLogNormal — LogisticLogNormal-class","text":"LogisticLogNormal class usual logistic regression model bivariate normal prior intercept log slope.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormal — LogisticLogNormal-class","text":"","code":"LogisticLogNormal(mean, cov, ref_dose = 1)  .DefaultLogisticLogNormal()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormal — LogisticLogNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormal — LogisticLogNormal-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticLogNormal — LogisticLogNormal-class","text":"Typically, end users use .DefaultLogisticLogNormal() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormal — LogisticLogNormal-class","text":"","code":"my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 ) my_model #> An object of class \"LogisticLogNormal\" #> Slot \"params\": #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #> [1] -0.85  1.00 #>  #> Slot \"cov\": #>      [,1] [,2] #> [1,]  1.0 -0.5 #> [2,] -0.5  1.0 #>  #> Slot \"prec\": #>           [,1]      [,2] #> [1,] 1.3333333 0.6666667 #> [2,] 0.6666667 1.3333333 #>  #>  #> Slot \"ref_dose\": #> An object of class \"positive_number\" #> [1] 50 #>  #> Slot \"datamodel\": #> function() { #>       for (i in 1:nObs) { #>         logit(p[i]) <- alpha0 + alpha1 * log(x[i] / ref_dose) #>         y[i] ~ dbern(p[i]) #>       } #>     } #> <bytecode: 0x55e36b2d2de8> #> <environment: 0x55e36ae58768> #>  #> Slot \"priormodel\": #> function() { #>       theta ~ dmnorm(mean, prec) #>       alpha0 <- theta[1] #>       alpha1 <- exp(theta[2]) #>     } #> <bytecode: 0x55e36b4dd1a0> #> <environment: 0x55e36ae58180> #>  #> Slot \"modelspecs\": #> function(from_prior) { #>       ms <- list(mean = params@mean, prec = params@prec) #>       if (!from_prior) { #>         ms$ref_dose <- ref_dose #>       } #>       ms #>     } #> <bytecode: 0x55e36b5f7928> #> <environment: 0x55e36ae58180> #>  #> Slot \"init\": #> function() { #>       list(theta = c(0, 1)) #>     } #> <bytecode: 0x55e36b672a58> #> <environment: 0x55e36ae58180> #>  #> Slot \"datanames\": #> [1] \"nObs\" \"y\"    \"x\"    #>  #> Slot \"datanames_prior\": #> character(0) #>  #> Slot \"sample\": #> [1] \"alpha0\" \"alpha1\" #>"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"LogisticLogNormalGrouped class logistic regression model mono combo arms simultaneous dose escalation design.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"","code":"LogisticLogNormalGrouped(mean, cov, ref_dose = 1)  .DefaultLogisticLogNormalGrouped()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"continuous covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\) LogisticLogNormal. addition, \\(I_c\\) binary indicator covariate 1 combo arm 0 mono arm. model defined : $$logit[p(x)] = (alpha0 + I_c * delta0) + (alpha1 + I_c * delta1) * log(x / x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\), delta0 delta1 differences combo arm compared mono intercept slope parameters alpha0 alpha1. prior defined $$(alpha0, log(delta0), log(alpha1), log(delta1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"Typically, end users use .DefaultLogisticLogNormalGrouped() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalGrouped-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormalGrouped — LogisticLogNormalGrouped-class","text":"","code":"my_model <- LogisticLogNormalGrouped(   mean = c(-0.85, 0, 1, 0),   cov = diag(1, 4),   ref_dose = 50 ) my_model #> An object of class \"LogisticLogNormalGrouped\" #> Slot \"params\": #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #> [1] -0.85  0.00  1.00  0.00 #>  #> Slot \"cov\": #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #> Slot \"prec\": #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  #>  #> Slot \"ref_dose\": #> An object of class \"positive_number\" #> [1] 50 #>  #> Slot \"datamodel\": #> function() { #>       for (i in 1:nObs) { #>         logit(p[i]) <- (alpha0 + is_combo[i] * delta0) + #>           (alpha1 + is_combo[i] * delta1) * log(x[i] / ref_dose) #>         y[i] ~ dbern(p[i]) #>       } #>     } #> <bytecode: 0x55e366a95938> #> <environment: 0x55e368300980> #>  #> Slot \"priormodel\": #> function() { #>       theta ~ dmnorm(mean, prec) #>       alpha0 <- theta[1] #>       delta0 <- exp(theta[2]) #>       alpha1 <- exp(theta[3]) #>       delta1 <- exp(theta[4]) #>     } #> <bytecode: 0x55e366766650> #> <environment: 0x55e368300980> #>  #> Slot \"modelspecs\": #> function(group, from_prior) { #>       ms <- list( #>         mean = params@mean, #>         prec = params@prec #>       ) #>       if (!from_prior) { #>         ms$ref_dose <- ref_dose #>         ms$is_combo <- as.integer(group == \"combo\") #>       } #>       ms #>     } #> <bytecode: 0x55e366c25030> #> <environment: 0x55e368300980> #>  #> Slot \"init\": #> function() { #>       list(theta = c(0, 1, 1, 1)) #>     } #> <bytecode: 0x55e366ca30c0> #> <environment: 0x55e368300980> #>  #> Slot \"datanames\": #> [1] \"nObs\" \"y\"    \"x\"    #>  #> Slot \"datanames_prior\": #> character(0) #>  #> Slot \"sample\": #> [1] \"alpha0\" \"delta0\" \"alpha1\" \"delta1\" #>"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"LogisticLogNormalMixture class standard logistic model online mixture two bivariate log normal priors.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"","code":"LogisticLogNormalMixture(mean, cov, ref_dose, share_weight)  .DefaultLogisticLogNormalMixture()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number). share_weight (proportion) prior weight share component.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"model can used data arising online informative component prior, time data trial main interest. Formally, achieved assuming probability DLT dose \\(x\\) given $$p(x) = \\pi * p1(x) + (1 - \\pi) * p2(x)$$ \\(\\pi\\) probability model \\(p(x)\\) model \\(p1(x)\\), informative component prior. model data arises parallel: doses xshare, DLT information yshare observed, total nObsshare data points (see DataMixture). hand, \\(1 - \\pi\\), probability separate model \\(p2(x)\\). components log normal prior distribution, can specified user, inherited LogisticLogNormal class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"share_weight (proportion) prior weight share component \\(p_{1}(x)\\).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"Typically, end users use .DefaultLogNormalMixture() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormalMixture — LogisticLogNormalMixture-class","text":"","code":"# Decide on the dose grid and MCMC options. dose_grid <- 1:80 my_options <- McmcOptions()  # Classic model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  empty_data <- Data(doseGrid = dose_grid) prior_samples <- mcmc(empty_data, my_model, my_options) plot(prior_samples, my_model, empty_data)   # Set up the mixture model and data share object. model_share <- LogisticLogNormalMixture(   share_weight = 0.1,   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  empty_data_share <- DataMixture(   doseGrid = dose_grid,   xshare = rep(c(10, 20, 40), each = 4),   yshare = rep(0L, 12), )  # Compare with the resulting prior model. prior_samples_share <- mcmc(empty_data_share, model_share, my_options) plot(prior_samples_share, model_share, empty_data_share)"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalOrdinal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormalOrdinal — LogisticLogNormalOrdinal-class","title":"LogisticLogNormalOrdinal — LogisticLogNormalOrdinal-class","text":"LogisticLogNormalOrdinal class logistic lognormal CRM model using ordinal toxicity scale.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalOrdinal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormalOrdinal — LogisticLogNormalOrdinal-class","text":"","code":"LogisticLogNormalOrdinal(mean, cov, ref_dose)  .DefaultLogisticLogNormalOrdinal()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalOrdinal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormalOrdinal — LogisticLogNormalOrdinal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalOrdinal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticLogNormalOrdinal — LogisticLogNormalOrdinal-class","text":"Typically, end users use .DefaultLogisticLogNormalOrdinal() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalOrdinal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormalOrdinal — LogisticLogNormalOrdinal-class","text":"","code":"LogisticLogNormalOrdinal(   mean = c(3, 4, 0),   cov = diag(c(4, 3, 1)),   ref_dose = 1 ) #> An object of class \"LogisticLogNormalOrdinal\" #> Slot \"params\": #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #> [1] 3 4 0 #>  #> Slot \"cov\": #>      [,1] [,2] [,3] #> [1,]    4    0    0 #> [2,]    0    3    0 #> [3,]    0    0    1 #>  #> Slot \"prec\": #>      [,1]      [,2] [,3] #> [1,] 0.25 0.0000000    0 #> [2,] 0.00 0.3333333    0 #> [3,] 0.00 0.0000000    1 #>  #>  #> Slot \"ref_dose\": #> An object of class \"positive_number\" #> [1] 1 #>  #> Slot \"datamodel\": #> function() { #>       for (i in 1:nObs) { #>         xhat[i] <- log(x[i] / ref_dose) #>         for (j in 1:(k - 1)) { #>           z[i, j] <- alpha[j] + beta * xhat[i] #>           p[i, j] <- exp(z[i, j]) / (1 + exp(z[i, j])) #>           tox[i, j] ~ dbern(p[i, j]) #>         } #>       } #>     } #> <bytecode: 0x55e367897530> #> <environment: 0x55e36c1a3218> #>  #> Slot \"priormodel\": #> function() { #>       alpha[1] ~ dnorm(mean[1], prec[1, 1]) #>       for (i in 2:(k - 1)) { #>         alpha[i] ~ dnorm(mean[i], prec[i, i]) %_% T(, alpha[i - 1]) #>       } #>       gamma ~ dnorm(mean[k], prec[k, k]) #>       beta <- exp(gamma) #>     } #> <bytecode: 0x55e369792720> #> <environment: 0x55e36c1a3218> #>  #> Slot \"modelspecs\": #> function(y, from_prior) { #>       ms <- list( #>         mean = params@mean, #>         prec = params@prec, #>         k = length(mean), #>         tox = array(dim = c(length(y), length(mean) - 1)) #>       ) #>       if (!from_prior) { #>         for (i in seq_along(y)) { #>           for (j in 1:(ms$k - 1)) { #>             ms$tox[i, j] <- y[i] >= j #>           } #>         } #>         ms$ref_dose <- ref_dose #>       } #>       ms #>     } #> <bytecode: 0x55e36bf33320> #> <environment: 0x55e36c1a3218> #>  #> Slot \"init\": #> function() { #>       list( #>         alpha = sapply(1:(length(mean) - 1), function(x) -(x + 1)), #>         gamma = 1 #>       ) #>     } #> <bytecode: 0x55e36b8eac00> #> <environment: 0x55e36c1a3218> #>  #> Slot \"datanames\": #> [1] \"nObs\" \"y\"    \"x\"    #>  #> Slot \"datanames_prior\": #> character(0) #>  #> Slot \"sample\": #> [1] \"alpha[1]\" \"alpha[2]\" \"beta\"     #>"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticLogNormalSub — LogisticLogNormalSub-class","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"LogisticLogNormalSub class standard logistic model bivariate (log) normal prior subtractive dose standardization.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"","code":"LogisticLogNormalSub(mean, cov, ref_dose = 0)  .DefaultLogisticLogNormalSub()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"covariate dose \\(x\\) minus reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * (x - x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"params (ModelParamsNormal) bivariate normal prior parameters. ref_dose (number) reference dose \\(x*\\).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"Typically, end-users use .DefaultLogisticLogNormalSub() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/LogisticLogNormalSub-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticLogNormalSub — LogisticLogNormalSub-class","text":"","code":"my_model <- LogisticLogNormalSub(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticNormal — LogisticNormal-class","title":"LogisticNormal — LogisticNormal-class","text":"LogisticNormal class usual logistic regression model bivariate normal prior intercept slope.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticNormal — LogisticNormal-class","text":"","code":"LogisticNormal(mean, cov, ref_dose = 1)  .DefaultLogisticNormal()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticNormal — LogisticNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticNormal — LogisticNormal-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, alpha1) ~ Normal(mean, cov).$$","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticNormal — LogisticNormal-class","text":"Typically, end users use .DefaultLogisticNormal() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticNormal — LogisticNormal-class","text":"","code":"# Define the dose-grid. empty_data <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  my_model <- LogisticNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2) )  my_options <- McmcOptions(burnin = 10, step = 2, samples = 100)  samples <- mcmc(empty_data, my_model, my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $alpha0 #>   [1] -0.50550773 -2.55233435 -1.62405124  0.35780922 -0.71965501  0.42837376 #>   [7] -0.08029425 -0.58437214 -0.88479483 -0.32646873  1.12395254 -0.80328044 #>  [13]  1.06255817 -1.07022490 -0.77342373 -2.52242958 -0.08640770 -0.09028514 #>  [19]  0.27102000 -0.12763081 -1.84685404  0.16925267 -0.22788287 -0.23416974 #>  [25] -0.37145776 -0.90900729 -0.69782063 -2.21460813 -1.77632471 -0.28655472 #>  [31]  0.56853490  0.68305028 -0.90359113 -0.67028281  1.16833165 -1.72144509 #>  [37] -0.24678460 -0.84819388 -0.40834143 -1.05269868 -0.61575612 -0.34734612 #>  [43] -1.39806749 -0.75272103 -0.82192865 -0.70109279  0.16498642 -2.41225549 #>  [49]  1.52832686 -0.51352820 -0.29846433 -3.08949461 -1.34449695 -1.20832138 #>  [55] -1.01918009  0.31581703 -0.93025604 -0.99585170 -0.47280368 -1.76770430 #>  [61]  0.77371410 -2.19797147  0.38874883 -1.56536338  0.15174317  0.03434288 #>  [67] -0.90893331 -0.75234691 -0.76644088 -1.64058341  0.26392064 -1.44312871 #>  [73]  0.63325730 -0.46814029 -0.53934425 -1.75198155 -1.84401974 -1.09249881 #>  [79] -0.80416992 -0.36417688  0.91957942 -0.95050079 -1.48272076 -0.89856651 #>  [85] -1.65551331  0.18251343  0.21480312 -2.20581665 -1.38941597  0.60676792 #>  [91] -1.64479794 -1.22598557 -0.88188276 -0.52800028  0.50303557 -1.27020074 #>  [97] -0.29156016 -3.22252144 -2.21374260 -0.44401091 #>  #> $alpha1 #>   [1]  1.35392326  3.57007773  2.00166917 -0.27989689  1.46173968 -0.02520215 #>   [7] -0.47914355  2.31133587  0.71806771  0.94885673  0.88481739  0.40003345 #>  [13] -0.13586279  0.95553481  1.92250290  2.06473039 -0.16739264  1.95839353 #>  [19] -0.03466121  1.93838678  2.90910308  0.30451249  0.78789480  1.34938286 #>  [25]  1.84485504  1.97901784  1.69092119  0.82372308  1.97871807  1.23489737 #>  [31]  2.11335459  2.14052299  1.66916985  0.73127349 -0.59483911  1.88080188 #>  [37]  0.63126434  0.20001458  1.46286022  0.00823751  0.65059328  0.76880537 #>  [43]  1.04392131  1.45747260  3.03984767  0.49615867  1.13007542  1.30525039 #>  [49]  0.57222840  1.26025039 -0.08752278  2.32178278  0.65647257  2.08143620 #>  [55]  0.07747305 -1.21434781  1.16135312  1.42945982  1.49168929  1.60108182 #>  [61] -0.75602006  1.43485755  0.54068667  0.55333639  0.96676839  0.66455201 #>  [67]  1.69191646  3.52197760  2.31230423  0.83163427  0.25762222  3.91043577 #>  [73]  1.09832107  1.57423620  0.41283559  1.85250918  1.71835268  1.06294806 #>  [79]  1.29546397  0.54876826  1.42400757  0.35076745  0.34576507  1.20163670 #>  [85]  0.75506254  0.38849803  1.85147485  2.23275006 -0.18297486  0.87974582 #>  [91]  1.66780454  1.91597971  1.16490812 -0.06291770  0.17579833  0.29063930 #>  [97] -0.01257664  0.21809149  1.75031831  2.53735671 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 210 #>  #> Slot \"burnin\": #> [1] 10 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] NA #>  #> Slot \"rng_seed\": #> [1] NA #>  #>"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"LogisticNormalFixedMixture class standard logistic regression model fixed mixture multiple bivariate (log) normal priors intercept slope parameters. weights normal priors fixed, hence additional model parameters introduced. type prior often used better approximate given posterior distribution, information given terms mixture.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"","code":"LogisticNormalFixedMixture(components, weights, ref_dose, log_normal = FALSE)  .DefaultLogisticNormalFixedMixture()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"components (list) specifications mixture components, list ModelParamsNormal objects bivariate (log) normal prior. weights (numeric) weights components; must positive normalized sum 1. ref_dose (number) reference dose \\(x*\\) (strictly positive number). log_normal (flag) log normal prior specified, mean vectors covariance matrices valid intercept log slope?","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, alpha1) ~ w1 * Normal(mean1, cov1) + ... + wK * Normal(meanK, covK),$$ normal prior used $$(alpha0, log(alpha1)) ~ w1 * Normal(mean1, cov1) + ... + wK * Normal(meanK, covK),$$ log normal prior used. weights \\(w1, ..., wK\\) components fixed sum 1. slots class comprise list components parameters. Every single component contains mean vector covariance matrix bivariate normal distributions. Remaining slots weights components well reference dose. Moreover, special indicator slot specifies whether log normal prior used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"components (list) specifications mixture components, list ModelParamsNormal objects bivariate (log) normal prior. weights (numeric) weights components; must positive must sum 1. ref_dose (positive_number) reference dose. log_normal (flag) log normal prior used, mean vectors covariance matrices valid intercept log slope?","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"Typically, end-users use .DefaultLogisticNormalFixedMixture() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalFixedMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticNormalFixedMixture — LogisticNormalFixedMixture-class","text":"","code":"my_model <- LogisticNormalFixedMixture(   components = list(     comp1 = ModelParamsNormal(       mean = c(-0.85, 1),       cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2)     ),     comp2 = ModelParamsNormal(       mean = c(1, 1.5),       cov = matrix(c(1.2, -0.45, -0.45, 0.6), nrow = 2)     )   ),   weights = c(0.3, 0.7),   ref_dose = 50 )"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":null,"dir":"Reference","previous_headings":"","what":"LogisticNormalMixture — LogisticNormalMixture-class","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"LogisticNormalMixture class standard logistic regression model mixture two bivariate normal priors intercept slope parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"","code":"LogisticNormalMixture(comp1, comp2, weightpar, ref_dose)  .DefaultLogisticNormalMixture()"},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"comp1 (ModelParamsNormal) bivariate normal prior specification first component. See ModelParamsNormal details. comp2 (ModelParamsNormal) bivariate normal prior specification second component. See ModelParamsNormal details. weightpar (numeric) beta parameters weight first component. must named vector length 2 names b strictly positive values. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$logit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, alpha1) ~ w * Normal(mean1, cov1) + (1 - w) * Normal(mean2, cov2).$$ weight w first component assigned beta prior B(, b).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"comp1 (ModelParamsNormal) bivariate normal prior specification first component. comp2 (ModelParamsNormal) bivariate normal prior specification second component. weightpar (numeric) beta parameters weight first component. must named vector length 2 names b strictly positive values. ref_dose (positive_number) reference dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"weight two normal priors model parameter, hence flexible mixture. type prior often used mixture minimal informative informative component, order make CRM robust data deviations informative component. Typically, end-users use .DefaultLogisticNormalMixture() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/LogisticNormalMixture-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LogisticNormalMixture — LogisticNormalMixture-class","text":"","code":"my_model <- LogisticNormalMixture(   comp1 = ModelParamsNormal(     mean = c(-0.85, 1),     cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2)   ),   comp2 = ModelParamsNormal(     mean = c(1, 1.5),     cov = matrix(c(1.2, -0.45, -0.45, 0.6), nrow = 2)   ),   weightpar = c(a = 1, b = 1),   ref_dose = 50 )"},{"path":"https://openpharma.github.io/crmPack/reference/McmcOptions-class.html","id":null,"dir":"Reference","previous_headings":"","what":"McmcOptions — McmcOptions-class","title":"McmcOptions — McmcOptions-class","text":"McmcOptions class three canonical MCMC options well Random Number Generator settings.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/McmcOptions-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"McmcOptions — McmcOptions-class","text":"","code":"McmcOptions(   burnin = 10000L,   step = 2L,   samples = 10000L,   rng_kind = NA_character_,   rng_seed = NA_integer_ )  .DefaultMcmcOptions()"},{"path":"https://openpharma.github.io/crmPack/reference/McmcOptions-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"McmcOptions — McmcOptions-class","text":"burnin (count) number burn-iterations saved. step (count) every step-th iteration saved burn-. samples (count) number resulting samples. rng_kind (string) name RNG type. Possible types : Wichmann-Hill, Marsaglia-Multicarry, Super-Duper, Mersenne-Twister. NA (default), RNG kind chosen [rjags]. rng_seed (number) RNG seed corresponding chosen rng_kind. must integer value NA (default), means seed chosen [rjags].","code":""},{"path":"https://openpharma.github.io/crmPack/reference/McmcOptions-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"McmcOptions — McmcOptions-class","text":"iterations (count) number MCMC iterations. burnin (count) number burn-iterations saved. step (count) every step-th iteration saved burnin. words, sample iteration = 1,...,iterations, saved (- burnin) mod step = 0. example, iterations = 6, burnin = 0 step = 2, samples iterations 2,4,6 saved. rng_kind (string) Random Number Generator (RNG) type used rjags::rjags. must one following four values: base::Wichmann-Hill, base::Marsaglia-Multicarry, base::Super-Duper, base::Mersenne-Twister, NA_character_. NA_character_ (default), RNG kind chosen rjags::rjags. rng_seed (number) Random Number Generator (RNG) seed used rjags::rjags chosen rng_kind. must integer scalar NA_integer_, means seed chosen rjags::rjags.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/McmcOptions-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"McmcOptions — McmcOptions-class","text":"Typically, end users use .DefaultMcmcOptions() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/McmcOptions-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"McmcOptions — McmcOptions-class","text":"","code":"# Set up MCMC option in order to have a burn-in of 10000 iterations and # then take every other iteration up to a collection of 10000 samples. McmcOptions(burnin = 10000, step = 2, samples = 10000) #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 30000 #>  #> Slot \"burnin\": #> [1] 10000 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] NA #>  #> Slot \"rng_seed\": #> [1] NA #>"},{"path":"https://openpharma.github.io/crmPack/reference/MinimalInformative.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a minimally informative prior — MinimalInformative","title":"Construct a minimally informative prior — MinimalInformative","text":"function constructs minimally informative prior, captured LogisticNormal (LogisticLogNormal) object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/MinimalInformative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a minimally informative prior — MinimalInformative","text":"","code":"MinimalInformative(   dosegrid,   refDose,   threshmin = 0.2,   threshmax = 0.3,   probmin = 0.05,   probmax = 0.05,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/MinimalInformative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a minimally informative prior — MinimalInformative","text":"dosegrid dose grid refDose reference dose threshmin toxicity probability threshold unlikely (see probmin) minimum dose (default: 0.2) threshmax toxicity probability threshold unlikely (see probmax) maximum dose (default: 0.3) probmin prior probability exceeding threshmin minimum dose (default: 0.05) probmax prior probability threshmax maximum dose (default: 0.05) ... additional arguments computations, see Quantiles2LogisticNormal, e.g. refDose logNormal=TRUE obtain minimal informative log normal prior.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/MinimalInformative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a minimally informative prior — MinimalInformative","text":"see Quantiles2LogisticNormal","code":""},{"path":"https://openpharma.github.io/crmPack/reference/MinimalInformative.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a minimally informative prior — MinimalInformative","text":"Based proposal Neuenschwander et al (2008, Statistics Medicine), minimally informative prior distribution constructed. required key input minimum (\\(d_{1}\\) notation Appendix .1 paper) maximum value (\\(d_{J}\\)) dose grid supplied function. threshmin probability threshold \\(q_{1}\\), probability DLT larger \\(q_{1}\\) 5% probability. Therefore \\(q_{1}\\) 95% quantile beta distribution hence \\(p_{1} = 0.95\\). Likewise, threshmax probability threshold \\(q_{J}\\), probability DLT smaller \\(q_{J}\\) 5% probability (\\(p_{J} = 0.05\\)). probabilities \\(1 - p_{1}\\) \\(p_{J}\\) can controlled arguments probmin probmax, respectively. Subsequently, doses supplied dosegrid argument, beta distributions set assumption prior medians linear log-dose logit scale, Quantiles2LogisticNormal used transform resulting quantiles approximating LogisticNormal (LogisticLogNormal) model. Note reference dose required computations.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/MinimalInformative.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a minimally informative prior — MinimalInformative","text":"","code":"# \\donttest{ # Setting up a minimal informative prior  # max.time is quite small only for the purpose of showing the example. They  # should be increased for a real case. set.seed(132) coarseGrid <- c(0.1, 10, 30, 60, 100) minInfModel <- MinimalInformative(dosegrid = coarseGrid,                                   refDose=50,                                   threshmin=0.2,                                   threshmax=0.3,                                   control=## for real case: leave out control                                      list(max.time=0.1))  #> It: 1, obj value (lsEnd): 0.6732911061 indTrace: 1 #> timeSpan = 4.350019 maxTime = 0.1 #> Emini is: 0.6732911061 #> xmini are: #> 3.436837973 9.074768474 4.306636605 0.7253533934 -0.7572128108  #> Totally it used 4.350047 secs #> No. of function call is: 991  # Plotting the result matplot(x=coarseGrid,         y=minInfModel$required,         type=\"b\", pch=19, col=\"blue\", lty=1,         xlab=\"dose\",         ylab=\"prior probability of DLT\") matlines(x=coarseGrid,          y=minInfModel$quantiles,          type=\"b\", pch=19, col=\"red\", lty=1) legend(\"right\",        legend=c(\"quantiles\", \"approximation\"),        col=c(\"blue\", \"red\"),        lty=1,        bty=\"n\")  # }"},{"path":"https://openpharma.github.io/crmPack/reference/ModelEff-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelEff — ModelEff-class","title":"ModelEff — ModelEff-class","text":"ModelEff parent class efficacy models using pseudo data prior. dedicated efficacy models prior specified form pseudo data (data trial starts). data must obey convention DataDual class. refers observed efficacy/biomarker responses (w DataDual), dose levels responses observed (x DataDual), dose levels considered study (doseGrid DataDual), finally specifications DataDual class can used generate prior posterior modal estimates samples estimates model parameter(s). responses observed, least doseGrid specified data prior modal estimates samples can obtained model parameters based specified pseudo data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelEff-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelEff — ModelEff-class","text":"","code":".DefaultModelEff()"},{"path":"https://openpharma.github.io/crmPack/reference/ModelEff-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelEff — ModelEff-class","text":"data (DataDual) observed data used obtain model parameters estimates samples (see details ).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelEff-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelEff — ModelEff-class","text":"Typically, end users use .DefaultModelEff() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/ModelLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelLogNormal — ModelLogNormal-class","title":"ModelLogNormal — ModelLogNormal-class","text":"ModelLogNormal class model reference dose bivariate normal prior model parameters alpha0 natural logarithm alpha1, .e.: $$(alpha0, log(alpha1)) ~ Normal(mean, cov),$$. Transformations log, e.g. identity, can specified priormodel slot. parameter alpha1 log-normal distribution default ensure positivity alpha1 guarantees exp(alpha1) > 1. slots class contain mean vector, covariance precision matrices bivariate normal distribution, well reference dose. Note precision matrix inverse covariance matrix JAGS. (\"normal\") model specific classes inherit class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelLogNormal — ModelLogNormal-class","text":"","code":"ModelLogNormal(mean, cov, ref_dose = 1)  .DefaultModelLogNormal()"},{"path":"https://openpharma.github.io/crmPack/reference/ModelLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModelLogNormal — ModelLogNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelLogNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelLogNormal — ModelLogNormal-class","text":"params (ModelParamsNormal) bivariate normal prior parameters. ref_dose (positive_number) reference dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelLogNormal — ModelLogNormal-class","text":"Typically, end users use .DefaultModelLogNormal() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/ModelParamsNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelParamsNormal — ModelParamsNormal-class","title":"ModelParamsNormal — ModelParamsNormal-class","text":"ModelParamsNormal class bivariate normal model parameters, .e. mean vector, covariance matrix precision matrix. precision matrix inverse covariance matrix JAGS computed internally object constructor function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelParamsNormal — ModelParamsNormal-class","text":"","code":"ModelParamsNormal(mean, cov)  .DefaultModelParamsNormal()"},{"path":"https://openpharma.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModelParamsNormal — ModelParamsNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelParamsNormal — ModelParamsNormal-class","text":"mean (numeric) mean vector. cov (matrix) covariance matrix. prec (matrix) precision matrix, inverse matrix cov.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelParamsNormal — ModelParamsNormal-class","text":"Typically, end users use .ModelPAramsNormal() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/ModelParamsNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModelParamsNormal — ModelParamsNormal-class","text":"","code":"ModelParamsNormal(mean = c(1, 6), cov = diag(2)) #> An object of class \"ModelParamsNormal\" #> Slot \"mean\": #> [1] 1 6 #>  #> Slot \"cov\": #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>  #> Slot \"prec\": #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #>"},{"path":"https://openpharma.github.io/crmPack/reference/ModelPseudo-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelPseudo — ModelPseudo-class","title":"ModelPseudo — ModelPseudo-class","text":"ModelPseudo parent class models express prior form pseudo data (data trial starts).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelPseudo-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelPseudo — ModelPseudo-class","text":"","code":".DefaultModelPseudo()"},{"path":"https://openpharma.github.io/crmPack/reference/ModelPseudo-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelPseudo — ModelPseudo-class","text":"Typically, end users use .DefaultModelPseudo() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/ModelTox-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelTox — ModelTox-class","title":"ModelTox — ModelTox-class","text":"ModelTox parent class DLE (dose-limiting events) models using pseudo data prior. dedicated DLE models toxicity models prior specified form pseudo data (data trial starts). data must obey convention Data class. refers observed DLE responses (y Data), dose levels (x Data) responses observed, dose levels considered study (doseGrid Data), finally specifications Data class can used generate prior posterior modal estimates samples estimates model parameter(s). responses observed, least doseGrid specified data prior modal estimates samples can obtained model parameters based specified pseudo data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelTox-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelTox — ModelTox-class","text":"","code":".DefaultModelTox()"},{"path":"https://openpharma.github.io/crmPack/reference/ModelTox-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"ModelTox — ModelTox-class","text":"data (Data) observed data used obtain model parameters estimates samples (see details ).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ModelTox-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ModelTox — ModelTox-class","text":"Typically, end users use .DefaultModelTox() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/NextBest-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBest — NextBest-class","title":"NextBest — NextBest-class","text":"NextBest virtual class finding next best dose, specific next best dose classes inherit.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBest-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBest — NextBest-class","text":"","code":".DefaultNextBest()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBest-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBest — NextBest-class","text":"Typically, end users use DefaultNextBest() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestDualEndpoint — NextBestDualEndpoint-class","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"NextBestDualEndpoint class next best dose based dual endpoint model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"","code":"NextBestDualEndpoint(   target,   overdose,   max_overdose_prob,   target_relative = TRUE,   target_thresh = 0.01 )  .DefaultNextBestDualEndpoint()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"target (numeric) see slot definition. overdose (numeric) see slot definition. max_overdose_prob (proportion) see slot definition. target_relative (flag) see slot definition. target_thresh (proportion) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"rule, first admissible doses found, toxicity probability fall overdose category max_overdose_prob. Next, picks (remaining admissible doses) one maximizes probability target biomarker range. default (target_relative = TRUE) target specified relative maximum biomarker level across dose grid relative Emax parameter case parametric model selected (.e. DualEndpointBeta, DualEndpointEmax). However, target_relative = FALSE, absolute biomarker range can used target.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"target (numeric) biomarker target range needs reached. example, target range \\((0.8, 1.0)\\) target_relative = TRUE means target dose least \\(80\\%\\) maximum biomarker level. example, \\((0.5, 0.8)\\) mean target dose \\(50\\%\\) \\(80\\%\\) maximum biomarker level. overdose (numeric) overdose toxicity interval (lower limit excluded, upper limit included). max_overdose_prob (proportion) maximum overdose probability allowed. target_relative (flag) target specified relative? TRUE, target interpreted relative maximum, must probability range. Otherwise, target interpreted absolute biomarker range. target_thresh (proportion) target probability threshold needs fulfilled target probability used deriving next best dose (default 0.01).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"Typically, end users use .DefaultNextBestDualEndpoint() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestDualEndpoint-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestDualEndpoint — NextBestDualEndpoint-class","text":"","code":"# Target a dose achieving at least 0.9 of maximum biomarker level (efficacy) # and with a probability below 0.25 that prob(DLT) > 0.35 (safety). my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Now, using absolute target on the natural biomarker scale. my_next_best_absolute <- NextBestDualEndpoint(   target = c(200, 300),   overdose = c(0.35, 1),   max_overdose_prob = 0.25,   target_relative = FALSE )"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestInfTheory-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestInfTheory — NextBestInfTheory-class","title":"NextBestInfTheory — NextBestInfTheory-class","text":"NextBestInfTheory class next best dose based information theory proposed https://doi.org/10.1002/sim.8450.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestInfTheory-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestInfTheory — NextBestInfTheory-class","text":"","code":"NextBestInfTheory(target, asymmetry)  .DefaultNextBestInfTheory()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestInfTheory-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestInfTheory — NextBestInfTheory-class","text":"target (proportion) see slot definition. asymmetry (number) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestInfTheory-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestInfTheory — NextBestInfTheory-class","text":"target (proportion) target toxicity probability, except 0 1. asymmetry (number) value asymmetry exponent divergence function describes rate penalization overly toxic . must value \\((0, 2)\\) interval.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestInfTheory-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestInfTheory — NextBestInfTheory-class","text":"Typically, end users use .DefaultNextBestInfTheory() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMTD-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMTD — NextBestMTD-class","title":"NextBestMTD — NextBestMTD-class","text":"NextBestMTD class next best dose based MTD estimate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMTD-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMTD — NextBestMTD-class","text":"","code":"NextBestMTD(target, derive)  .DefaultNextBestMTD()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMTD-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMTD — NextBestMTD-class","text":"target (proportion) see slot definition. derive (function) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMTD-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMTD — NextBestMTD-class","text":"target (proportion) target toxicity probability, except 0 1. derive (function) function derives final next best MTD estimate, based vector posterior MTD samples. must therefore accept one one argument, numeric vector, return number.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMTD-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestMTD — NextBestMTD-class","text":"Typically, end users use .DefaultNextBestMTD() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMTD-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMTD — NextBestMTD-class","text":"","code":"# In the example below, the MTD is defined as the dose for which prob(DLE) = 0.33 # and we will use the 25th quantile of the posterior of MTD as our next best dose. next_best_mtd <- NextBestMTD(   target = 0.33,   derive = function(mtd_samples) {     quantile(mtd_samples, probs = 0.25)   } )"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGain-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMaxGain — NextBestMaxGain-class","title":"NextBestMaxGain — NextBestMaxGain-class","text":"NextBestMaxGain class find next best dose maximum gain value based pseudo DLT efficacy models without samples. based solely probabilities occurrence DLT values mean efficacy responses obtained using modal estimates DLT efficacy model parameters. two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial. suitable use ModelTox model ModelEff classes (except EffFlexi).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMaxGain — NextBestMaxGain-class","text":"","code":"NextBestMaxGain(prob_target_drt, prob_target_eot)  .DefaultNextBestMaxGain()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMaxGain — NextBestMaxGain-class","text":"prob_target_drt (proportion) see slot definition. prob_target_eot (proportion) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMaxGain — NextBestMaxGain-class","text":"prob_target_drt (proportion) target probability occurrence DLT used trial. prob_target_eot (proportion) target probability occurrence DLT used end trial.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestMaxGain — NextBestMaxGain-class","text":"Typically, end users use .DefaultNextBestMaxGain() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGain-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMaxGain — NextBestMaxGain-class","text":"","code":"my_next_best <- NextBestMaxGain(0.35, 0.3)"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"NextBestMaxGainSamples class find next best dose maximum gain value based pseudo DLT efficacy models DLT efficacy samples. two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial. suitable use ModelTox model ModelEff classes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"","code":"NextBestMaxGainSamples(prob_target_drt, prob_target_eot, derive, mg_derive)  .DefaultNextBestMaxGainSamples()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"prob_target_drt (proportion) see slot definition NextBestMaxGain. prob_target_eot (proportion) see slot definition NextBestMaxGain. derive (function) see slot definition. mg_derive (function) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"derive (function) derives, based vector posterior dose samples, target dose probability occurrence DLT equals either prob_target_drt prob_target_eot. must therefore accept one one argument, numeric vector, return number. mg_derive (function) derives, based vector posterior dose samples give maximum gain value, final next best estimate dose gives maximum gain value. must therefore accept one one argument, numeric vector, return number.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"Typically, end users use .DefaultNextBestMaxGainSamples() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMaxGainSamples-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMaxGainSamples — NextBestMaxGainSamples-class","text":"","code":"# Target probability of the occurrence of a DLT during the trial is set to 0.35. # Target probability of the occurrence of a DLT at the end of the trial is set to 0.3. # We want the use the 30% posterior quantile (the 30th percentile) of the TD35 # (the dose level with probability of the DLT equals 0.35) and TD30 samples. # For `mg_derive` function (which takes the sample of doses which give the maximum # gain), we will use the 50% posterior quantile (the median or th 50th percentile) # of the sample. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMinDist-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestMinDist — NextBestMinDist-class","title":"NextBestMinDist — NextBestMinDist-class","text":"NextBestMinDist class next best dose based minimum distance target probability.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMinDist-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestMinDist — NextBestMinDist-class","text":"","code":"NextBestMinDist(target)  .DefaultNextBestMinDist()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMinDist-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestMinDist — NextBestMinDist-class","text":"target (proportion) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMinDist-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestMinDist — NextBestMinDist-class","text":"target (proportion) single target toxicity probability, except 0 1.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMinDist-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestMinDist — NextBestMinDist-class","text":"Typically, end users use .DefaultNextBestMinDist() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestMinDist-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestMinDist — NextBestMinDist-class","text":"","code":"# In the example below, the MTD is defined as the dose with the toxicity rate # with minimal distance to the target of 30%. next_best_min_dist <- NextBestMinDist(target = 0.3)"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRM-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestNCRM — NextBestNCRM-class","title":"NextBestNCRM — NextBestNCRM-class","text":"NextBestNCRM class next best dose finds next dose high posterior probability target toxicity interval.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRM-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestNCRM — NextBestNCRM-class","text":"","code":"NextBestNCRM(target, overdose, max_overdose_prob)  .DefaultNextBestNCRM()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRM-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestNCRM — NextBestNCRM-class","text":"target (numeric) see slot definition. overdose (numeric) see slot definition. max_overdose_prob (proportion) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRM-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"NextBestNCRM — NextBestNCRM-class","text":"avoid numerical problems, dose selection algorithm implemented follows: First admissible doses found, probability fall overdose category max_overdose_prob. Next, within admissible doses, maximum probability fall target category calculated. 5% (.e. just numerical error), corresponding dose next recommended dose. Otherwise, highest admissible dose next recommended dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRM-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestNCRM — NextBestNCRM-class","text":"target (numeric) target toxicity interval (limits included). overdose (numeric) overdose toxicity interval (lower limit excluded, upper limit included). used filter probability samples. max_overdose_prob (proportion) maximum overdose posterior probability allowed, except 0 1.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRM-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestNCRM — NextBestNCRM-class","text":"Typically, end users use .DefaultNextBestNCRM() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRM-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestNCRM — NextBestNCRM-class","text":"","code":"# In the example below, the target toxicity interval [0.2, 0.35] while the # overdose interval is (0.35,1]. Finally we would like to constrain the # probability of overdosing below 25%. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestNCRMLoss — NextBestNCRMLoss-class","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"NextBestNCRMLoss class based NCRM rule loss function. class similar NextBestNCRM class, differences addition loss function re-defined toxicity intervals, see toxicity interval documentation note details. NCRM rule, first admissible doses found, probability fall overdose category max_overdose_prob. Next, within admissible doses, loss function calculated, .e. losses %*% target. Finally, corresponding dose lowest loss function (Bayes risk) recommended next dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"","code":"NextBestNCRMLoss(   target,   overdose,   unacceptable = c(1, 1),   max_overdose_prob,   losses )  .DefaultNextBestNCRMLoss()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"target (numeric) see slot definition. overdose (numeric) see slot definition. unacceptable (numeric) see slot definition. max_overdose_prob (proportion) see slot definition NextBestNCRM. losses (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"target (numeric) target toxicity interval (limits included). probability range excluding 0 1. overdose (numeric) overdose toxicity interval (lower limit excluded, upper limit included) excessive toxicity interval (lower limit excluded, upper limit included) unacceptable provided. probability range. used filter probability samples. unacceptable (numeric) unacceptable toxicity interval (lower limit excluded, upper limit included). must specified overdose include 1. Otherwise, c(1, 1) (default), essentially scalar equals 1. probability range. losses (numeric) vector specifying loss function. unacceptable provided, vector length must 4, otherwise 3.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"loss function vector either 3 4 values. loss function values must specified interval, -dosing, target toxicity, overdosing toxicity -dosing, target toxicity, overdosing (excessive) toxicity, unacceptable toxicity intervals. Typically, end users use .DefaultNextBestnCRMLoss() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestNCRMLoss-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestNCRMLoss — NextBestNCRMLoss-class","text":"","code":"# In the example below, the target toxicity interval [0.2, 0.35] while the # overdose interval is (0.35, 1]. We would like to constrain the probability # of overdosing below 25%. The loss function is c(1, 0, 1, 2). my_next_best <- NextBestNCRMLoss(   target = c(0.2, 0.35),   overdose = c(0.35, 0.6),   unacceptable = c(0.6, 1),   max_overdose_prob = 0.25,   losses = c(1, 0, 1, 2) )"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestOrdinal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestOrdinal — NextBestOrdinal-class","title":"NextBestOrdinal — NextBestOrdinal-class","text":"NextBestOrdinal class applying standard NextBest rule results ordinal CRM trial.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestOrdinal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestOrdinal — NextBestOrdinal-class","text":"","code":"NextBestOrdinal(grade, rule)  .DefaultNextBestOrdinal()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestOrdinal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestOrdinal — NextBestOrdinal-class","text":"grade (numeric) see slot definition. rule (NextBest) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestOrdinal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestOrdinal — NextBestOrdinal-class","text":"grade (integer) toxicity grade rule applied. rule (NextBest) standard NextBest rule applied","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestOrdinal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestOrdinal — NextBestOrdinal-class","text":"Typically, end users use .DefaultNextBestOrdinal() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestOrdinal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestOrdinal — NextBestOrdinal-class","text":"","code":"NextBestOrdinal(   grade = 1L,   rule = NextBestMTD(     0.25,     function(mtd_samples) {       quantile(mtd_samples, probs = 0.25)     }   ) ) #> An object of class \"NextBestOrdinal\" #> Slot \"grade\": #> [1] 1 #>  #> Slot \"rule\": #> An object of class \"NextBestMTD\" #> Slot \"target\": #> [1] 0.25 #>  #> Slot \"derive\": #> function (mtd_samples)  #> { #>     quantile(mtd_samples, probs = 0.25) #> } #> <environment: 0x55e3621477f0> #>  #>"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"NextBestProbMTDLTE class finding next best dose selects dose highest probability toxicity rate less equal toxicity target. dose determined calculating posterior toxicity probability dose per iteration select maximum dose toxicity probability equal target. dose highest frequency selected MTD across iterations next best dose. Placebo considered calculation removed dose grid calculations.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"","code":"NextBestProbMTDLTE(target)  .DefaultNextBestProbMTDLTE()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"target (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"target (numeric) target toxicity probability.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"Typically, end users use .DefaultNextBestProbMTDLTE() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDLTE-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestProbMTDLTE — NextBestProbMTDLTE-class","text":"","code":"# In the example below, the MTD is defined as the dose with the highest # probability of having a toxicity rate below 30%. next_best_prob_mtd_lte <- NextBestProbMTDLTE(target = 0.3)"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"NextBestProbMTDMinDist class finding next best dose selects dose highest probability toxicity rate smallest distance toxicity target. dose determined calculating posterior toxicity probability dose per iteration select dose smallest toxicity probability distance target. dose highest frequency selected MTD across iterations next best dose. Placebo considered next dose reason used calculations. .e. placebo toxicity probability distance target calculated taken account determination next dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"","code":"NextBestProbMTDMinDist(target)  .DefaultNextBestProbMTDMinDist()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"target (numeric) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"target (numeric) target toxicity probability.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"Typically, end users use .DefaultNextBestProbMTDMinDist() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestProbMTDMinDist-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestProbMTDMinDist — NextBestProbMTDMinDist-class","text":"","code":"# In the example below, the MTD is defined as the dose with the highest # probability of having a toxicity rate with minimal distance # to the target of 30%. next_best_prob_mtd_min_dist <- NextBestProbMTDMinDist(target = 0.3)"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTD-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestTD — NextBestTD-class","title":"NextBestTD — NextBestTD-class","text":"NextBestTD class find next best dose based pseudo DLT model without samples. Namely, find two next best doses, one allocation trial second final recommendation end trial without involving samples, .e. DLT responses incorporated dose-allocation. based solely probabilities occurrence DLT obtained using modal estimates model parameters. two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial. suitable use ModelTox model class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTD-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestTD — NextBestTD-class","text":"","code":".DefaultNextBestTD()  NextBestTD(prob_target_drt, prob_target_eot)"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTD-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestTD — NextBestTD-class","text":"prob_target_drt (proportion) see slot definition. prob_target_eot (proportion) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTD-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestTD — NextBestTD-class","text":"prob_target_drt (proportion) target probability (except 0 1) occurrence DLT used trial. prob_target_eot (proportion) target probability (except 0 1) occurrence DLT used end trial.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTD-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestTD — NextBestTD-class","text":"Typically, end users use .DefaultNextBestTD() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTD-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestTD — NextBestTD-class","text":"","code":"my_next_best <- NextBestTD(0.35, 0.3)"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTDsamples-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestTDsamples — NextBestTDsamples-class","title":"NextBestTDsamples — NextBestTDsamples-class","text":"NextBestTDsamples class find next best dose based Pseudo DLT model samples. Namely, find two next best doses, one allocation trial second final recommendation end trial. Hence, two target probabilities occurrence DLT must specified: target probability used trial target probability used end trial.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestTDsamples — NextBestTDsamples-class","text":"","code":"NextBestTDsamples(prob_target_drt, prob_target_eot, derive)  .DefaultNextBestTDsamples()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NextBestTDsamples — NextBestTDsamples-class","text":"prob_target_drt (proportion) see slot definition NextBestTD. prob_target_eot (proportion) see slot definition NextBestTD. derive (function) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"NextBestTDsamples — NextBestTDsamples-class","text":"derive (function) derives, based vector posterior dose samples, target dose probability occurrence DLT equals either prob_target_drt prob_target_eot. must therefore accept one one argument, numeric vector, return number.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestTDsamples — NextBestTDsamples-class","text":"Typically, end users use .DefaultNextBestTDsamples() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestTDsamples-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestTDsamples — NextBestTDsamples-class","text":"","code":"# Target probability of the occurrence of a DLT during the trial is set to 0.35. # Target probability of the occurrence of a DLT at the end of the trial is set to 0.3. # We want the use the 30% posterior quantile (the 30th percentile) of the TD35 # (the dose level with probability of the DLT equals 0.35) and TD30 samples. my_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestThreePlusThree-class.html","id":null,"dir":"Reference","previous_headings":"","what":"NextBestThreePlusThree — NextBestThreePlusThree-class","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"NextBestThreePlusThree class next best dose implements classical 3+3 dose recommendation. input required, hence class slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestThreePlusThree-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"","code":"NextBestThreePlusThree()  .DefaultNextBestThreePlusThree()"},{"path":"https://openpharma.github.io/crmPack/reference/NextBestThreePlusThree-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"Typically, end users use .DefaultNextBestThreePlusThree() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/NextBestThreePlusThree-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NextBestThreePlusThree — NextBestThreePlusThree-class","text":"","code":"# Next best dose class object using the classical 3+3 design. my_next_best <- NextBestThreePlusThree()"},{"path":"https://openpharma.github.io/crmPack/reference/OneParExpPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"OneParExpPrior — OneParExpPrior-class","title":"OneParExpPrior — OneParExpPrior-class","text":"OneParExpPrior class standard CRM exponential prior power parameter skeleton prior probabilities. implementation version one-parameter CRM (O’Quigley et al. 1990).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/OneParExpPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OneParExpPrior — OneParExpPrior-class","text":"","code":"OneParExpPrior(skel_probs, dose_grid, lambda)  .DefaultOneParExpPrior()"},{"path":"https://openpharma.github.io/crmPack/reference/OneParExpPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OneParExpPrior — OneParExpPrior-class","text":"skel_probs see slot definition. dose_grid (numeric) dose grid. must must sorted vector length skel_probs. lambda see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/OneParExpPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"OneParExpPrior — OneParExpPrior-class","text":"skel_fun (function) function calculate prior DLT probabilities. skel_fun_inv (function) inverse function skel_fun. skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. lambda (number) rate parameter prior exponential distribution theta.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/OneParExpPrior-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"OneParExpPrior — OneParExpPrior-class","text":"Typically, end users use .DefaultOneparExpPrior() function. Typically, end users use .DefaultOneParLogNormalPrior() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/OneParExpPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OneParExpPrior — OneParExpPrior-class","text":"","code":"my_model <- OneParExpPrior(   skel_probs = c(0.1, 0.3, 0.5, 0.7, 0.9),   dose_grid = 1:5,   lambda = 2 )"},{"path":"https://openpharma.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"OneParLogNormalPrior — OneParLogNormalPrior-class","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"OneParLogNormalPrior class standard CRM normal prior log power parameter skeleton prior probabilities.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"","code":"OneParLogNormalPrior(skel_probs, dose_grid, sigma2)  .DefaultOneParLogNormalPrior()"},{"path":"https://openpharma.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. dose_grid (numeric) dose grid. must must sorted vector length skel_probs. sigma2 (number) prior variance log power parameter alpha.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"instance OneParLogNormalPrior class","code":""},{"path":"https://openpharma.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"skel_fun (function) function calculate prior DLT probabilities. skel_fun_inv (function) inverse function skel_fun. skel_probs (numeric) skeleton prior probabilities. vector unique sorted probability values 0 1. sigma2 (number) prior variance log power parameter alpha.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/OneParLogNormalPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OneParLogNormalPrior — OneParLogNormalPrior-class","text":"","code":"my_model <- OneParLogNormalPrior(   skel_probs = seq(from = 0.1, to = 0.9, length = 5),   dose_grid = 1:5,   sigma2 = 2 )"},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ProbitLogNormal — ProbitLogNormal-class","title":"ProbitLogNormal — ProbitLogNormal-class","text":"ProbitLogNormal class probit regression model bivariate normal prior intercept log slope.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ProbitLogNormal — ProbitLogNormal-class","text":"","code":"ProbitLogNormal(mean, cov, ref_dose = 1)  .DefaultProbitLogNormal()"},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProbitLogNormal — ProbitLogNormal-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ProbitLogNormal — ProbitLogNormal-class","text":"covariate natural logarithm dose \\(x\\) divided reference dose \\(x*\\), .e.: $$probit[p(x)] = alpha0 + alpha1 * log(x/x*),$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ProbitLogNormal — ProbitLogNormal-class","text":"model also used DualEndpoint classes, class can used check prior assumptions dose-toxicity model, even sampling prior distribution dual endpoint model possible. Typically, end users use .DefaultProbitLogNormal() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ProbitLogNormal — ProbitLogNormal-class","text":"","code":"my_model <- ProbitLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 7.2 )"},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"ProbitLogNormalRel — ProbitLogNormalRel-class","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"ProbitLogNormalRel class probit regression model bivariate normal prior intercept log slope.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"","code":"ProbitLogNormalRel(mean, cov, ref_dose = 1)  .DefaultProbitLogNormalRel()"},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"covariate dose \\(x\\) divided reference dose \\(x*\\), .e.: $$probit[p(x)] = alpha0 + alpha1 * x/x*,$$ \\(p(x)\\) probability observing DLT given dose \\(x\\). prior $$(alpha0, log(alpha1)) ~ Normal(mean, cov).$$","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"model also used DualEndpoint classes, class can used check prior assumptions dose-toxicity model, even sampling prior distribution dual endpoint model possible. Typically, end users use .DefaultProbitLogNormalRel() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/ProbitLogNormalRel-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ProbitLogNormalRel — ProbitLogNormalRel-class","text":"","code":"my_model <- ProbitLogNormalRel(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2) )"},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualFlexiSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"PseudoDualFlexiSimulations — PseudoDualFlexiSimulations-class","title":"PseudoDualFlexiSimulations — PseudoDualFlexiSimulations-class","text":"class captures trial simulations design using DLE efficacy responses using EffFlexi efficacy model. extends PseudoDualSimulations adding capability capture sigma2betaW estimates.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualFlexiSimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PseudoDualFlexiSimulations — PseudoDualFlexiSimulations-class","text":"","code":"PseudoDualFlexiSimulations(sigma2_beta_w_est, ...)  .DefaultPseudoDualFlexiSimulations()"},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualFlexiSimulations-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PseudoDualFlexiSimulations — PseudoDualFlexiSimulations-class","text":"sigma2_beta_w_est (numeric) vector final posterior mean sigma2betaW estimates ... additional parameters PseudoDualSimulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualFlexiSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"PseudoDualFlexiSimulations — PseudoDualFlexiSimulations-class","text":"sigma2_beta_w_est (numeric) vector final posterior mean sigma2betaW estimates","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualFlexiSimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"PseudoDualFlexiSimulations — PseudoDualFlexiSimulations-class","text":"Typically, end users use .DefaultPseudoFlexiSimulations() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"PseudoDualSimulations — PseudoDualSimulations-class","title":"PseudoDualSimulations — PseudoDualSimulations-class","text":"class conducts trial simulations designs using DLE efficacy responses. defines final values efficacy fit DLE, estimates Gstar, optimal dose sigma2.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PseudoDualSimulations — PseudoDualSimulations-class","text":"","code":"PseudoDualSimulations(   fit_eff,   final_gstar_estimates,   final_gstar_at_dose_grid,   final_gstar_cis,   final_gstar_ratios,   final_optimal_dose,   final_optimal_dose_at_dose_grid,   sigma2_est,   ... )  .DefaultPseudoDualSimulations()"},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulations-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PseudoDualSimulations — PseudoDualSimulations-class","text":"fit_eff (list) see slot definition. final_gstar_estimates (numeric) see slot definition. final_gstar_at_dose_grid (numeric) see slot definition. final_gstar_cis (list) see slot definition. final_gstar_ratios (numeric) see slot definition. final_optimal_dose (numeric) see slot definition. final_optimal_dose_at_dose_grid (numeric) see slot definition. sigma2_est (numeric) see slot definition. ... additional parameters PseudoSimulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"PseudoDualSimulations — PseudoDualSimulations-class","text":"fit_eff (list) final values efficacy fit. final_gstar_estimates (numeric) final Gstar estimates. final_gstar_at_dose_grid (numeric) final Gstar estimates dose grid. final_gstar_cis (list) list 95% confidence interval Gstar estimates. final_gstar_ratios (numeric) ratios confidence intervals Gstar estimates. final_optimal_dose (numeric) final optimal dose. final_optimal_dose_at_dose_grid (numeric) final optimal dose dose grid. sigma2_est (numeric) final sigma2 estimates.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"PseudoDualSimulations — PseudoDualSimulations-class","text":"use .DefaultPseudoDualSimulations() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"contains slots PseudoSimulationsSummary object. addition slots parent class PseudoSimulationsSummary, contains four slots efficacy model fit information.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"","code":".DefaultPseudoDualSimulationsSummary()"},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"targetGstar target dose level gain value maximum targetGstarAtDoseGrid dose level dose Grid closest Gstar GstarSummary six-number table summary (lowest, 25th, 50th (median), 75th percentile, mean highest value) final Gstar values obtained across simulations ratioGstarSummary six-number summary table ratios upper lower 95% credibility intervals final Gstar across simulations EffFitAtDoseMostSelected fitted expected mean efficacy value dose often selected meanEffFit list mean, lower (2.5%) upper (97.5%) quantiles fitted expected efficacy value dose level.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoDualSimulationsSummary-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class for the summary of the dual responses simulations using pseudo models — PseudoDualSimulationsSummary-class","text":"Typically, end users use .DefaultPseudoDualSimulationsSummary() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoSimulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"PseudoSimulations — PseudoSimulations-class","title":"PseudoSimulations — PseudoSimulations-class","text":"class captures trial simulations designs using pseudo model. additional slots fit stop_reasons compared general class GeneralSimulations.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoSimulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PseudoSimulations — PseudoSimulations-class","text":"","code":"PseudoSimulations(   fit,   final_td_target_during_trial_estimates,   final_td_target_end_of_trial_estimates,   final_td_target_during_trial_at_dose_grid,   final_td_target_end_of_trial_at_dose_grid,   final_tdeot_cis,   final_tdeot_ratios,   final_cis,   final_ratios,   stop_report,   stop_reasons,   ... )  .DefaultPseudoSimulations()"},{"path":"https://openpharma.github.io/crmPack/reference/PseudoSimulations-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PseudoSimulations — PseudoSimulations-class","text":"fit (list) see slot definition. final_td_target_during_trial_estimates (numeric) see slot definition. final_td_target_end_of_trial_estimates (numeric) see slot definition. final_td_target_during_trial_at_dose_grid (numeric) see slot definition. final_td_target_end_of_trial_at_dose_grid (numeric) see slot definition. final_tdeot_cis (list) see slot definition. final_tdeot_ratios (numeric) see slot definition. final_cis (list) see slot definition. final_ratios (numeric) see slot definition. stop_report see PseudoSimulations stop_reasons (list) see slot definition. ... additional parameters GeneralSimulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoSimulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"PseudoSimulations — PseudoSimulations-class","text":"fit (list) final fit values. final_td_target_during_trial_estimates (numeric) final estimates td_target_during_trial. final_td_target_end_of_trial_estimates (numeric) final estimates td_target_end_of_trial. final_td_target_during_trial_at_dose_grid (numeric)  dose levels dose grid closest final td_target_during_trial estimates. final_td_target_end_of_trial_at_dose_grid (numeric)  dose levels dose grid closest final td_target_end_of_trial estimates. final_tdeot_cis (list) 95% credibility intervals final estimates td_target_end_of_trial. final_tdeot_ratios (numeric) ratio upper lower 95% credibility intervals td_target_end_of_trial. final_cis (list) final 95% credibility intervals td_target_end_of_trial estimates. final_ratios (numeric) final ratios upper lower 95% credibility interval td_target_end_of_trial. stop_report (matrix) outcomes stopping rules. stop_reasons (list) reasons stopping simulation run.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoSimulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"PseudoSimulations — PseudoSimulations-class","text":"Typically, end users use .DefaultPseudoSimulations() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoSimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class for the summary of pseudo-models simulations output — PseudoSimulationsSummary-class","title":"Class for the summary of pseudo-models simulations output — PseudoSimulationsSummary-class","text":"Note objects created users, therefore initialization function provided class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/PseudoSimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class for the summary of pseudo-models simulations output — PseudoSimulationsSummary-class","text":"targetEndOfTrial target probability DLE wanted end trial targetDoseEndOfTrial dose level corresponds target probability DLE wanted end trial, TDEOT targetDoseEndOfTrialAtDoseGrid dose level dose grid corresponds target probability DLE wanted end trial targetDuringTrial target probability DLE wanted trial targetDoseDuringTrial dose level corresponds target probability DLE wanted trial. TDDT targetDoseDuringTrialAtDoseGrid dose level dose grid corresponds target probability DLE wanted trial TDEOTSummary six-number table summary, include lowest, 25th precentile (lower quartile), 50th percentile (median), mean, 27th percentile highest values final dose levels obtained corresponds target probability DLE want end trial across simulations TDDTSummary six-number table summary, include lowest, 25th precentile (lower quartile), 50th percentile (median), mean, 27th percentile highest values final dose levels obtained corresponds target probability DLE want trial across simulations FinalDoseRecSummary six-number table summary, include lowest, 25th precentile (lower quartile), 50th percentile (median), mean, 27th percentile highest values final optimal doses, either TDEOT DLE response incorporated escalation procedure minimum TDEOT Gstar DLE efficacy responses incorporated, across simulations ratioTDEOTSummary six-number summary table final ratios upper lower 95% credibility intervals final TDEOTs across simulations FinalRatioSummary six-number summary table final ratios upper lower 95% credibility intervals final optimal doses across simulations #@slot doseRec dose level recommend subsequent study nsim number simulations propDLE proportions DLE trials meanToxRisk mean toxicity risks patients doseSelected doses selected MTD (targetDoseEndOfTrial) toxAtDosesSelected true toxicity doses selected propAtTargetEndOfTrial Proportion trials selecting doseGrid closest MTD, targetDoseEndOfTrial propAtTargetDuringTrial Proportion trials selecting doseGrid closest targetDoseDuringTrial doseMostSelected dose often selected MTD obsToxRateAtDoseMostSelected observed toxicity rate dose often selected nObs number patients overall nAboveTargetEndOfTrial number patients treated targetDoseEndOfTrial nAboveTargetDuringTrial number patients treated targetDoseDuringTrial doseGrid dose grid used fitAtDoseMostSelected fitted toxicity rate dose often selected meanFit list average, lower (2.5%) upper (97.5%) quantiles mean fitted toxicity dose level stop_report matrix stopping rule outcomes","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Quantiles2LogisticNormal.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert prior quantiles (lower, median, upper) to logistic (log) normal model — Quantiles2LogisticNormal","title":"Convert prior quantiles (lower, median, upper) to logistic (log) normal model — Quantiles2LogisticNormal","text":"function uses generalized simulated annealing optimize LogisticNormal model close possible given prior quantiles.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Quantiles2LogisticNormal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert prior quantiles (lower, median, upper) to logistic (log) normal model — Quantiles2LogisticNormal","text":"","code":"Quantiles2LogisticNormal(   dosegrid,   refDose,   lower,   median,   upper,   level = 0.95,   logNormal = FALSE,   parstart = NULL,   parlower = c(-10, -10, 0, 0, -0.95),   parupper = c(10, 10, 10, 10, 0.95),   seed = 12345,   verbose = TRUE,   control = list(threshold.stop = 0.01, maxit = 50000, temperature = 50000, max.time =     600) )"},{"path":"https://openpharma.github.io/crmPack/reference/Quantiles2LogisticNormal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert prior quantiles (lower, median, upper) to logistic (log) normal model — Quantiles2LogisticNormal","text":"dosegrid dose grid refDose reference dose lower lower quantiles median medians upper upper quantiles level credible level (lower, upper) intervals (default: 0.95) logNormal use log-normal prior? (default) otherwise, normal prior logistic regression coefficients used parstart starting values parameters. default, determined medians supplied. parlower lower bounds parameters (intercept alpha slope beta, corresponding standard deviations correlation.) parupper upper bounds parameters seed seed random number generation verbose verbose? (default) control additional options optimisation routine, see GenSA details","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Quantiles2LogisticNormal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert prior quantiles (lower, median, upper) to logistic (log) normal model — Quantiles2LogisticNormal","text":"list best approximating model (LogisticNormal LogisticLogNormal), resulting quantiles, required quantiles distance required quantiles, well final parameters (used running algorithm second time)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Report.html","id":null,"dir":"Reference","previous_headings":"","what":"A Reference Class to represent sequentially updated reporting objects. — Report","title":"A Reference Class to represent sequentially updated reporting objects. — Report","text":"Reference Class represent sequentially updated reporting objects.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Report.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"A Reference Class to represent sequentially updated reporting objects. — Report","text":"object object report df data frame columns sequentially added dfNames names strings sequentially added","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"RuleDesign — RuleDesign-class","title":"RuleDesign — RuleDesign-class","text":"RuleDesign class rule-based designs. difference class Design class RuleDesign contain model, stopping increments slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RuleDesign — RuleDesign-class","text":"","code":"RuleDesign(nextBest, cohort_size, data, startingDose)  .DefaultRuleDesign()  ThreePlusThreeDesign(doseGrid)"},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RuleDesign — RuleDesign-class","text":"nextBest (NextBest) see slot definition. cohort_size (CohortSize) see slot definition. data (Data) see slot definition. startingDose (number) see slot definition. doseGrid (numeric) dose grid used (sorted).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesign-class.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"RuleDesign — RuleDesign-class","text":"ThreePlusThreeDesign(): creates new 3+3 design object dose grid.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"RuleDesign — RuleDesign-class","text":"nextBest (NextBest) find next best dose. cohort_size (CohortSize) rules cohort sizes. data (Data) specifies dose grid, previous data, etc. startingDose (number) starting dose, must lie dose grid data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"RuleDesign — RuleDesign-class","text":"Typically, end users use .DefaultRuleDesign() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RuleDesign — RuleDesign-class","text":"","code":"# Specify the design to run simulations. The design comprises a model, # the escalation rule, starting data, a cohort size and a starting dose.  # Initialing a 3+3 design with constant cohort size of 3 and starting dose equal 5. my_design <- RuleDesign(   nextBest = NextBestThreePlusThree(),   cohort_size = CohortSizeConst(size = 3L),   data = Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80)),   startingDose = 5 ) # Initialing a 3+3 design with constant cohort size of 3 and starting dose equal 8. my_design <- ThreePlusThreeDesign(doseGrid = c(8, 10, 15, 25, 35, 50, 80))"},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesignOrdinal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"RuleDesignOrdinal — RuleDesignOrdinal-class","title":"RuleDesignOrdinal — RuleDesignOrdinal-class","text":"RuleDesignOrdinal class rule-based designs. difference class DesignOrdinal class RuleDesignOrdinal contain model, stopping increments slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesignOrdinal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RuleDesignOrdinal — RuleDesignOrdinal-class","text":"","code":"RuleDesignOrdinal(next_best, cohort_size, data, starting_dose)  .DefaultRuleDesignOrdinal()"},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesignOrdinal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RuleDesignOrdinal — RuleDesignOrdinal-class","text":"next_best (NextBestOrdinal) see slot definition. cohort_size (CohortSizeOrdinal) see slot definition. data (DataOrdinal) see slot definition. starting_dose (number) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesignOrdinal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"RuleDesignOrdinal — RuleDesignOrdinal-class","text":"next_best (NextBestOrdinal) find next best dose. cohort_size (CohortSizeOrdinal) rules cohort sizes. data (DataOrdinal) specifies dose grid, previous data, etc. starting_dose (number) starting dose, must lie dose grid data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesignOrdinal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"RuleDesignOrdinal — RuleDesignOrdinal-class","text":"Typically, end users use .DefaultRuleDesignOrdinal() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/RuleDesignOrdinal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RuleDesignOrdinal — RuleDesignOrdinal-class","text":"","code":"RuleDesignOrdinal(   next_best = NextBestOrdinal(     1L,     NextBestMTD(       target = 0.25,       derive = function(x) median(x, na.rm = TRUE)     )   ),   cohort_size = CohortSizeOrdinal(1L, CohortSizeConst(size = 3L)),   data = DataOrdinal(doseGrid = c(5, 10, 15, 25, 35, 50, 80)),   starting_dose = 5 ) #> An object of class \"RuleDesignOrdinal\" #> Slot \"next_best\": #> An object of class \"NextBestOrdinal\" #> Slot \"grade\": #> [1] 1 #>  #> Slot \"rule\": #> An object of class \"NextBestMTD\" #> Slot \"target\": #> [1] 0.25 #>  #> Slot \"derive\": #> function (x)  #> median(x, na.rm = TRUE) #> <environment: 0x55e36a70b280> #>  #>  #>  #> Slot \"cohort_size\": #> An object of class \"CohortSizeOrdinal\" #> Slot \"grade\": #> [1] 1 #>  #> Slot \"rule\": #> An object of class \"CohortSizeConst\" #> Slot \"size\": #> [1] 3 #>  #>  #>  #> Slot \"data\": #> An object of class \"DataOrdinal\" #> Slot \"x\": #> numeric(0) #>  #> Slot \"y\": #> integer(0) #>  #> Slot \"doseGrid\": #> [1]  5 10 15 25 35 50 80 #>  #> Slot \"nGrid\": #> [1] 7 #>  #> Slot \"xLevel\": #> integer(0) #>  #> Slot \"yCategories\": #> No DLT    DLT  #>      0      1  #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> integer(0) #>  #> Slot \"cohort\": #> integer(0) #>  #> Slot \"nObs\": #> [1] 0 #>  #>  #> Slot \"starting_dose\": #> [1] 5 #>"},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindow-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SafetyWindow — SafetyWindow-class","title":"SafetyWindow — SafetyWindow-class","text":"SafetyWindow class safety window.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindow-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SafetyWindow — SafetyWindow-class","text":"","code":".DefaultSafetyWindow()"},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindow-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"SafetyWindow — SafetyWindow-class","text":"Typically, end users use .DefaultSafetyWindow() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowConst-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SafetyWindowConst — SafetyWindowConst-class","title":"SafetyWindowConst — SafetyWindowConst-class","text":"SafetyWindowConst class safety window length used gap kept constant across cohorts (though may vary within cohort).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SafetyWindowConst — SafetyWindowConst-class","text":"","code":"SafetyWindowConst(gap, follow, follow_min)  .DefaultSafetyWindowConst()"},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SafetyWindowConst — SafetyWindowConst-class","text":"gap see slot definition. follow see slot definition. follow_min see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"SafetyWindowConst — SafetyWindowConst-class","text":"gap (integer) vector, constant gap patients. follow (count) long follow patient. period time patient cohort needs followed next cohort opens. follow_min (count) minimum follow . least one patient cohort needs followed minimal follow time.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"SafetyWindowConst — SafetyWindowConst-class","text":"Typically, end users use .DefaultSafetyWindowConst() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowConst-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SafetyWindowConst — SafetyWindowConst-class","text":"","code":"# This is to have along the study constant parameters settings of safety window # length, regardless of the cohort size. my_win_len <- SafetyWindowConst(   gap = c(7, 5, 3),   follow = 7,   follow_min = 14 )"},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SafetyWindowSize — SafetyWindowSize-class","title":"SafetyWindowSize — SafetyWindowSize-class","text":"SafetyWindowSize class safety window length based cohort size. class used decide rolling rule clinical perspective.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SafetyWindowSize — SafetyWindowSize-class","text":"","code":"SafetyWindowSize(gap, size, follow, follow_min)  .DefaultSafetyWindowSize()"},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SafetyWindowSize — SafetyWindowSize-class","text":"gap see slot definition. size see slot definition. follow see slot definition. follow_min see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"SafetyWindowSize — SafetyWindowSize-class","text":"gap (list) observed period previous patient next patient can dosed. used follows. instance, cohort size 4 want specify three time intervals four consecutive patients, .e. 7 units time 1st 2nd patient, 5 units 2nd 3rd one, finally 3 units 3rd 4th one, , gap = list(c(7L, 5L, 3L)). Sometimes, want interval 1st 2nd patient increased safety consideration rest time intervals remain constant, regardless cohort size . , gap = list(c(7L, 3L)) package automatically repeat last element vector remaining time intervals. size (integer) vector left bounds relevant cohort size intervals. used follows. instance, want change gap based cohort size, .e. time interval 1st 2nd patient = 9 units time rest time intervals 5 units time cohort size equal larger 4. time interval 1st 2nd patient = 7 units time rest time intervals 3 units time cohort size smaller 4, specify gap = list(c(7, 3), c(9, 5)) size = c(0L, 4L). means, right bounds intervals excluded interval, last interval goes last value infinity. follow (count) period time patient cohort needs followed next cohort opens. follow_min (count) least one patient cohort needs followed minimal follow time.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"SafetyWindowSize — SafetyWindowSize-class","text":"Typically, end users use .DefaultSafetyWindowSize() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SafetyWindowSize-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SafetyWindowSize — SafetyWindowSize-class","text":"","code":"# Rule for having patient gap (7,3,3,3,...) for cohort size < 4, and # patient gap (9,5,5,5...) for cohort size >= 4. my_window_len <- SafetyWindowSize(   gap = list(c(7, 3), c(9, 5)),   size = c(1, 4),   follow = 7,   follow_min = 14 )"},{"path":"https://openpharma.github.io/crmPack/reference/Samples-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Samples — Samples-class","title":"Samples — Samples-class","text":"Samples class store MCMC samples.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Samples-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Samples — Samples-class","text":"","code":"Samples(data, options)  .DefaultSamples()"},{"path":"https://openpharma.github.io/crmPack/reference/Samples-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Samples — Samples-class","text":"data see slot definition. options see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Samples-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Samples — Samples-class","text":"data (list) MCMC samples parameter. entry list must vector (case scalar parameter) matrix (case vector-valued parameter) samples. case matrix, every row separate sample, columns correspond dimension parameter. options (McmcOptions) MCMC options used generate samples.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Samples-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Samples — Samples-class","text":"Typically, end users use .DefaultSamples() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Samples-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Samples — Samples-class","text":"","code":"# The MCMC options that were used to generate the samples. my_options <- McmcOptions(   burnin = 1000,   step = 2,   samples = 1000 )  # Create an object of class 'Samples' # Here the parameters 'alpha' and 'beta' are randomly generated. Of course, in # a real example these would be a samples coming from MCMC procedures. my_samples <- Samples(   data = list(alpha = rnorm(1000), beta = rnorm(1000)),   options = my_options )"},{"path":"https://openpharma.github.io/crmPack/reference/Simulations-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulations — Simulations-class","title":"Simulations — Simulations-class","text":"class captures trial simulations model based designs. Additional slots fit, stop_reasons, stop_report,additional_stats compared general class GeneralSimulations.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Simulations-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulations — Simulations-class","text":"","code":"Simulations(fit, stop_reasons, stop_report, additional_stats, ...)  .DefaultSimulations()"},{"path":"https://openpharma.github.io/crmPack/reference/Simulations-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulations — Simulations-class","text":"fit (list) see slot definition. stop_reasons (list) see slot definition. stop_report see Simulations additional_stats (list) see slot definition. ... additional parameters GeneralSimulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Simulations-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Simulations — Simulations-class","text":"fit (list) final fits stop_reasons (list) stopping reasons simulation run stop_report matrix stopping rule outcomes additional_stats list additional statistical summary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Simulations-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulations — Simulations-class","text":"Typically, end users use .DefaultSimulations() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Simulations-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulations — Simulations-class","text":"","code":"data <- list(   Data(     x = 1:2,     y = 0:1,     doseGrid = 1:2,     ID = 1L:2L,     cohort = 1L:2L   ),   Data(     x = 3:4,     y = 0:1,     doseGrid = 3:4,     ID = 1L:2L,     cohort = 1L:2L   ) )  doses <- c(1, 2)  seed <- as.integer(123)  fit <- list(   c(0.1, 0.2),   c(0.3, 0.4) )  stop_report <- matrix(c(TRUE, FALSE), nrow = 2)  stop_reasons <- list(\"A\", \"B\")  additional_stats <- list(a = 1, b = 1)  simulations <- Simulations(   fit = fit,   stop_report = stop_report,   stop_reasons = stop_reasons,   additional_stats = additional_stats,   data,   doses,   seed )"},{"path":"https://openpharma.github.io/crmPack/reference/SimulationsSummary-class.html","id":null,"dir":"Reference","previous_headings":"","what":"SimulationsSummary — SimulationsSummary-class","title":"SimulationsSummary — SimulationsSummary-class","text":"addition slots parent class GeneralSimulationsSummary, contains two slots model fit information.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SimulationsSummary-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SimulationsSummary — SimulationsSummary-class","text":"","code":".DefaultSimulationsSummary()"},{"path":"https://openpharma.github.io/crmPack/reference/SimulationsSummary-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"SimulationsSummary — SimulationsSummary-class","text":"stop_report (matrix) matrix stopping rule outcomes fit_at_dose_most_selected (numeric) fitted toxicity rate dose often selected additional_stats (list) list additional statistical summary mean_fit (list) list average, lower (2.5%) upper (97.5%) quantiles mean fitted toxicity dose level","code":""},{"path":"https://openpharma.github.io/crmPack/reference/SimulationsSummary-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"SimulationsSummary — SimulationsSummary-class","text":"Typically, end users use .DefaultSimulationsSummary() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StartingDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StartingDose — StartingDose-class","title":"StartingDose — StartingDose-class","text":"StartingDose simple wrapper class startingDose slot design classes. used internally knit_print methods","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StartingDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StartingDose — StartingDose-class","text":"","code":"StartingDose(starting_dose)  .DefaultStartingDose()"},{"path":"https://openpharma.github.io/crmPack/reference/StartingDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StartingDose — StartingDose-class","text":"starting_dose (positive_number) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StartingDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StartingDose — StartingDose-class","text":"starting_dose (numeric) starting dose","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StartingDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StartingDose — StartingDose-class","text":"Typically, end users use .DefaultStartingDose() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Stopping-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Stopping — Stopping-class","title":"Stopping — Stopping-class","text":"Stopping class stopping rules.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Stopping-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Stopping — Stopping-class","text":"report_label (string) label stopping report. meaning parameter twofold. equal NA_character_ (default), report_label used report . Otherwise, specified empty character (.e. character(0)) user constructor, default, class-specific label created slot. Finally, remaining cases, user can provide custom label.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAll-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingAll — StoppingAll-class","title":"StoppingAll — StoppingAll-class","text":"StoppingAll class testing stopping rule consists many single stopping rules turn objects class Stopping. single stopping rules must satisfied order result rule TRUE.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAll-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingAll — StoppingAll-class","text":"","code":"StoppingAll(stop_list, report_label = NA_character_)  .DefaultStoppingAll()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAll-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingAll — StoppingAll-class","text":"stop_list (list) see slot definition. report_label (string)  see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAll-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingAll — StoppingAll-class","text":"stop_list (list) list stopping rules. report_label label reporting","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAll-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingAll — StoppingAll-class","text":"Typically, end users use .DefaultStoppingAll() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAll-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingAll — StoppingAll-class","text":"","code":"# Define some stopping rules. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) my_stopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class `StoppingAll`) which would then be # summarized by the `all` function, meaning that the study would be stopped only # if all of the single stopping rules are `TRUE`. my_stopping <- StoppingAll(   stop_list = c(my_stopping1, my_stopping2, my_stopping3) )"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAny-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingAny — StoppingAny-class","title":"StoppingAny — StoppingAny-class","text":"StoppingAny class testing stopping rule consists many single stopping rules turn objects class Stopping. least one single stopping rule must satisfied order result rule TRUE.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAny-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingAny — StoppingAny-class","text":"","code":"StoppingAny(stop_list, report_label = NA_character_)  .DefaultStoppingAny()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAny-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingAny — StoppingAny-class","text":"stop_list (list) see slot definition. report_label (string) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAny-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingAny — StoppingAny-class","text":"stop_list (list) list stopping rules. report_label label reporting","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAny-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingAny — StoppingAny-class","text":"Typically, end users use .DefaultStoppingAny() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingAny-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingAny — StoppingAny-class","text":"","code":"# Define some stopping rules. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) my_stopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class `StoppingAny`) which would then be # summarized by the `any` function, meaning that the study would be stopped if # any of the single stopping rules is `TRUE`. my_stopping <- StoppingAny(   stop_list = c(my_stopping1, my_stopping2, my_stopping3) )"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"StoppingCohortsNearDose class stopping based number cohorts near next best dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"","code":"StoppingCohortsNearDose(   nCohorts = 2L,   percentage = 50,   report_label = NA_character_ )  .DefaultStoppingCohortsNearDose()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"nCohorts (number) see slot definition. percentage (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"nCohorts (number) number required cohorts. percentage (number) percentage (including 0 100) within next best dose cohorts must lie.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"Typically, end users use .DefaultStoppingCohortsNearDose() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingCohortsNearDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingCohortsNearDose — StoppingCohortsNearDose-class","text":"","code":"# Here, is the rule for stopping the study if at least 3 cohorts were dosed # at a dose within (1 +/- 0.2) of the next best dose. my_stopping <- StoppingCohortsNearDose(   nCohorts = 3,   percentage = 0.2 )"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingExternal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingExternal — StoppingExternal-class","title":"StoppingExternal — StoppingExternal-class","text":"StoppingExternal class stopping based external flag.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingExternal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingExternal — StoppingExternal-class","text":"","code":"StoppingExternal(report_label = NA_character_)  .DefaultStoppingExternal(report_label = NA_character_)"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingExternal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingExternal — StoppingExternal-class","text":"report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingExternal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingExternal — StoppingExternal-class","text":"Typically, end users use .DefaultStoppingExternal() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingExternal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingExternal — StoppingExternal-class","text":"","code":"my_stopping <- StoppingExternal()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingHighestDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingHighestDose — StoppingHighestDose-class","title":"StoppingHighestDose — StoppingHighestDose-class","text":"StoppingHighestDose class stopping based highest dose. , stopping occurs highest dose reached.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingHighestDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingHighestDose — StoppingHighestDose-class","text":"","code":"StoppingHighestDose(report_label = NA_character_)  .DefaultStoppingHighestDose()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingHighestDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingHighestDose — StoppingHighestDose-class","text":"report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingHighestDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingHighestDose — StoppingHighestDose-class","text":"Typically, end users use .DefaultStoppingHighestDose() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingHighestDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingHighestDose — StoppingHighestDose-class","text":"","code":"# The following stopping rule is met when: # - next proposed dose is highest dose, and # - there are already at least 3 patients on that dose, and # - we are sure that this dose is safe, e.g. the probability to be in (0%, 20%) # interval of the DLT rate is above 50%. my_stopping <- StoppingHighestDose() &   StoppingPatientsNearDose(nPatients = 3, percentage = 0) &   StoppingTargetProb(target = c(0, 0.2), prob = 0.5)  # We note that this rule would then need to be combined with the other standard # stopping rules, when the MTD is found based on being near e.g. a 30% DLT # probability or having reached maximal sample size, in the manner of: # stop_rule <- stop_high | stop_low | stop_sample_size # nolintr."},{"path":"https://openpharma.github.io/crmPack/reference/StoppingList-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingList — StoppingList-class","title":"StoppingList — StoppingList-class","text":"StoppingList class testing stopping rule consists many single stopping rules turn objects class Stopping. summary slot stores function takes logical vector size stop_list returns single logical value. example, function specified summary function, stopping rules defined stop_list must satisfied order result rule TRUE.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingList-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingList — StoppingList-class","text":"","code":"StoppingList(stop_list, summary)  .DefaultStoppingList()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingList-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingList — StoppingList-class","text":"stop_list (list) see slot definition. summary (function) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingList-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingList — StoppingList-class","text":"stop_list (list) list stopping rules. summary (function) summary function combine results stopping rules single result.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingList-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingList — StoppingList-class","text":"Typically, end users use .DefaultStoppingList() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingList-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingList — StoppingList-class","text":"","code":"# Define some stopping rules. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) my_stopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class `StoppingList`) which will then be # summarized (in this specific example) with the `any` function, meaning that # the study would be stopped if any of the single stopping rules is `TRUE`. my_stopping <- StoppingList(   stop_list = c(my_stopping1, my_stopping2, my_stopping3),   summary = any )"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"StoppingLowestDoseHSRBeta class stopping based Hard Safety Rule using Beta posterior distribution Beta(,b) prior Bin-Beta model based observed data lowest dose level. rule triggered first dose considered toxic (.e. threshold probability) based observed data lowest dose level Beta(,b) prior distribution. default prior Beta(1,1). case placebo used, rule evaluated second dose dose grid, .e. lowest non-placebo dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"","code":"StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.95,   a = 1,   b = 1,   report_label = NA_character_ )  .DefaultStoppingLowestDoseHSRBeta()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"target (proportion) see slot definition. prob (proportion) see slot definition. (number) see slot definition. b (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"target (proportion) target toxicity. prob (proportion) threshold probability lowest dose toxic. (number) shape parameter \\(> 0\\) probability distribution Beta (,b). b (number) shape parameter \\(b > 0\\) probability distribution Beta (,b).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"stopping rule independent underlying model. Typically, end users use .DefaultStoppingLowestDoseHSRBeta() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingLowestDoseHSRBeta-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingLowestDoseHSRBeta — StoppingLowestDoseHSRBeta-class","text":"","code":"# Stopping the study if the first dose is toxic with more than 90% # probability based on a Beta posterior distribution with Beta(1,1) prior. my_stopping <- StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.9 )  # Stopping the study if the first dose is toxic with more than 90% # probability based on a Beta posterior distribution with Beta(0.5,0.5) prior. my_stopping <- StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.9,   a = 0.5,   b = 0.5 )"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDCV-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMTDCV — StoppingMTDCV-class","title":"StoppingMTDCV — StoppingMTDCV-class","text":"StoppingMTDCV class stopping rule based precision MTD calculated coefficient variation (CV) MTD. , MTD defined dose reaches specific target probability occurrence DLT.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMTDCV — StoppingMTDCV-class","text":"","code":"StoppingMTDCV(target = 0.3, thresh_cv = 40, report_label = NA_character_)  .DefaultStoppingMTDCV()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMTDCV — StoppingMTDCV-class","text":"target (proportion) see slot definition. thresh_cv (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMTDCV — StoppingMTDCV-class","text":"target (proportion) toxicity target MTD (except 0 1). thresh_cv (number) threshold (percentage > 0) CV considered accurate enough stop trial. stopping occurs CV less equal tresh_cv.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMTDCV — StoppingMTDCV-class","text":"Typically, end users use .DefaultStoppingMTDCV() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDCV-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMTDCV — StoppingMTDCV-class","text":"","code":"# Stopping the study if the MTD estimation is precise enough, i.e. if robust # coefficient of variation of the MTD is below 40%. my_stopping <- StoppingMTDCV(target = 0.3, thresh_cv = 40)"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMTDdistribution — StoppingMTDdistribution-class","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"StoppingMTDdistribution class stopping based posterior distribution MTD. used cases stopping occurs probability MTD > thresh * next_dose greater equal prob, next_dose recommended next best dose. , MTD defined dose reaches specific target probability occurrence DLT.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"","code":"StoppingMTDdistribution(   target = 0.33,   thresh = 0.5,   prob = 0.9,   report_label = NA_character_ )  .DefaultStoppingMTDdistribution()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"target (proportion) see slot definition. thresh (proportion) see slot definition. prob (proportion) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"target (proportion) target toxicity probability (except 0 1) defining MTD. thresh (proportion) threshold (except 0 1) relative recommended next best dose. prob (proportion) required minimum probability, except 0 1.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"Typically, end users use .DefaultStoppingMTDDistribution() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMTDdistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMTDdistribution — StoppingMTDdistribution-class","text":"","code":"# As example, here is the rule for stopping the study if there is at least 0.9 # probability that MTD > 0.5 * next_dose. Here MTD is defined as the dose for # which prob(DLT) = 0.33 my_stopping <- StoppingMTDdistribution(   target = 0.33,   thresh = 0.5,   prob = 0.9 )"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"StoppingMaxGainCIRatio class testing stopping rule based target ratio 95% credibility interval. Specifically, ratio upper lower bound 95% credibility interval's estimate : (1) target dose (.e. dose corresponds given target probability occurrence DLT prob_target), (2) max gain dose (.e. dose gives maximum gain), depending one two smaller.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"","code":"StoppingMaxGainCIRatio(   target_ratio = 5,   prob_target = 0.3,   report_label = NA_character_ )  .DefaultStoppingMaxGainCIRatio()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"target_ratio (numeric) see slot definition. prob_target (proportion) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"target_ratio (numeric) target ratio 95% credibility interval's estimate, required stop trial. prob_target (proportion) target probability occurrence DLT.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMaxGainCIRatio-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMaxGainCIRatio — StoppingMaxGainCIRatio-class","text":"","code":"# Define the target stopping ratio (5) and the target probability of a DLT to # be used (0.3). my_stopping <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) .DefaultStoppingMaxGainCIRatio() #> An object of class \"StoppingMaxGainCIRatio\" #> Slot \"target_ratio\": #> [1] 5 #>  #> Slot \"prob_target\": #> [1] 0.3 #>  #> Slot \"report_label\": #> [1] \"GStar 5 for 0.3 target prob\" #>"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMinCohorts — StoppingMinCohorts-class","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"StoppingMinCohorts class stopping based minimum number cohorts.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"","code":"StoppingMinCohorts(nCohorts = 2L, report_label = NA_character_)  .DefaultStoppingMinCohorts()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"nCohorts (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"nCohorts (number) minimum required number cohorts.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"Typically, end users use .DefaultStoppingMinCohorts() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinCohorts-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMinCohorts — StoppingMinCohorts-class","text":"","code":"# As example, here is the rule for stopping the study if at least 6 cohorts # were already dosed. my_stopping <- StoppingMinCohorts(nCohorts = 6)"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinPatients-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMinPatients — StoppingMinPatients-class","title":"StoppingMinPatients — StoppingMinPatients-class","text":"StoppingMinPatients class stopping based minimum number patients","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMinPatients — StoppingMinPatients-class","text":"","code":"StoppingMinPatients(nPatients = 20L, report_label = NA_character_)  .DefaultStoppingMinPatients()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMinPatients — StoppingMinPatients-class","text":"nPatients (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingMinPatients — StoppingMinPatients-class","text":"nPatients (number) minimum allowed number patients.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMinPatients — StoppingMinPatients-class","text":"Typically, end users use .DefaultStoppingMinPatients() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMinPatients-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMinPatients — StoppingMinPatients-class","text":"","code":"# As example, here is the rule for stopping the study if at least 20 patients # were already dosed my_stopping <- StoppingMinPatients(nPatients = 20)"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMissingDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingMissingDose — StoppingMissingDose-class","title":"StoppingMissingDose — StoppingMissingDose-class","text":"StoppingMissingDose class stopping based NA returned next best dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMissingDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingMissingDose — StoppingMissingDose-class","text":"","code":"StoppingMissingDose(report_label = NA_character_)  .DefaultStoppingMissingDose()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMissingDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingMissingDose — StoppingMissingDose-class","text":"report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMissingDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingMissingDose — StoppingMissingDose-class","text":"Typically, end users use .DefaultStoppingMissingDose() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingMissingDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingMissingDose — StoppingMissingDose-class","text":"","code":"# The rule for stopping the study if NA or Placebo is returned as # next best dose. my_stopping <- StoppingMissingDose()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingOrdinal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingOrdinal — StoppingOrdinal-class","title":"StoppingOrdinal — StoppingOrdinal-class","text":"StoppingOrdinal class stopping based Stopping rule applied specific toxicity grade ordinal CRM trial","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingOrdinal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingOrdinal — StoppingOrdinal-class","text":"","code":"StoppingOrdinal(grade, rule)  .DefaultStoppingOrdinal()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingOrdinal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingOrdinal — StoppingOrdinal-class","text":"grade (integer) see slot definition. rule (Stopping) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingOrdinal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingOrdinal — StoppingOrdinal-class","text":"grade (integer) grade rule applied rule (Stopping) rule apply","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingOrdinal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingOrdinal — StoppingOrdinal-class","text":"Typically, end users use .DefaultStoppingOrdinal() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingOrdinal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingOrdinal — StoppingOrdinal-class","text":"","code":"StoppingOrdinal(   1L,   StoppingTargetProb(target = c(0.2, 0.35), prob = 0.6) ) #> An object of class \"StoppingOrdinal\" #> Slot \"grade\": #> [1] 1 #>  #> Slot \"rule\": #> An object of class \"StoppingTargetProb\" #> Slot \"target\": #> [1] 0.20 0.35 #>  #> Slot \"prob\": #> [1] 0.6 #>  #> Slot \"report_label\": #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.6\" #>  #>  #> Slot \"report_label\": #> character(0) #>"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"StoppingPatientsNearDose class stopping based number patients near next best dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"","code":"StoppingPatientsNearDose(   nPatients = 10L,   percentage = 50,   report_label = NA_character_ )  .DefaultStoppingPatientsNearDose()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"nPatients (number) see slot definition. percentage (number) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"nPatients (number) number required patients. percentage (number) percentage (including 0 100) within next best dose patients must lie.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"Typically, end users use .DefaultStoppingPatientsNearDose() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingPatientsNearDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingPatientsNearDose — StoppingPatientsNearDose-class","text":"","code":"# As example, here is the rule for stopping the study if at least 9 patients # were dosed at a dose within (1 +/- 0.2) of the next best dose.  my_stopping <- StoppingPatientsNearDose(   nPatients = 9,   percentage = 20 )"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingSpecificDose — StoppingSpecificDose-class","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"StoppingSpecificDose class testing stopping rule specific dose dose grid next best dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"","code":"StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0, 0.3), prob = 0.8),   dose = 80,   report_label = NA_character_ )  .DefaultStoppingSpecificDose()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"rule (Stopping) see slot definition. dose (number) see slot definition. report_label (string NA)  see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"rule (Stopping) stopping rule available package. dose (positive_number) dose defined part dose grid data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"Typically, end users use .DefaultStoppingSpecificDose() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingSpecificDose-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingSpecificDose — StoppingSpecificDose-class","text":"","code":"# Stop if highest dose 80 is safe. highest_dose_safe <- StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0, 0.3), prob = 0.8),   dose = 80 )  # Stop if lowest dose 10 is toxic. lowest_dose_toxic <- StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0.3, 1), prob = 0.8),   dose = 10 )"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingTDCIRatio — StoppingTDCIRatio-class","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"StoppingTDCIRatio class testing stopping rule based target ratio 95% credibility interval. Specifically, ratio upper lower bound 95% credibility interval's estimate target dose (.e. dose corresponds given target probability occurrence DLT prob_target).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"","code":"StoppingTDCIRatio(   target_ratio = 5,   prob_target = 0.3,   report_label = NA_character_ )  .DefaultStoppingTDCIRatio()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"target_ratio (numeric) see slot definition. prob_target (proportion) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"target_ratio (numeric) target ratio 95% credibility interval's estimate, required stop trial. prob_target (proportion) target probability occurrence DLT.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"Typically, end users use .DefaultStoppingTDCIRatio() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTDCIRatio-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingTDCIRatio — StoppingTDCIRatio-class","text":"","code":"# Define the target stopping ratio (5) and the target probability of a DLT to # be used (0.3). my_stopping <- StoppingTDCIRatio(   target_ratio = 5,   prob_target = 0.3 )"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"StoppingTargetBiomarker class stopping based probability target biomarker.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"","code":"StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.3,   is_relative = TRUE,   report_label = NA_character_ )  .DefaultStoppingTargetBiomarker()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"target (numeric) see slot definition. prob (proportion) see slot definition. is_relative (flag) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"target (numeric) biomarker target range needs reached. example, target = c(0.8, 1.0) is_relative = TRUE means target dose least 80% maximum biomarker level. is_relative (flag) target relative? (default), target interpreted relative maximum, must probability range. Otherwise, target interpreted absolute biomarker range. prob (proportion) required target probability (except 0 1) reaching sufficient precision.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"Typically, end users use .DefaultStoppingTargetBiomarker() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetBiomarker-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingTargetBiomarker — StoppingTargetBiomarker-class","text":"","code":"# Stopping the study if there is at least 0.5 probability that the biomarker # (efficacy) is within the biomarker target range of [0.9, 1.0] (relative to the # maximum for the biomarker).  my_stopping <- StoppingTargetBiomarker(target = c(0.9, 1), prob = 0.5)"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetProb-class.html","id":null,"dir":"Reference","previous_headings":"","what":"StoppingTargetProb — StoppingTargetProb-class","title":"StoppingTargetProb — StoppingTargetProb-class","text":"StoppingTargetProb class stopping based probability DLT rate target toxicity interval.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"StoppingTargetProb — StoppingTargetProb-class","text":"","code":"StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.4,   report_label = NA_character_ )  .DefaultStoppingTargetProb()"},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"StoppingTargetProb — StoppingTargetProb-class","text":"target (number) see slot definition. prob (proportion) see slot definition. report_label (string NA) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"StoppingTargetProb — StoppingTargetProb-class","text":"target (number) target toxicity interval, e.g. c(0.2, 0.35). prob (proportion) required target toxicity probability (except 0 1) reaching sufficient precision.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"StoppingTargetProb — StoppingTargetProb-class","text":"Typically, end users use .DefaultStoppingTargetProb() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/StoppingTargetProb-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"StoppingTargetProb — StoppingTargetProb-class","text":"","code":"# As example, here is the rule for stopping the study if the posterior # probability that [0.2 =< Prob(DLT | dose) <= 0.35] for the next best dose # is above 0.5. my_stopping <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)"},{"path":"https://openpharma.github.io/crmPack/reference/TDDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"TDDesign — TDDesign-class","title":"TDDesign — TDDesign-class","text":"TDDesign class design based DLT responses using ModelTox class model (.e. LogisticIndepBeta) without MCMC samples.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TDDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TDDesign — TDDesign-class","text":"","code":"TDDesign(   model,   stopping,   increments,   pl_cohort_size = CohortSizeConst(0L),   ... )  .DefaultTDDesign()"},{"path":"https://openpharma.github.io/crmPack/reference/TDDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TDDesign — TDDesign-class","text":"model (ModelTox) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition. ... Arguments passed RuleDesign nextBest (NextBest) see slot definition. cohort_size (CohortSize) see slot definition. data (Data) see slot definition. startingDose (number) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TDDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"TDDesign — TDDesign-class","text":"model (ModelTox) pseudo DLT model used. stopping (Stopping) stopping rule(s) trial. increments (Increments) control increments dose levels. pl_cohort_size (CohortSize) rules cohort sizes placebo, planned (defaults constant 0 placebo patients).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TDDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"TDDesign — TDDesign-class","text":"Typically, end users use .DefaultTDDesign() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TDDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TDDesign — TDDesign-class","text":"","code":"empty_data <- Data(doseGrid = seq(25, 300, 25))  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data )  # The escalation rule. my_next_best <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  my_size <- CohortSizeConst(size = 3)  # The increments for the dose-escalation process: #  the maximum increase of 200% for doses up to the maximum dose in grid, #  the maximum increase of 200% for dose above the maximum dose in grid. my_increments <- IncrementsRelative(   intervals = range(empty_data@doseGrid),   increments = c(2, 2) )  # Stop when the maximum sample size of 36 patients is reached. my_stopping <- StoppingMinPatients(nPatients = 36)  # The design with all the above information and starting with a dose of 25. # This design incorporates only DLT responses and no DLT samples are involved # during the simulation. design <- TDDesign(   model = my_model,   stopping = my_stopping,   increments = my_increments,   nextBest = my_next_best,   cohort_size = my_size,   data = empty_data,   startingDose = 25 )"},{"path":"https://openpharma.github.io/crmPack/reference/TDsamplesDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"TDsamplesDesign — TDsamplesDesign-class","title":"TDsamplesDesign — TDsamplesDesign-class","text":"TDsamplesDesign class design based DLT responses using ModelTox class model (.e. LogisticIndepBeta) well MCMC samples obtained model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TDsamplesDesign — TDsamplesDesign-class","text":"","code":"TDsamplesDesign(   model,   stopping,   increments,   pl_cohort_size = CohortSizeConst(0L),   ... )  .DefaultTDsamplesDesign()"},{"path":"https://openpharma.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TDsamplesDesign — TDsamplesDesign-class","text":"model (ModelTox) see slot definition. stopping (Stopping) see slot definition. increments (Increments) see slot definition. pl_cohort_size (CohortSize) see slot definition. ... Arguments passed RuleDesign nextBest (NextBest) see slot definition. cohort_size (CohortSize) see slot definition. data (Data) see slot definition. startingDose (number) see slot definition.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"TDsamplesDesign — TDsamplesDesign-class","text":"model (ModelTox) pseudo DLT model used. stopping (Stopping) stopping rule(s) trial. increments (Increments) control increments dose levels. pl_cohort_size (CohortSize) rules cohort sizes placebo, planned (defaults constant 0 placebo patients).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"TDsamplesDesign — TDsamplesDesign-class","text":"Typically, end users use .DefaultTDsamplesDesign() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TDsamplesDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TDsamplesDesign — TDsamplesDesign-class","text":"","code":"empty_data <- Data(doseGrid = seq(25, 300, 25))  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data )  # The escalation rule. my_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  my_size <- CohortSizeConst(size = 3)  # The increments for the dose-escalation process: #  the maximum increase of 200% for doses up to the maximum dose in grid, #  the maximum increase of 200% for dose above the maximum dose in grid. my_increments <- IncrementsRelative(   intervals = range(empty_data@doseGrid),   increments = c(2, 2) )  # Stop when the maximum sample size of 36 patients is reached. my_stopping <- StoppingMinPatients(nPatients = 36)  # The design with all the above information and starting with a dose of 25. design <- TDsamplesDesign(   model = my_model,   stopping = my_stopping,   increments = my_increments,   nextBest = my_next_best,   cohort_size = my_size,   data = empty_data,   startingDose = 25 )"},{"path":"https://openpharma.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":null,"dir":"Reference","previous_headings":"","what":"TITELogisticLogNormal — TITELogisticLogNormal-class","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"TITELogisticLogNormal class TITE-CRM based logistic regression model using bivariate normal prior intercept log slope parameters. class inherits LogisticLogNormal.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"","code":"TITELogisticLogNormal(weight_method = \"linear\", ...)  .DefaultTITELogisticLogNormal()"},{"path":"https://openpharma.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"weight_method (string) weight function method: either linear adaptive. used Liu, Yin Yuan's paper. ... Arguments passed LogisticLogNormal mean (numeric) prior mean vector. cov (matrix) prior covariance matrix. precision matrix prec internally calculated inverse cov. ref_dose (number) reference dose \\(x*\\) (strictly positive number).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"weight_method (string) weight function method: either linear adaptive. used Liu, Yin Yuan's paper.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"Typically, end users use .DefaultTITELogisticLogNormal() function.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/TITELogisticLogNormal-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TITELogisticLogNormal — TITELogisticLogNormal-class","text":"","code":"my_model <- TITELogisticLogNormal(   mean = c(0, 1),   cov = diag(2),   ref_dose = 1,   weight_method = \"linear\" )  my_model1 <- TITELogisticLogNormal(   mean = c(0, 1),   cov = diag(2),   ref_dose = 1,   weight_method = \"adaptive\" )"},{"path":"https://openpharma.github.io/crmPack/reference/Validate.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate — Validate","title":"Validate — Validate","text":"Validate class Reference Class help programming validation new S4 classes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Validate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate — Validate","text":"Starting empty msg vector, check returning FALSE vector gets new element - string explaining failure validation.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Validate.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Validate — Validate","text":"msg (character) cumulative messages.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/Validate.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Validate — Validate","text":"check(test, string = \"\") Check whether test TRUE; , return NULL. Otherwise, add string message cumulative messages vector msg. result() Return either cumulative messages vector msg (contains error messages checks), NULL, msg empty (.e. checks successful).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"method combining two atomic stopping rules","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"","code":"# S4 method for class 'Stopping,Stopping' e1 & e2"},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"e1 First Stopping object e2 Second Stopping object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"StoppingAll object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-Stopping-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining two atomic stopping rules — &,Stopping,Stopping-method","text":"","code":"## Example of combining two atomic stopping rules with an AND ('&') operator  myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)  myStopping <- myStopping1 & myStopping2"},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"method combining atomic stopping list","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"","code":"# S4 method for class 'Stopping,StoppingAll' e1 & e2"},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"e1 Stopping object e2 StoppingAll object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"modified StoppingAll object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-Stopping-StoppingAll-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining an atomic and a stopping list — &,Stopping,StoppingAll-method","text":"","code":"## Example of combining an atomic stopping rule with a list of stopping rules ## with an AND ('&') operator  myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)  myStopping3 <- StoppingMinPatients(nPatients = 20)  myStopping <- myStopping3 & (myStopping1 | myStopping2)"},{"path":"https://openpharma.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"method combining stopping list atomic","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"","code":"# S4 method for class 'StoppingAll,Stopping' e1 & e2"},{"path":"https://openpharma.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"e1 StoppingAll object e2 Stopping object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"modified StoppingAll object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/and-StoppingAll-Stopping-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining a stopping list and an atomic — &,StoppingAll,Stopping-method","text":"","code":"## Example of combining a list of stopping rules with an atomic stopping rule ## with an AND ('&') operator  myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)  myStopping3 <- StoppingMinPatients(nPatients = 20)  myStopping <- (myStopping1 | myStopping2) & myStopping3"},{"path":"https://openpharma.github.io/crmPack/reference/approximate.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate posterior with (log) normal distribution — approximate","title":"Approximate posterior with (log) normal distribution — approximate","text":"reproduce resultant approximate model future exactly, include seed = xxxx call approximate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/approximate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate posterior with (log) normal distribution — approximate","text":"","code":"approximate(object, model, data, ...)  # S4 method for class 'Samples' approximate(   object,   model,   data,   points = seq(from = min(data@doseGrid), to = max(data@doseGrid), length = 5L),   refDose = median(points),   logNormal = FALSE,   verbose = TRUE,   create_plot = TRUE,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/approximate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate posterior with (log) normal distribution — approximate","text":"object Samples object model GeneralModel object data Data object ... additional arguments (see methods) points optional parameter, gives dose values approximation rely (default: 5 values equally spaced minimum maximum dose grid) refDose reference dose used (default: median points) logNormal use log-normal prior? (default) otherwise, normal prior logistic regression coefficients used verbose verbose (progress statements)? (default) create_plot add ggplot2 object return value (default)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/approximate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate posterior with (log) normal distribution — approximate","text":"list containing approximation model , requested, ggplot2 object containing graphical representation fitted model","code":""},{"path":"https://openpharma.github.io/crmPack/reference/approximate.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Approximate posterior with (log) normal distribution — approximate","text":"approximate(Samples): ... argument can transport additional arguments Quantiles2LogisticNormal, e.g. order control approximation quality, etc.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/approximate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate posterior with (log) normal distribution — approximate","text":"","code":"# nolint start  # Create some data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ) ) #> Used default patient IDs!  # Initialize a model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get posterior for all model parameters options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Approximate the posterior distribution with a bivariate normal # max.time and maxit are very small only for the purpose of showing the example. They # should be increased for a real case. set.seed(94) approximation <- approximate(   object = samples,   model = model,   data = data,   logNormal = TRUE,   control = list(     threshold.stop = 0.1,     max.time = 1,     maxit = 1   ) ) #> Emini is: 0.1118534587 #> xmini are: #> -0.1336682719 0.008089689073 0.7457629427 0.4895774756 0.08085132146  #> Totally it used 8.7e-05 secs #> No. of function call is: 1 #> Algorithm reached max number of iterations.  posterior <- approximation$model  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/assertions.html","id":null,"dir":"Reference","previous_headings":"","what":"Additional Assertions for checkmate — assertions","title":"Additional Assertions for checkmate — assertions","text":"provide additional assertion functions can used together checkmate functions. described individual help pages linked .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/assertions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Additional Assertions for checkmate — assertions","text":"Depending function prefix. assert_ functions return object invisibly successful, otherwise throw error message. check_ functions return TRUE successful, otherwise string error message. test_ functions just return TRUE FALSE.","code":""},{"path":[]},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/biomarker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"","code":"biomarker(xLevel, model, samples, ...)  # S4 method for class 'integer,DualEndpoint,Samples' biomarker(xLevel, model, samples, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/biomarker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"xLevel (integer) levels doses patients given w.r.t dose grid. See Data details. model (DualEndpoint) model. samples (Samples) samples model's parameters store value biomarker levels doses dose grid. ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/biomarker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"biomarker levels.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/biomarker.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"function simply returns specific columns (indices equal xLevel) biomarker samples matrix, included samples object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/biomarker.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"biomarker(xLevel = integer, model = DualEndpoint, samples = Samples):","code":""},{"path":"https://openpharma.github.io/crmPack/reference/biomarker.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Biomarker Levels for a Given Dual-Endpoint Model, Given Dose Levels and Samples — biomarker","text":"","code":"# Create the data. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 50, 50, 50),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1),   ID = 1:17,   cohort = c(     1L,     2L,     3L,     4L,     5L,     6L,     6L,     6L,     7L,     7L,     7L,     8L,     8L,     8L,     9L,     9L,     9L   ),   w = c(     0.31,     0.42,     0.59,     0.45,     0.6,     0.7,     0.55,     0.6,     0.52,     0.54,     0.56,     0.43,     0.41,     0.39,     0.34,     0.38,     0.21   ),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the Dual-Endpoint model (in this case RW1). my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 500 ) my_samples <- mcmc(my_data, my_model, my_options)  # Obtain the biomarker levels (samples) for the second dose from the dose grid, # which is 0.5. biomarker(   xLevel = 2L,   model = my_model,   samples = my_samples ) #>   [1] 0.3371034 0.3612431 0.4179860 0.3830279 0.3888446 0.3398733 0.3797251 #>   [8] 0.4241814 0.3924223 0.4009581 0.3386207 0.3844423 0.3646142 0.3103187 #>  [15] 0.2239479 0.3692034 0.4088924 0.2859181 0.3998623 0.4061258 0.4590591 #>  [22] 0.5713697 0.4576071 0.5388694 0.4618255 0.3771409 0.4253512 0.4496424 #>  [29] 0.3680105 0.3176516 0.3588777 0.3836673 0.3477051 0.3232797 0.3258889 #>  [36] 0.3079632 0.2453025 0.2813640 0.3614430 0.3759858 0.4338411 0.3798846 #>  [43] 0.2938054 0.3406377 0.3946273 0.3996411 0.4421544 0.4511584 0.4627840 #>  [50] 0.4643824 0.4965061 0.4851126 0.5488315 0.5162410 0.4874223 0.4486016 #>  [57] 0.4750617 0.3574412 0.3075806 0.3295135 0.2733143 0.1929950 0.2471847 #>  [64] 0.2575473 0.3102890 0.4253364 0.4207629 0.3427158 0.4134833 0.4168334 #>  [71] 0.4456964 0.4151854 0.3722371 0.3971003 0.4620173 0.4580512 0.3318005 #>  [78] 0.3040386 0.2342411 0.2705456 0.2990085 0.3302426 0.3900553 0.3766262 #>  [85] 0.3907007 0.4206139 0.4429881 0.4925287 0.4756075 0.4970323 0.4606768 #>  [92] 0.4724840 0.3956490 0.5196185 0.5172512 0.4928490 0.2974632 0.3007917 #>  [99] 0.3490870 0.3658712 0.3107833 0.4164873 0.3613287 0.3619648 0.4301881 #> [106] 0.4821166 0.4074124 0.4741268 0.4103014 0.3574101 0.3582676 0.4227797 #> [113] 0.4464350 0.3788471 0.4234292 0.4082693 0.4136828 0.4435125 0.4266706 #> [120] 0.5029988 0.4750601 0.4508721 0.5205573 0.4920684 0.4830824 0.5205294 #> [127] 0.4496992 0.4855174 0.3592998 0.2941172 0.3968978 0.4779726 0.5075846 #> [134] 0.5267767 0.5004980 0.4680125 0.3239376 0.2967093 0.3862368 0.5095818 #> [141] 0.4849484 0.4450604 0.3800559 0.3551307 0.3680536 0.3749978 0.3607942 #> [148] 0.3568244 0.5113439 0.4262529 0.3134967 0.3652773 0.4145645 0.4315221 #> [155] 0.4097411 0.5255043 0.3942359 0.3999910 0.4493664 0.4680060 0.5265723 #> [162] 0.6228875 0.2950965 0.4573576 0.4811837 0.3732733 0.3352019 0.4335920 #> [169] 0.4098011 0.3197201 0.4510762 0.4037698 0.4828151 0.4653346 0.4535062 #> [176] 0.4484488 0.4575518 0.4516795 0.4435347 0.4716252 0.5417148 0.5344356 #> [183] 0.4567528 0.3411291 0.3664537 0.4150806 0.5076936 0.5405238 0.6347667 #> [190] 0.6668688 0.6761183 0.5609940 0.6724047 0.5717815 0.4367208 0.4231655 #> [197] 0.3931543 0.4630435 0.4082050 0.3921360 0.4131521 0.4287876 0.5051901 #> [204] 0.5077451 0.4102495 0.5287606 0.6128477 0.6335997 0.6579703 0.5542942 #> [211] 0.5305798 0.5680142 0.5468653 0.6351385 0.5431000 0.3788500 0.3438827 #> [218] 0.3431914 0.3071715 0.4160355 0.5022189 0.5216497 0.4896014 0.4969007 #> [225] 0.4944184 0.4010607 0.4466588 0.3866575 0.3123721 0.2726508 0.3534351 #> [232] 0.3440758 0.4634056 0.4176112 0.4593174 0.3915845 0.4737337 0.4444284 #> [239] 0.3898918 0.3239986 0.3262805 0.2440534 0.2498692 0.4010374 0.2695430 #> [246] 0.3371171 0.3819303 0.3494533 0.3317882 0.3561309 0.3996947 0.4881493 #> [253] 0.4916436 0.4281350 0.4160944 0.3818898 0.3420647 0.4437572 0.4034327 #> [260] 0.3676096 0.4087840 0.4230717 0.3952509 0.4019765 0.4924921 0.5250713 #> [267] 0.4563321 0.4099172 0.4860270 0.6142802 0.4943097 0.4106163 0.2919803 #> [274] 0.4336972 0.4562082 0.4558593 0.4030492 0.3928996 0.3337134 0.3736967 #> [281] 0.3906059 0.4375773 0.3543904 0.4629457 0.4286942 0.4124811 0.5612441 #> [288] 0.5037031 0.5032383 0.4763066 0.5693377 0.5561478 0.5786330 0.5273299 #> [295] 0.4951378 0.4422003 0.3779430 0.3200041 0.3120243 0.2814509 0.3246990 #> [302] 0.3636596 0.3589129 0.3767921 0.3113951 0.3945056 0.4038430 0.4514205 #> [309] 0.4644253 0.4994040 0.4413605 0.4081287 0.3768486 0.4008377 0.3770124 #> [316] 0.3628785 0.3616416 0.3313288 0.2734174 0.2363448 0.3643890 0.2783298 #> [323] 0.5022343 0.4899900 0.4248330 0.4398167 0.5174453 0.4242429 0.3429054 #> [330] 0.4523458 0.4521852 0.5538871 0.4664953 0.4089807 0.4425488 0.4533230 #> [337] 0.5084943 0.6247199 0.5699033 0.4626674 0.4465088 0.4344467 0.3826317 #> [344] 0.3842354 0.3215803 0.3833928 0.3468475 0.3612668 0.3665713 0.3497570 #> [351] 0.3135482 0.2612079 0.2046156 0.2834653 0.3981412 0.4631618 0.4588787 #> [358] 0.4064763 0.4105782 0.4157472 0.5156038 0.5149637 0.4905699 0.4776615 #> [365] 0.4054333 0.3596380 0.3691968 0.3575635 0.3752148 0.3689560 0.1418785 #> [372] 0.1584341 0.1988403 0.2713303 0.4349273 0.4282067 0.4636576 0.4405378 #> [379] 0.4763595 0.3711578 0.3980229 0.2634688 0.2886687 0.3687519 0.3396307 #> [386] 0.4134015 0.4130528 0.4107633 0.4317901 0.4319814 0.4342814 0.4058709 #> [393] 0.3845170 0.3696712 0.3669426 0.3485255 0.4795397 0.4736301 0.4878738 #> [400] 0.4200137 0.4021133 0.4810702 0.4812588 0.3835008 0.3728373 0.3862609 #> [407] 0.3841817 0.4826022 0.5970803 0.4714583 0.4446080 0.3701863 0.3533619 #> [414] 0.4603389 0.4431939 0.4366614 0.4205732 0.3561068 0.4142464 0.3719803 #> [421] 0.4233862 0.3742252 0.4476472 0.4290592 0.4243382 0.4370228 0.3802081 #> [428] 0.3816765 0.3492634 0.4201010 0.5010877 0.5729314 0.4851824 0.3719554 #> [435] 0.2185459 0.1773797 0.2895272 0.3814877 0.4888928 0.4333452 0.2901139 #> [442] 0.4053035 0.4289929 0.3605146 0.4107097 0.3724540 0.2881791 0.3884011 #> [449] 0.4509262 0.4318705 0.3191597 0.3125005 0.3639109 0.3179818 0.2958831 #> [456] 0.3429347 0.3176721 0.3404349 0.2999163 0.3344136 0.4036797 0.4131358 #> [463] 0.4526878 0.5250622 0.5510277 0.5361223 0.5377100 0.4596622 0.4373413 #> [470] 0.4857924 0.4211132 0.4385802 0.4372460 0.5197671 0.4459800 0.4939278 #> [477] 0.4599087 0.4789507 0.5087485 0.4819717 0.5207612 0.5217648 0.5418603 #> [484] 0.5190519 0.4147724 0.4985190 0.4058844 0.3387136 0.3274125 0.3778674 #> [491] 0.3627314 0.3638444 0.3467047 0.3486959 0.4883465 0.4690357 0.3530341 #> [498] 0.3351977 0.3497655 0.4344103"},{"path":"https://openpharma.github.io/crmPack/reference/check_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if All Arguments Are Equal — check_equal","title":"Check if All Arguments Are Equal — check_equal","text":"Elements ... must numeric vectors scalars. function performs element--element comparison first object provided ... every object ... returns TRUE comparisons equal within given tolerance FALSE otherwise. Elements ... must numeric vectors scalars. function performs element--element comparison first object provided ... every object ... throws error .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if All Arguments Are Equal — check_equal","text":"","code":"check_equal(..., tol = sqrt(.Machine$double.eps))  assert_equal(   ...,   tol = sqrt(.Machine$double.eps),   .var.name = vname(x),   add = NULL )"},{"path":"https://openpharma.github.io/crmPack/reference/check_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if All Arguments Are Equal — check_equal","text":"... (numeric) vectors compared tol (numeric) maximum difference tolerated judging equality .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if All Arguments Are Equal — check_equal","text":"TRUE element--element differences less tolerance magnitude, FALSE otherwise. list(...), invisibly.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_equal.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check if All Arguments Are Equal — check_equal","text":"missing infinite values ..., function returns FALSE, regardless values elements .... elements ... length, FALSE returned. missing infinite values ..., function throws error, regardless values elements .... elements ... length, error thrown.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/check_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if All Arguments Are Equal — check_equal","text":"","code":"check_equal(1:2, 1:2) # TRUE #> [1] TRUE check_equal(1:2, 2:3) # \"Not all equal\" #> [1] \"Not all equal\" check_equal(Inf, Inf) # \"Not all equal\" #> [1] \"Not all entries finite\" check_equal(0.01, 0.02) # \"Not all equal\" #> [1] \"Not all equal\" check_equal(0.01, 0.02, tol = 0.05) # TRUE #> [1] TRUE check_equal(1, c(1, 1)) # \"Not all equal\" #> [1] \"Not all of same length\" assert_equal(1:2, 1:2) # no error assert_equal(0.01, 0.02, tol = 0.05) # no error"},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/check_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that an argument is a valid format specification — check_format","text":"","code":"check_format(x, len = NULL, min.len = NULL, max.len = NULL)  assert_format(   x,   len = NULL,   min.len = NULL,   max.len = NULL,   .var.name = checkmate::vname(x),   add = NULL )  test_format(x, len = NULL, min.len = NULL, max.len = NULL)  expect_format(   x,   len = NULL,   min.len = NULL,   max.len = NULL,   info = NULL,   label = vname(x) )"},{"path":"https://openpharma.github.io/crmPack/reference/check_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that an argument is a valid format specification — check_format","text":"x [] Object check. len [integer(1)] Exact expected length x. min.len [integer(1)] Minimal length x. max.len [integer(1)] Maximal length x. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that an argument is a valid format specification — check_format","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/check_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that an argument is a valid format specification — check_format","text":"","code":"check_format(\"%5.2f\") #> [1] TRUE"},{"path":"https://openpharma.github.io/crmPack/reference/check_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if vectors are of compatible lengths — check_length","title":"Check if vectors are of compatible lengths — check_length","text":"Two vectors compatible size : least one vector size 1 vectors size.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if vectors are of compatible lengths — check_length","text":"","code":"check_length(x, len)  assert_length(x, len, .var.name = checkmate::vname(x), add = NULL)  test_length(x, len)"},{"path":"https://openpharma.github.io/crmPack/reference/check_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if vectors are of compatible lengths — check_length","text":"x () first vector, object length() function defined. len (count) length second vector. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if vectors are of compatible lengths — check_length","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/check_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if vectors are of compatible lengths — check_length","text":"","code":"check_length(1:5, 1) #> [1] TRUE check_length(1:5, 6) #> [1] \"x is of length 5 which is not allowed; the allowed lengths are: 1 or 6\" check_length(1:5, 5) #> [1] TRUE check_length(10, 1) #> [1] TRUE check_length(10, 9) #> [1] TRUE"},{"path":"https://openpharma.github.io/crmPack/reference/check_probabilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an argument is a probability vector — check_probabilities","title":"Check if an argument is a probability vector — check_probabilities","text":"Check every element given numerical vector matrix represents probability, number within (0, 1) interval, can optionally closed side.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_probabilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an argument is a probability vector — check_probabilities","text":"","code":"check_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE )  assert_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE,   .var.name = checkmate::vname(x),   add = NULL )  test_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE )  expect_probabilities(   x,   bounds_closed = TRUE,   len = NULL,   unique = FALSE,   sorted = FALSE,   info = NULL,   label = vname(x) )"},{"path":"https://openpharma.github.io/crmPack/reference/check_probabilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an argument is a probability vector — check_probabilities","text":"x (numeric) vector matrix numerical values check. bounds_closed (logical) bounds closed? can scalar vector length two. scalar, value applies equally lower bound \\(0\\) upper bound \\(1\\). vector two flags, first flag corresponds lower bound \\(0\\) , second upper bound \\(1\\) . len [integer(1)] Exact expected length x. unique [logical(1)] Must values unique? Default FALSE. sorted [logical(1)] Elements must sorted ascending order. Missing values ignored. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_probabilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an argument is a probability vector — check_probabilities","text":"TRUE successful, otherwise string error message.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_probabilities.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check if an argument is a probability vector — check_probabilities","text":"missing non-finite values x, function returns FALSE, regardless values elements x.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/check_probabilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an argument is a probability vector — check_probabilities","text":"","code":"x <- c(0, 0.2, 0.1, 0.3, 1) check_probabilities(x) #> [1] TRUE check_probabilities(x, bounds_closed = FALSE) #> [1] \"Probability must be within (0, 1) bounds but it is not\" check_probabilities(x, bounds_closed = c(FALSE, TRUE)) #> [1] \"Probability must be within (0, 1] bounds but it is not\""},{"path":"https://openpharma.github.io/crmPack/reference/check_probability.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an argument is a single probability value — check_probability","title":"Check if an argument is a single probability value — check_probability","text":"Check given value represents probability, number within (0, 1) interval, can optionally closed side.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_probability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an argument is a single probability value — check_probability","text":"","code":"check_probability(x, bounds_closed = TRUE)  assert_probability(   x,   bounds_closed = TRUE,   .var.name = checkmate::vname(x),   add = NULL )  test_probability(x, bounds_closed = TRUE)  expect_probability(x, bounds_closed = TRUE, info = NULL, label = vname(x))"},{"path":"https://openpharma.github.io/crmPack/reference/check_probability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an argument is a single probability value — check_probability","text":"x (number) single value check. bounds_closed (logical) bounds closed? can scalar vector length two. scalar, value applies equally lower bound \\(0\\) upper bound \\(1\\). vector two flags, first flag corresponds lower bound \\(0\\) , second upper bound \\(1\\) . .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_probability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an argument is a single probability value — check_probability","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/check_probability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an argument is a single probability value — check_probability","text":"","code":"check_probability(0.5) #> [1] TRUE check_probability(0, bounds_closed = FALSE) #> [1] \"Probability must be within (0, 1) bounds but it is not\" check_probability(0, bounds_closed = c(FALSE, TRUE)) #> [1] \"Probability must be within (0, 1] bounds but it is not\""},{"path":"https://openpharma.github.io/crmPack/reference/check_probability_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an argument is a probability range — check_probability_range","title":"Check if an argument is a probability range — check_probability_range","text":"Check given numerical interval represents probability range, sub-interval (0, 1) interval, can optionally closed side.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_probability_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an argument is a probability range — check_probability_range","text":"","code":"check_probability_range(x, bounds_closed = TRUE)  assert_probability_range(   x,   bounds_closed = TRUE,   .var.name = checkmate::vname(x),   add = NULL )  test_probability_range(x, bounds_closed = TRUE)  expect_probability_range(   x,   bounds_closed = TRUE,   info = NULL,   label = vname(x) )"},{"path":"https://openpharma.github.io/crmPack/reference/check_probability_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an argument is a probability range — check_probability_range","text":"x (number) interval check. bounds_closed (logical) bounds closed? can scalar vector length two. scalar, value applies equally lower bound \\(0\\) upper bound \\(1\\). vector two flags, first flag corresponds lower bound \\(0\\) , second upper bound \\(1\\) . .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_probability_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an argument is a probability range — check_probability_range","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/check_probability_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if an argument is a probability range — check_probability_range","text":"","code":"x <- c(0, 0.2) check_probability_range(x) #> [1] TRUE check_probability_range(rev(x)) #> [1] \"Must be sorted\" check_probability_range(x, bounds_closed = FALSE) #> [1] \"Probability must be within (0, 1) bounds but it is not\" check_probability_range(x, bounds_closed = c(FALSE, TRUE)) #> [1] \"Probability must be within (0, 1] bounds but it is not\""},{"path":"https://openpharma.github.io/crmPack/reference/check_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that an argument is a numerical range — check_range","title":"Check that an argument is a numerical range — check_range","text":"argument x numerical range (conditions must met): object type: integer double. vector length two value first number less second number. Equalness allowed unique flag set TRUE. Lower bound interval greater equal lower upper bound interval less equal upper. contains finite (given finite TRUE) non-missing values.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that an argument is a numerical range — check_range","text":"","code":"check_range(x, lower = -Inf, upper = Inf, finite = FALSE, unique = TRUE)  assert_range(   x,   lower = -Inf,   upper = Inf,   finite = FALSE,   unique = TRUE,   .var.name = checkmate::vname(x),   add = NULL )  test_range(x, lower = -Inf, upper = Inf, finite = FALSE, unique = TRUE)  expect_range(   x,   lower = -Inf,   upper = Inf,   finite = FALSE,   unique = TRUE,   info = NULL,   label = vname(x) )"},{"path":"https://openpharma.github.io/crmPack/reference/check_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that an argument is a numerical range — check_range","text":"x [] Object check. lower [numeric(1)] Lower value elements x must greater equal . upper [numeric(1)] Upper value elements x must lower equal . finite [logical(1)] Check finite values? Default FALSE. unique [logical(1)] Must values unique? Default FALSE. .var.name [character(1)] Name checked object print assertions. Defaults heuristic implemented vname. add [AssertCollection] Collection store assertion messages. See AssertCollection. info [character(1)] Extra information included message testthat reporter. See expect_that. label [character(1)] Name checked object print messages. Defaults heuristic implemented vname.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/check_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that an argument is a numerical range — check_range","text":"TRUE successful, otherwise string error message.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/check_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that an argument is a numerical range — check_range","text":"","code":"check_range(c(1, 5)) #> [1] TRUE check_range(c(-5, 1)) #> [1] TRUE check_range(c(4, 1)) #> [1] \"x must be a valid numerical range. Must be sorted\" check_range(c(1, 1)) #> [1] \"x must be a valid numerical range. Contains duplicated values, position 2\" check_range(c(1, 1), unique = FALSE) #> [1] TRUE check_range(1:3) #> [1] \"x must be a valid numerical range. Must have length 2, but has length 3\""},{"path":"https://openpharma.github.io/crmPack/reference/crmPack.html","id":null,"dir":"Reference","previous_headings":"","what":"Object-oriented implementation of CRM designs — crmPack","title":"Object-oriented implementation of CRM designs — crmPack","text":"Object-oriented implementation CRM designs","code":""},{"path":"https://openpharma.github.io/crmPack/reference/crmPack.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Object-oriented implementation of CRM designs — crmPack","text":"Sabanes Bove D, Yeung WY, Palermo G, Jaki T (2019). \"Model-Based Dose Escalation Designs R crmPack.\" Journal Statistical Software, 89(10), 1-22. doi:10.18637/jss.v089.i10 (URL: http://doi.org/10.18637/jss.v089.i10).","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/crmPack.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Object-oriented implementation of CRM designs — crmPack","text":"Maintainer: Daniel Sabanes Bove daniel.sabanes_bove@rconis.com Authors: Wai Yin Yeung winnie.yeung@roche.com Burak Kuersad Guenhan burakgunhan@gmail.com Giuseppe Palermo giuseppe.palermo@roche.com Thomas Jaki jaki.thomas@gmail.com Jiawen Zhu zhu.jiawen@gene.com Ziwei Liao ziwei.liao.fdu@gmail.com Dimitris Kontos dimitris.kontos@bayer.com Marlene Schulte-Goebel marlene.schulte-goebel@merckgroup.com Doug Kelkhoff doug.kelkhoff@roche.com (ORCID) Oliver Boix oliver.boix@bayer.com Robert Adams robert.adams@bayer.com Clara Beck clara.beck@bayer.com John Kirkpatrick john.kirkpatrick@roche.com contributors: F. Hoffmann-La Roche AG [copyright holder, funder] Merck Healthcare KGaA [copyright holder, funder] Bayer AG [copyright holder, funder]","code":""},{"path":"https://openpharma.github.io/crmPack/reference/crmPackExample.html","id":null,"dir":"Reference","previous_headings":"","what":"Open the example pdf for crmPack — crmPackExample","title":"Open the example pdf for crmPack — crmPackExample","text":"Calling helper function open example.pdf document, residing doc subfolder package installation directory.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/crmPackExample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open the example pdf for crmPack — crmPackExample","text":"","code":"crmPackExample()"},{"path":"https://openpharma.github.io/crmPack/reference/crmPackExample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Open the example pdf for crmPack — crmPackExample","text":"nothing","code":""},{"path":"https://openpharma.github.io/crmPack/reference/crmPackExample.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Open the example pdf for crmPack — crmPackExample","text":"Daniel Sabanes Bove sabanesd@rconis.com","code":""},{"path":"https://openpharma.github.io/crmPack/reference/crmPackHelp.html","id":null,"dir":"Reference","previous_headings":"","what":"Open the browser with help pages for crmPack — crmPackHelp","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"convenience function opens browser help pages crmPack.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/crmPackHelp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"","code":"crmPackHelp()"},{"path":"https://openpharma.github.io/crmPack/reference/crmPackHelp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"nothing","code":""},{"path":"https://openpharma.github.io/crmPack/reference/crmPackHelp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Open the browser with help pages for crmPack — crmPackHelp","text":"Daniel Sabanes Bove sabanesd@rconis.com","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a Function to Subsets of Data Frame. — dapply","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"dapply splits data df subsets defined f, applies function FUN subset. results row-binded returned data.frame object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"","code":"dapply(df, f, FUN, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/dapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"df (data frame) data set divided groups. f (factor formula list) factor sense .factor(f) defines grouping, list factors case interaction used grouping. f can also formula form ~ g1 + ... + gk split interaction variables g1, ..., gk. parameter passed directly split() function. FUN (function) function applied subset df defined f. ... parameters passed lapply(), used applying function FUN groups defined f.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"data.frame object results FUN.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a Function to Subsets of Data Frame. — dapply","text":"","code":"df <- data.frame(   dose = c(0.1, 6, 6, 5, 0.1, 5, 6, 6),   cohort = c(\"B\", \"B\", \"B\", \"A\", \"A\", \"A\", \"B\", \"B\") )  dapply(   df,   f = ~cohort,   FUN = function(coh) {     data.frame(my_cohort = coh$cohort[1], my_max = max(coh$dose))   } ) #>   my_cohort my_max #> 1         A      5 #> 2         B      6  dapply(   df,   f = ~cohort,   FUN = function(coh) {     coh$dose <- sort(coh$dose, decreasing = TRUE)     coh   } ) #>   dose cohort #> 1  5.0      A #> 2  5.0      A #> 3  0.1      A #> 4  6.0      B #> 5  6.0      B #> 6  6.0      B #> 7  6.0      B #> 8  0.1      B"},{"path":"https://openpharma.github.io/crmPack/reference/dinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the density of Inverse gamma distribution — dinvGamma","title":"Compute the density of Inverse gamma distribution — dinvGamma","text":"Compute density Inverse gamma distribution","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the density of Inverse gamma distribution — dinvGamma","text":"","code":"dinvGamma(x, a, b, log = FALSE, normalize = TRUE)"},{"path":"https://openpharma.github.io/crmPack/reference/dinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the density of Inverse gamma distribution — dinvGamma","text":"x vector quantiles shape parameter inverse gamma distribution b scale parameter inverse gamma distribution log logical; TRUE, probabilities p given log(p) normalize logical; TRUE, output normalized","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dose.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing the Doses for a given independent variable, Model and Samples — dose","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"function computes dose reaching specific target value given variable dose depends . meaning variable depends type model. instance, single agent dose escalation model pseudo DLE (dose-limiting events)/toxicity model, variable represents probability occurrence DLE. efficacy models, represents expected efficacy. doses computed based samples model parameters (samples).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"","code":"dose(x, model, samples, ...)  # S4 method for class 'numeric,LogisticNormal,Samples' dose(x, model, samples)  # S4 method for class 'numeric,LogisticLogNormal,Samples' dose(x, model, samples)  # S4 method for class 'numeric,LogisticLogNormalOrdinal,Samples' dose(x, model, samples, grade)  # S4 method for class 'numeric,LogisticLogNormalSub,Samples' dose(x, model, samples)  # S4 method for class 'numeric,ProbitLogNormal,Samples' dose(x, model, samples)  # S4 method for class 'numeric,ProbitLogNormalRel,Samples' dose(x, model, samples)  # S4 method for class 'numeric,LogisticLogNormalGrouped,Samples' dose(x, model, samples, group)  # S4 method for class 'numeric,LogisticKadane,Samples' dose(x, model, samples)  # S4 method for class 'numeric,LogisticKadaneBetaGamma,Samples' dose(x, model, samples)  # S4 method for class 'numeric,LogisticNormalMixture,Samples' dose(x, model, samples)  # S4 method for class 'numeric,LogisticNormalFixedMixture,Samples' dose(x, model, samples)  # S4 method for class 'numeric,LogisticLogNormalMixture,Samples' dose(x, model, samples)  # S4 method for class 'numeric,DualEndpoint,Samples' dose(x, model, samples)  # S4 method for class 'numeric,LogisticIndepBeta,Samples' dose(x, model, samples)  # S4 method for class 'numeric,LogisticIndepBeta,missing' dose(x, model)  # S4 method for class 'numeric,Effloglog,missing' dose(x, model)  # S4 method for class 'numeric,EffFlexi,Samples' dose(x, model, samples)  # S4 method for class 'numeric,OneParLogNormalPrior,Samples' dose(x, model, samples)  # S4 method for class 'numeric,OneParExpPrior,Samples' dose(x, model, samples)"},{"path":"https://openpharma.github.io/crmPack/reference/dose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"x (proportion numeric) value independent variable dose depends. following recycling rule applies samples missing: vectors size 1 recycled size sample (.e. size(samples)). Otherwise, x must size sample. model (GeneralModel ModelPseudo) model. samples (Samples) samples model's parameters used compute resulting doses. Can also missing models. ... model specific parameters samples used. grade (integer) toxicity grade probabilities required group (character factor) LogisticLogNormalGrouped, indicating whether calculate dose mono combo arm.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"number numeric vector doses. non-scalar samples used, every element returned vector corresponds one element sample. Hence, case, output vector length sample vector. scalar samples used samples used, e.g. pseudo DLE/toxicity model, output length length prob.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"dose() function computes doses corresponding value given independent variable, using samples model parameter(s). work multivariate model parameters, assume model specific dose() method receives samples matrix rows correspond sampling index, .e. layout nSamples x dimParameter.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dose.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"dose(x = numeric, model = LogisticNormal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormalOrdinal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). case LogisticLogNormalOrdinal model, dose returns probability toxicity given grade higher dose(x = numeric, model = LogisticLogNormalSub, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = ProbitLogNormal, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = ProbitLogNormalRel, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormalGrouped, samples = Samples): method LogisticLogNormalGrouped needs group argument addition. dose(x = numeric, model = LogisticKadane, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticKadaneBetaGamma, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticNormalMixture, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticNormalFixedMixture, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticLogNormalMixture, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = DualEndpoint, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticIndepBeta, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). dose(x = numeric, model = LogisticIndepBeta, samples = missing): compute dose level reaching specific target probability occurrence DLE (x). model parameters (except x) present model object. dose(x = numeric, model = Effloglog, samples = missing): compute dose level reaching specific target probability occurrence DLE (x). model parameters (except x) present model object. dose(x = numeric, model = EffFlexi, samples = Samples): compute dose level reaching specific target probability occurrence DLE (x). method x must scalar. dose(x = numeric, model = OneParLogNormalPrior, samples = Samples): compute dose level reaching specific target probability occurrence DLT (x). dose(x = numeric, model = OneParExpPrior, samples = Samples): compute dose level reaching specific target probability occurrence DLT (x).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dose.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"dose() prob() methods inverse , dose() methods first argument, .e. given independent variable dose depends , represents toxicity probability.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/dose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing the Doses for a given independent variable, Model and Samples — dose","text":"","code":"# Create some data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize a model, e.g. 'LogisticLogNormal'. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get samples from posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 20) my_samples <- mcmc(data = my_data, model = my_model, options = my_options)  # Posterior for the dose achieving Prob(DLT) = 0.45. dose(x = 0.45, model = my_model, samples = my_samples) #>  [1] 40.493866 40.493866  7.512803 12.792543 18.504052 26.719103 21.527861 #>  [8] 21.527861 36.939326 36.893146 25.383489 53.057645 53.057645 53.057645 #> [15] 53.057645 53.057645 53.057645 61.390126 61.390126 61.390126  # Create data from the 'Data' (or 'DataDual') class. dlt_data <- Data(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize a toxicity model using 'LogisticIndepBeta' model. dlt_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = dlt_data )  # Get samples from posterior. dlt_sample <- mcmc(data = dlt_data, model = dlt_model, options = my_options)  # Posterior for the dose achieving Prob(DLT) = 0.45. dose(x = 0.45, model = dlt_model, samples = dlt_sample) #>  [1]  5.394717e+07 2.079593e-131 2.079593e-131 2.079593e-131 2.079593e-131 #>  [6]  2.103099e+01  2.103099e+01  1.875484e+02  3.718879e+01  3.718879e+01 #> [11]  3.718879e+01  3.718879e+01  3.718879e+01  3.718879e+01  3.718879e+01 #> [16]  3.718879e+01  3.718879e+01  3.718879e+01  3.718879e+01  6.519215e+01 dose(x = c(0.45, 0.6), model = dlt_model) #> [1] 144.6624 247.7348 data_ordinal <- .DefaultDataOrdinal() model <- .DefaultLogisticLogNormalOrdinal() options <- .DefaultMcmcOptions() samples <- mcmc(data_ordinal, model, options) #> Warning: Unused variable \"y\" in data  dose(0.25, model, samples, grade = 2L) #>    [1]     73.66230     69.26277     57.59442   1704.54535     68.37459 #>    [6]     72.49957     93.01406     68.42297     56.50985     71.65370 #>   [11]    236.50583     58.02286     85.03834    124.68054     62.67019 #>   [16]     59.22934     83.91917     56.76817     72.00571     84.45083 #>   [21]     51.07953     90.33918     78.38532    126.59324     78.63263 #>   [26]     65.13993    220.47526     55.86311     95.05210     71.45512 #>   [31]     56.97830     69.63138     60.60269     81.14534    137.50123 #>   [36]     57.70894     82.30123    510.69889     60.07097     57.10846 #>   [41]    114.40048     64.07634     62.73175     57.83157     59.55051 #>   [46]     63.71861     66.07862     70.98497     55.16552     81.71818 #>   [51]     55.31332     48.87363     56.64099     64.21779     60.63302 #>   [56]     88.29682     68.86609     90.30877     77.70827     60.63826 #>   [61]     56.60644   3348.92475    104.78654     77.96074     87.71052 #>   [66]    192.16169     56.15453    326.23192    257.32668     58.99669 #>   [71]     58.90379     66.25331     66.06290     67.60811     92.70238 #>   [76]     89.11290     60.56974    213.11583     52.86751     66.40387 #>   [81]     60.81547     85.95668    316.74803     69.86720     55.90505 #>   [86]     73.06936     56.94708    229.59636     82.80834    150.70727 #>   [91]     71.22524     55.18455     69.06112     95.09190     56.62639 #>   [96]     59.89266    151.12009    157.88905    164.02769     83.03914 #>  [101]     56.98886    223.17481    117.18259    233.30130     70.76530 #>  [106]     64.21175     54.91049     66.59958     65.16131     98.28926 #>  [111]     61.76182    115.86646     82.67969     55.25337     61.02278 #>  [116]     90.69566     64.60395     61.10110     70.84422    169.91412 #>  [121]    125.67825    105.42267     59.32554    134.75350    115.66464 #>  [126]     87.39917     60.77381     58.95959     79.68716     68.37905 #>  [131]     67.47516     74.69404    105.71430    466.04187    493.30903 #>  [136]    184.76111    114.25383     56.10753    101.91046    166.40944 #>  [141]     91.99249     55.96758    233.07314     64.71913     59.43801 #>  [146]     60.22698     66.85596     71.55594     52.08734     89.32950 #>  [151]     61.90924     65.08408     66.32021     77.00142     69.39533 #>  [156]     96.48256     64.45940     60.09359    352.41319     71.17260 #>  [161]    106.98586     90.30308     34.35364     60.71151     55.30000 #>  [166]    101.73137     67.81308     65.94731     89.00445     66.47955 #>  [171]     54.38406    118.05578     57.84685     61.08405     69.18871 #>  [176]    433.27363     54.78052     65.26440     65.18460     63.16588 #>  [181]     58.62861     56.35566     82.63933     56.71769     66.13502 #>  [186]     91.90259    184.19647     72.06477   2712.38833    259.40090 #>  [191]     70.01057     73.23670    269.08685     56.37168     67.76700 #>  [196]    119.31634     57.42933     62.03615     57.64953     75.50439 #>  [201]     63.83885     64.45479     96.16514     99.89426     83.92075 #>  [206]     65.75495     65.25733     60.10781     80.54901     74.46646 #>  [211]     59.08171     79.31018     50.45503     61.29202     61.26706 #>  [216]    684.10048 125588.97078     54.86099     72.69125     61.15184 #>  [221]     53.04566     71.68558     61.06284     71.54624     55.77658 #>  [226]     62.20153     60.50178     62.64950     67.10352    312.91555 #>  [231]     85.85958     77.65476     75.06240     64.25381     87.91142 #>  [236]     81.98799     79.49371     65.62862     63.83726     62.20223 #>  [241]     59.45575     55.26435    134.93755     78.65843     56.31494 #>  [246]     85.72197     79.74544     61.78465     76.05769     53.61656 #>  [251]     61.31529     59.46037     66.57263    541.88060     53.48825 #>  [256]     58.22751     88.21486     74.07987     59.07920     62.49947 #>  [261]     74.04982    100.48804     77.79006    124.14566     85.04816 #>  [266]    112.32775     61.28987     65.15541     57.32175     69.69784 #>  [271]     96.27825     60.53126     65.22544     66.26503     66.18753 #>  [276]     76.95749    110.34424     61.96223     66.75781    136.85564 #>  [281]     68.52302     66.78708     63.27885     58.19341     59.13017 #>  [286]     63.75064     63.85403     56.58262     64.84515     62.67146 #>  [291]     58.55530    110.67878     73.52252    119.85030     56.69375 #>  [296]     69.88390     64.22673     96.97613     57.25150     57.35856 #>  [301]     69.54398     67.03323     64.88836     75.87158     87.82359 #>  [306]     75.42379     62.87027     60.15729     59.61207     58.02553 #>  [311]     61.46639     65.57148    116.17122     58.14487     76.03824 #>  [316]     56.89064     63.69498     62.18996     68.55945    147.38409 #>  [321]    140.58809     62.85045     67.18886     57.41990     71.48539 #>  [326]    269.35587     65.70937     62.84875     98.38187     62.53127 #>  [331]     62.21631     60.83539    206.90891     58.31061     83.60993 #>  [336]     57.17499     56.60213     49.85990     49.95221     70.53660 #>  [341]     64.85082     67.03594     68.94721     66.04801    216.77807 #>  [346]    391.20308     67.38458    458.52970     64.88908     57.33450 #>  [351]     64.47459    202.83900     69.08884     59.49876     67.37488 #>  [356]    124.99206     63.04376     69.14540     60.07025     59.97225 #>  [361]     58.64680     56.62132     67.43088     93.62524     79.02131 #>  [366]     63.49714     70.39393     60.91224     58.22117     66.84625 #>  [371]     66.11343     70.59447     73.66638     62.26269     64.91867 #>  [376]     65.89189     56.82182     62.94749     69.31141     58.24190 #>  [381]     58.65377     99.61511     64.42957   1273.18660    275.77212 #>  [386]     59.60402     73.92633     98.73915    108.69699     96.87222 #>  [391]     70.58591     66.16373     56.17783     60.74806     55.17121 #>  [396]    196.15881   7617.03989    367.61931     75.28948     65.01095 #>  [401]     67.45162     61.32855     57.35474     59.22911    110.20813 #>  [406]     68.17671     50.29656    155.88172     64.73183     62.01176 #>  [411]     57.33297     63.32329     78.34419     78.54664     94.97828 #>  [416]    137.29963     68.53785     87.30185     59.36019     80.82771 #>  [421]    145.83431     64.95279     65.85945     56.22525    156.34437 #>  [426]    144.94279     87.58744     55.84031    175.04560     76.60735 #>  [431]     91.93098     61.71106    106.82275     47.07363     56.86245 #>  [436]     63.32223     55.25737     61.20438     59.42152     63.10895 #>  [441]     63.25584     56.69941     61.08349     69.67773    133.61421 #>  [446]     50.32303    103.67574     54.34509     81.40603     52.10781 #>  [451]     60.18460     76.30930    240.13688     56.06697     71.49599 #>  [456]     66.90533     69.90658     63.82145     66.69280     65.73983 #>  [461]     57.53825    101.51712     84.72693     59.75971    108.06856 #>  [466]     54.53290     64.43021     65.71066     87.84433     90.56814 #>  [471]     53.32416     64.55572     85.07332     62.34948     89.31309 #>  [476]     61.83713    186.82011     57.74272     76.31666    100.22656 #>  [481]     59.81524     67.46571     57.12879     58.97224     63.12918 #>  [486]    235.18130     53.72897     77.92087     73.63278     65.79782 #>  [491]     45.99006     88.38506     67.71518    102.56190     72.13501 #>  [496]    123.81899     59.71263     55.20859     62.71620     47.03296 #>  [501]    195.21747     74.04662     64.22708     56.32755     70.46578 #>  [506]     66.58731    174.65387     66.33559     89.14232     57.45372 #>  [511]     81.63275     67.16816     66.70249   2593.64468     62.94872 #>  [516]     56.02555     59.34476     59.75908     63.47112     77.82971 #>  [521]     61.97228     53.17268    355.37900     54.75835     54.56521 #>  [526]    102.61184     58.81921     68.54321     60.50392     63.91485 #>  [531]     69.11015     72.83952     70.11399     61.20843     57.34797 #>  [536]     68.32667     60.41456     60.83553     67.64407     58.81016 #>  [541]     60.44918     65.52636     96.48326     82.72745    316.82802 #>  [546]    116.07789     79.40569     59.74395     61.09315     69.21221 #>  [551]     78.86254     86.21891     64.49488    258.10848     82.58363 #>  [556]     53.52633     71.28436    103.95103     97.75764     64.37696 #>  [561]     66.43180     63.45975     61.73063    141.13243     59.47126 #>  [566]     55.71237     78.73690     71.00576     59.04138     68.26574 #>  [571]     63.88703     63.59623     69.24602     56.22134     60.99221 #>  [576]     75.97619     75.37319     58.60052     67.92292     59.70723 #>  [581]     60.22697     56.82662     73.22599     79.17320     78.11693 #>  [586]     91.36390     56.17136     62.48515    139.30124     57.65474 #>  [591]     57.08988     90.64164     58.69616     79.61003     87.96608 #>  [596]     54.42863     87.58153     60.04713    386.42720     64.67218 #>  [601]   1344.15585    105.35303     53.17148     63.85646     61.49639 #>  [606]    105.55264     70.60394    328.80293     67.82127     65.40968 #>  [611]     76.96335     54.53956     67.24639     68.35548    106.57456 #>  [616]    274.43754     72.38917     79.64056     73.78753    137.83016 #>  [621]     90.85752     68.65081     78.95017     82.86169     54.06917 #>  [626]     57.64584     58.44948     57.22949    383.80301     71.84268 #>  [631]     66.35483     57.35032     63.04611     85.59008     72.07504 #>  [636]     47.10333     77.69493     75.15503 447180.53188    101.52143 #>  [641]     77.05093     58.13227     75.78509     74.56498     58.74983 #>  [646]     65.89011     83.16628    125.15412    107.13210     61.98301 #>  [651]     87.82134     54.72018     62.50879     66.81358     57.39415 #>  [656]     58.30040    168.25578     62.26389     55.57422     63.45121 #>  [661]     70.72448     92.93597    189.44538     60.96411    171.50235 #>  [666]    132.18045    192.25903 111534.46324     58.91132     57.27441 #>  [671]     61.03208     62.47845     74.18122     58.22614     77.52573 #>  [676]     62.59004     67.44565     59.87873     78.19023     61.76724 #>  [681]     63.22311     66.39821     67.15459    162.27491     52.77743 #>  [686]     62.07866    214.88586    116.43889     60.46029    266.54482 #>  [691]    103.47591    166.33405     45.90229  19740.73799     56.09811 #>  [696]     90.73203     73.70715     69.45934     91.10970    100.72497 #>  [701]     61.25575     96.95800     56.82460    131.46449     62.97592 #>  [706]     59.48042     59.23179    103.88843     61.37033     56.74065 #>  [711]     80.61195     58.42525     66.36798     85.22887     60.00980 #>  [716]     58.93401   1317.50295     83.99669     74.23507    103.51552 #>  [721]    339.41402   3461.88351     67.40042     66.48526     90.44208 #>  [726]     68.00774     65.20286     72.92188     57.00445     89.55268 #>  [731]     77.53582     63.08234     70.46860     59.47465   1094.75352 #>  [736] 290325.87487     55.06420     62.16590     62.69175     60.89598 #>  [741]     67.72073     60.81620     88.13502     71.46510    104.02018 #>  [746]    164.19494     62.50945     57.71116     61.64072    115.13178 #>  [751]     55.65093    149.98887     60.40962     71.78578     61.13672 #>  [756]    112.20444     32.10063     53.08265     90.15989     59.86848 #>  [761]     64.74720    248.41838     86.97684     66.99691     56.79480 #>  [766]     73.83534     68.59173     56.16719     72.86575     53.21174 #>  [771]    179.00437   1547.99005    119.95044    172.95891     60.68146 #>  [776]     69.39932     68.56010    132.04498    288.07309     62.81031 #>  [781]     70.48359    192.43203     94.89130     81.89913     58.52946 #>  [786]     56.74639     58.20735     74.45761     86.56999     82.30156 #>  [791]     86.30369     60.89093     68.23862     77.49254    161.50348 #>  [796]     81.42909     92.61300     59.97505     68.46701    554.44949 #>  [801]     83.39131     76.58830     60.35380     63.48036     90.90950 #>  [806]     54.20058     68.61400    139.99630     66.46338     82.95579 #>  [811]     57.80437     62.41841     55.93714     60.92197     87.44683 #>  [816]     62.79058     64.50641     93.95511     62.02129     60.76295 #>  [821]     91.20613    997.69214     59.33081     69.99671     61.70361 #>  [826]    147.70791     62.29546     60.64446     55.38301     60.64499 #>  [831]     79.39925     62.86452    178.40487     56.53996     81.05218 #>  [836]     63.63550     62.43104     58.23519     87.30027     81.06955 #>  [841]     60.12935     58.37472     68.30636     63.16514    156.88997 #>  [846]     62.32426    665.29940     63.45197     72.58775     80.83724 #>  [851]     57.64544     69.73311     53.47138     64.08106     59.91950 #>  [856]     60.08590     76.11023     62.05264     67.96529     72.79313 #>  [861]     56.11559     63.35373     98.72450     58.73221     59.03936 #>  [866]     73.10128     65.84889    125.86223    104.55941     71.88174 #>  [871]     73.99823    162.34180    147.52333     52.06619     58.70678 #>  [876]     61.13634     75.78282     65.40518     66.20355     60.52378 #>  [881]     64.95695     50.24134     60.44630     58.36142     63.71495 #>  [886]     66.04930     65.73076    188.03567     61.11172   7021.76411 #>  [891]    886.12213    370.31969     68.96821     57.63396     60.11063 #>  [896]     80.83049     58.80160     65.03967    104.72334     57.95784 #>  [901]     95.51289     73.18359     70.46360     73.74960     68.46814 #>  [906]     59.63259     64.30971    162.89408   2567.04392     67.57930 #>  [911]     71.82496     58.50489     83.81590     64.81648    314.28942 #>  [916]     58.28143     48.82894     59.46944     75.77824    219.20774 #>  [921]     59.54940   1196.09438     54.41340     86.78721    139.42532 #>  [926]     60.53653     55.81262     72.51396     68.76208     60.68540 #>  [931]     70.66051     70.34233     54.57643     53.40609     68.93799 #>  [936]     69.83915     53.66088     57.42238     82.76626     68.80675 #>  [941]     57.82741     89.33259     62.81965     81.70339     63.34807 #>  [946]    105.04055     48.63576     56.65990     66.14872     61.62150 #>  [951]     65.58307    221.75893     66.20692     78.41180     66.42122 #>  [956]     58.67807     61.49687     60.39617    177.81825     55.59001 #>  [961]   1298.41300     81.70301     54.08650    106.70478     55.09018 #>  [966]     61.03986     68.04569     60.45424     80.04277    101.29138 #>  [971]     57.04234     56.27361    127.75347     65.49210     65.02804 #>  [976]     67.36004     61.91943     56.62186     53.97333     67.66413 #>  [981]     60.86066     61.22153     75.80496     59.59299     67.37957 #>  [986]     61.10462     69.90964    126.92044     87.83838     90.72487 #>  [991]     62.32689     49.10158    106.37769     58.18780     66.63488 #>  [996]     71.41387     58.58332     73.58539     58.31074     57.39207"},{"path":"https://openpharma.github.io/crmPack/reference/doseFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Dose Function for a Given Model Type — doseFunction","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"function returns dose() method computes dose reaching specific target value given independent variable, based model specific parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/doseFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"","code":"doseFunction(model, ...)  # S4 method for class 'GeneralModel' doseFunction(model, ...)  # S4 method for class 'ModelPseudo' doseFunction(model, ...)  # S4 method for class 'LogisticLogNormalOrdinal' doseFunction(model, grade, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/doseFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"model (GeneralModel ModelPseudo) model. ... model specific parameters. grade (integer) toxicity grade dose function required","code":""},{"path":"https://openpharma.github.io/crmPack/reference/doseFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"dose() method computes doses.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/doseFunction.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"doseFunction(GeneralModel): doseFunction(ModelPseudo): doseFunction(LogisticLogNormalOrdinal):","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/doseFunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Dose Function for a Given Model Type — doseFunction","text":"","code":"my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  dose_fun <- doseFunction(my_model, alpha0 = 2, alpha1 = 3) dose_fun(0.6) #> [1] 29.38579 data_ordinal <- .DefaultDataOrdinal() model <- .DefaultLogisticLogNormalOrdinal() options <- .DefaultMcmcOptions() suppressWarnings({   samples <- mcmc(data_ordinal, model, options) })  doseFunction(   model,   alpha1 = samples@data$alpha2,   beta = samples@data$beta,   grade = 1L )(x = 0.75) #>    [1] 8.088542e+01 6.526374e+01 6.423585e+01 7.016567e+01 6.614313e+01 #>    [6] 8.761114e+01 1.145361e+02 7.429762e+01 6.396176e+01 6.825156e+01 #>   [11] 9.726337e+01 7.079898e+01 7.054038e+01 8.281558e+01 8.861650e+01 #>   [16] 7.637561e+01 6.911731e+01 1.586582e+02 7.379398e+01 8.811966e+01 #>   [21] 1.512752e+02 2.056158e+04 3.214743e+10 9.136274e+02 2.731080e+02 #>   [26] 5.195823e+05 2.262167e+03 8.839906e+01 1.061657e+02 1.625132e+02 #>   [31] 1.222100e+02 2.559043e+02 3.006484e+02 7.410065e+03 3.559648e+06 #>   [36] 6.920985e+01 1.339907e+03 9.745870e+02 6.508967e+01 6.660966e+01 #>   [41] 1.166486e+02 1.378422e+02 1.491551e+03 2.718303e+02 9.424560e+01 #>   [46] 7.189019e+01 1.687848e+02 3.419021e+02 9.845500e+01 1.041935e+02 #>   [51] 1.182198e+02 7.973810e+01 1.165271e+02 1.312016e+02 2.256728e+03 #>   [56] 7.159261e+01 8.728874e+01 6.017251e+01 7.526322e+01 6.947818e+01 #>   [61] 6.806674e+01 7.089915e+01 6.201432e+01 7.216540e+01 6.525281e+01 #>   [66] 7.797341e+01 7.123089e+01 1.034336e+02 1.060941e+02 8.595497e+01 #>   [71] 8.357203e+01 8.157153e+01 7.069744e+01 7.246675e+01 1.452543e+02 #>   [76] 8.653516e+01 8.391325e+01 2.082984e+02 4.984184e+02 1.569491e+02 #>   [81] 1.060313e+02 7.577691e+01 7.687584e+01 6.984732e+01 7.636875e+01 #>   [86] 1.064553e+02 9.836703e+01 8.759670e+01 7.192436e+01 1.146047e+02 #>   [91] 8.237717e+01 7.863289e+03 8.061916e+01 6.271298e+01 9.093194e+01 #>   [96] 1.486078e+02 7.057372e+01 7.437486e+01 7.681231e+01 1.106089e+02 #>  [101] 9.414640e+01 1.006084e+10 2.168571e+02 1.017828e+02 2.856925e+02 #>  [106] 6.426427e+01 1.109010e+02 1.327511e+02 1.088988e+02 6.911849e+01 #>  [111] 6.406160e+01 7.039526e+01 2.658643e+02 8.467138e+01 1.126238e+02 #>  [116] 7.223356e+04 4.032884e+02 2.035563e+02 7.353260e+01 2.258434e+02 #>  [121] 3.206213e+02 7.878215e+01 8.033806e+01 1.064639e+02 1.474816e+02 #>  [126] 1.158840e+02 8.835304e+01 7.622925e+01 1.236275e+02 1.245449e+02 #>  [131] 9.320678e+01 6.385945e+01 1.136671e+02 1.629016e+02 6.393654e+01 #>  [136] 7.844311e+01 8.997814e+01 8.005474e+01 1.117432e+02 8.589448e+01 #>  [141] 9.016836e+01 6.456690e+01 7.329743e+01 6.641966e+01 9.072655e+01 #>  [146] 1.104810e+02 7.902965e+01 9.178003e+01 6.618946e+01 6.847861e+01 #>  [151] 1.233603e+02 6.649200e+01 1.677785e+02 1.001228e+02 8.327287e+01 #>  [156] 1.004387e+02 1.492086e+02 2.428524e+07 1.040857e+02 1.207005e+02 #>  [161] 8.142220e+01 1.061712e+02 7.279288e+01 1.155229e+02 1.963836e+02 #>  [166] 7.085766e+01 2.756753e+04 5.766689e+02 1.329835e+02 8.217253e+01 #>  [171] 1.016916e+02 1.081678e+02 1.936538e+02 3.230871e+02 6.482128e+01 #>  [176] 2.395914e+02 7.496587e+01 1.977601e+02 8.317286e+01 1.207636e+02 #>  [181] 1.124979e+02 8.978052e+01 7.533701e+01 9.530781e+01 2.049538e+02 #>  [186] 1.640943e+03 1.071631e+02 9.827097e+01 1.574924e+03 6.352970e+01 #>  [191] 8.369980e+01 1.189850e+02 1.033914e+02 1.013421e+02 8.280190e+01 #>  [196] 1.077433e+02 6.773889e+01 1.210067e+02 7.258562e+01 8.317524e+01 #>  [201] 7.092547e+01 1.568899e+02 1.076447e+02 6.016841e+01 7.056310e+01 #>  [206] 8.940077e+01 7.897180e+01 9.582460e+01 1.013782e+02 1.006924e+02 #>  [211] 7.133396e+01 8.008434e+01 8.715422e+01 7.081370e+01 7.628385e+01 #>  [216] 3.808454e+02 7.161218e+01 6.818916e+01 6.961031e+01 6.411388e+01 #>  [221] 1.030737e+02 1.138472e+02 6.471096e+01 6.545447e+01 6.667873e+01 #>  [226] 6.878787e+01 6.808600e+01 1.451078e+02 7.984118e+01 7.192185e+01 #>  [231] 1.622707e+03 6.714005e+01 6.196531e+01 7.566720e+01 7.337564e+01 #>  [236] 6.866165e+01 8.302885e+01 3.194738e+02 1.339659e+02 2.279043e+02 #>  [241] 1.000110e+02 8.505729e+01 1.170796e+02 8.575316e+01 8.480683e+01 #>  [246] 9.153033e+01 1.073862e+02 1.012009e+02 1.038167e+02 1.467297e+02 #>  [251] 7.523727e+01 7.989088e+01 7.446240e+01 6.279254e+01 1.311414e+02 #>  [256] 7.319487e+01 1.665424e+02 7.163812e+01 1.162350e+02 9.811734e+01 #>  [261] 9.965999e+01 1.863009e+02 2.184171e+02 2.038123e+02 8.317629e+01 #>  [266] 6.579152e+01 8.486933e+01 8.013723e+01 9.345607e+01 7.148557e+01 #>  [271] 9.088733e+02 1.290383e+02 7.521956e+01 1.141700e+02 6.713624e+01 #>  [276] 1.074941e+02 1.166605e+02 6.196515e+01 9.001161e+01 8.464399e+01 #>  [281] 6.568346e+01 8.601216e+01 9.600900e+01 8.276927e+01 7.515835e+01 #>  [286] 1.021220e+02 1.000419e+02 9.205427e+01 7.448245e+01 1.069771e+02 #>  [291] 7.200893e+01 6.898342e+01 6.285374e+01 5.250267e+02 6.847436e+02 #>  [296] 1.482851e+02 8.200383e+01 7.667577e+01 7.005604e+01 7.276443e+03 #>  [301] 1.048703e+02 6.686914e+01 1.333323e+02 8.158693e+01 1.175960e+02 #>  [306] 6.319126e+01 7.129765e+01 8.521615e+01 2.021536e+02 8.279574e+01 #>  [311] 8.072133e+01 8.918237e+01 6.840172e+01 8.903920e+01 1.244429e+02 #>  [316] 3.081308e+02 8.471292e+01 9.076682e+01 6.965790e+01 6.517536e+01 #>  [321] 1.358930e+02 7.243737e+01 6.256306e+01 6.320912e+01 9.120422e+01 #>  [326] 7.481246e+01 7.030171e+01 7.741814e+01 2.252524e+02 1.202619e+02 #>  [331] 7.774213e+01 7.113016e+01 1.030735e+02 8.943945e+01 6.848151e+01 #>  [336] 2.194785e+02 1.395307e+02 8.258515e+01 1.043869e+02 1.720057e+02 #>  [341] 8.685380e+01 9.655929e+01 6.861166e+01 1.411704e+02 8.339419e+01 #>  [346] 9.538082e+01 7.519590e+01 8.234728e+01 7.624971e+01 1.278358e+02 #>  [351] 7.097985e+01 4.133046e+03 7.517932e+01 1.169836e+02 1.003165e+02 #>  [356] 1.257126e+03 2.985218e+02 9.244488e+01 6.842171e+01 7.123411e+01 #>  [361] 9.020031e+01 1.026662e+02 7.375358e+01 1.424299e+02 1.566847e+02 #>  [366] 1.964082e+02 1.290521e+02 9.752801e+02 1.703121e+02 1.097898e+02 #>  [371] 6.947439e+01 7.754376e+01 1.545993e+02 7.332026e+01 8.226448e+01 #>  [376] 6.460463e+01 9.180804e+01 3.012396e+02 7.202216e+01 2.849393e+02 #>  [381] 4.297046e+03 9.677714e+01 7.149062e+01 1.001670e+02 1.290418e+02 #>  [386] 7.038702e+01 9.783089e+01 8.659499e+01 9.777447e+01 7.099699e+01 #>  [391] 9.598649e+01 7.860775e+01 9.419715e+01 1.414536e+02 6.470866e+01 #>  [396] 1.744057e+02 6.539909e+01 6.590788e+01 9.953592e+01 1.049379e+02 #>  [401] 6.725448e+01 8.690188e+01 7.437727e+01 9.167790e+01 9.137210e+01 #>  [406] 9.392796e+01 7.694345e+01 1.211297e+03 5.000005e+02 7.100205e+02 #>  [411] 7.688942e+01 6.575839e+01 6.928852e+01 6.779403e+01 1.015726e+02 #>  [416] 9.538999e+01 8.522947e+01 8.776541e+01 7.588500e+01 6.919900e+01 #>  [421] 8.997735e+01 7.778939e+01 1.842165e+02 7.466355e+01 8.812537e+01 #>  [426] 6.321990e+01 1.342933e+02 7.538897e+01 6.523901e+01 1.098847e+02 #>  [431] 8.375490e+01 1.239173e+02 2.481778e+02 2.057136e+02 8.122328e+01 #>  [436] 6.532841e+01 1.043425e+02 9.073271e+01 7.252578e+01 1.759468e+02 #>  [441] 3.248242e+02 1.355709e+02 8.018290e+01 8.360545e+01 1.028031e+02 #>  [446] 1.687665e+02 8.249054e+01 2.026285e+02 2.942998e+02 7.039236e+01 #>  [451] 6.803133e+01 9.069613e+01 3.576144e+02 1.183284e+02 3.647710e+02 #>  [456] 6.625066e+01 7.045611e+01 1.556851e+02 7.099060e+01 9.650658e+01 #>  [461] 6.959717e+01 1.472496e+02 7.403648e+01 8.421320e+01 2.274865e+02 #>  [466] 7.756567e+01 7.468978e+01 1.492484e+02 1.201862e+02 6.801384e+01 #>  [471] 2.670283e+02 2.610197e+02 1.124759e+02 6.395525e+01 6.641779e+01 #>  [476] 6.690665e+01 9.446393e+01 9.567069e+01 7.284431e+01 1.247192e+02 #>  [481] 7.132906e+01 9.715046e+01 8.166699e+01 1.118384e+02 1.335539e+02 #>  [486] 2.246664e+02 7.632151e+01 8.742365e+01 7.411577e+01 2.443616e+02 #>  [491] 1.783839e+02 5.133813e+02 1.254514e+02 8.642498e+01 1.483744e+02 #>  [496] 1.053331e+02 7.823920e+01 1.120050e+02 7.772191e+01 2.814318e+02 #>  [501] 1.368995e+02 7.959693e+02 6.006473e+01 6.974552e+01 7.664509e+01 #>  [506] 6.725283e+01 6.175519e+01 7.819322e+01 8.100981e+01 8.669894e+01 #>  [511] 8.529298e+01 4.862115e+02 1.381202e+02 1.025416e+02 1.411296e+02 #>  [516] 6.635686e+01 6.069072e+01 7.022877e+01 7.603134e+01 8.956779e+01 #>  [521] 2.812019e+02 7.403702e+07 1.583679e+02 5.998672e+01 6.093937e+01 #>  [526] 6.285422e+01 2.227718e+02 8.204639e+01 9.794419e+01 1.629792e+03 #>  [531] 2.823503e+07 3.668208e+02 1.254327e+02 1.546661e+02 6.475651e+02 #>  [536] 1.664657e+02 6.986434e+01 1.059454e+02 4.440766e+02 1.664972e+02 #>  [541] 1.048651e+02 3.884826e+02 7.832691e+01 1.400968e+02 1.043294e+02 #>  [546] 1.031505e+02 7.423222e+01 6.648473e+01 6.907511e+01 6.934951e+01 #>  [551] 1.399645e+02 6.552120e+01 7.859328e+01 7.305187e+01 8.243819e+01 #>  [556] 1.101014e+02 7.608384e+01 6.459829e+01 7.825657e+01 8.092199e+01 #>  [561] 1.094467e+02 2.169310e+02 6.543055e+01 8.137445e+01 1.140804e+02 #>  [566] 1.102613e+02 2.185377e+03 2.378135e+02 7.407370e+01 1.601313e+02 #>  [571] 6.679986e+01 7.952797e+01 7.308536e+01 6.612690e+01 7.237889e+01 #>  [576] 5.755777e+02 8.805095e+01 1.497962e+02 5.055716e+02 1.563249e+02 #>  [581] 8.568513e+01 6.885901e+01 9.847047e+01 7.070179e+01 6.954561e+01 #>  [586] 8.484543e+01 1.444394e+02 6.552037e+01 6.838071e+01 7.981895e+01 #>  [591] 7.471682e+01 6.547934e+01 6.820763e+01 6.895235e+01 8.610207e+01 #>  [596] 1.367009e+02 1.244027e+02 1.080531e+02 1.066460e+02 1.577227e+02 #>  [601] 3.366446e+02 1.417715e+02 9.481499e+01 1.181444e+02 7.486610e+01 #>  [606] 1.578282e+02 7.005654e+01 2.585732e+02 1.084200e+03 1.273020e+03 #>  [611] 7.544211e+01 1.156579e+02 9.719510e+01 6.997276e+01 6.579416e+01 #>  [616] 9.059253e+01 6.757229e+01 1.287509e+02 1.046236e+02 7.671404e+01 #>  [621] 7.229989e+01 8.747087e+01 7.109991e+01 1.898008e+02 1.572576e+04 #>  [626] 6.768648e+01 6.974518e+01 7.908378e+01 7.536001e+01 6.520141e+01 #>  [631] 5.376811e+03 7.895137e+01 6.225099e+01 8.443776e+01 9.466849e+01 #>  [636] 7.849867e+01 2.843609e+02 9.080355e+01 6.504999e+01 6.551225e+01 #>  [641] 7.372758e+01 6.612945e+01 7.011906e+01 1.139473e+02 9.385382e+01 #>  [646] 1.607191e+02 7.392768e+01 1.177255e+02 6.571213e+01 6.386204e+01 #>  [651] 1.121163e+02 6.703203e+01 8.731690e+01 2.272942e+03 2.089011e+02 #>  [656] 7.436321e+01 7.736530e+01 1.712112e+02 8.774588e+01 7.000507e+01 #>  [661] 6.975126e+01 7.842163e+01 6.999336e+01 9.550701e+01 1.572171e+02 #>  [666] 7.240199e+01 1.394834e+03 9.441970e+02 3.420200e+04 1.261084e+02 #>  [671] 7.856632e+01 2.049698e+02 8.109916e+01 1.304591e+02 1.177794e+02 #>  [676] 7.183116e+01 6.641804e+01 2.132352e+02 1.120780e+02 3.608176e+04 #>  [681] 1.900220e+02 3.314045e+02 2.181125e+02 1.211884e+02 5.167765e+02 #>  [686] 3.836358e+02 7.032074e+01 8.111829e+01 7.606011e+01 8.343025e+01 #>  [691] 1.524740e+02 1.264647e+02 1.083021e+02 6.303124e+01 1.125398e+02 #>  [696] 1.039291e+02 7.521294e+01 6.770861e+01 1.325283e+02 8.878317e+01 #>  [701] 1.844457e+02 8.033475e+01 1.382150e+02 1.055921e+02 8.930472e+01 #>  [706] 2.162167e+02 8.902811e+01 1.057327e+02 1.049892e+02 8.416657e+01 #>  [711] 7.959387e+01 1.368745e+02 6.290304e+01 6.497264e+01 6.371146e+01 #>  [716] 8.090950e+01 7.844284e+01 7.029241e+01 8.596877e+02 7.706287e+02 #>  [721] 1.796842e+02 1.572853e+02 8.619983e+01 9.654256e+01 6.782840e+01 #>  [726] 7.395249e+01 8.418346e+01 7.421779e+01 6.700635e+01 8.821537e+02 #>  [731] 6.474911e+01 6.955940e+01 1.359929e+02 1.155041e+02 2.534116e+02 #>  [736] 1.111942e+02 6.614335e+01 1.157930e+02 9.488274e+01 1.187667e+02 #>  [741] 1.736418e+04 1.245895e+02 1.978702e+02 1.043824e+02 1.170108e+02 #>  [746] 6.329889e+01 9.531069e+01 1.659528e+02 8.402844e+01 5.397445e+02 #>  [751] 1.719917e+02 5.886950e+01 8.815996e+01 7.203714e+01 1.205991e+02 #>  [756] 8.033831e+01 1.001797e+02 6.921391e+01 8.925519e+01 8.357989e+01 #>  [761] 1.306076e+02 6.783411e+01 1.550608e+02 1.970712e+02 2.515793e+02 #>  [766] 1.160161e+02 1.021616e+02 1.028732e+02 1.058645e+02 7.446612e+01 #>  [771] 1.273889e+02 8.725158e+01 1.020112e+02 9.002625e+01 6.432880e+01 #>  [776] 7.266572e+01 6.267997e+01 5.255554e+02 1.434106e+02 8.110795e+01 #>  [781] 7.074942e+01 9.143808e+01 9.755454e+01 6.918048e+01 1.307014e+02 #>  [786] 7.472079e+01 2.272234e+02 6.946162e+01 8.477158e+01 1.142240e+02 #>  [791] 7.973984e+01 7.543839e+01 9.582552e+01 6.837608e+01 7.361497e+01 #>  [796] 1.042837e+02 6.111504e+01 7.579299e+01 7.041419e+01 7.952779e+01 #>  [801] 7.011206e+01 7.037126e+01 6.785802e+01 8.520693e+01 8.822714e+01 #>  [806] 8.411601e+01 1.063448e+02 2.509015e+02 1.103272e+02 9.455631e+01 #>  [811] 2.282753e+02 8.554791e+01 1.523099e+02 6.456991e+01 7.749745e+01 #>  [816] 6.878925e+01 6.211147e+01 9.007987e+01 1.702704e+02 5.252699e+02 #>  [821] 1.809934e+02 1.353517e+02 9.951104e+01 8.610426e+01 8.344266e+01 #>  [826] 8.748858e+01 1.280949e+02 6.386345e+01 6.954526e+01 8.230779e+01 #>  [831] 7.251234e+01 1.679340e+02 6.690190e+01 8.717731e+01 7.654338e+01 #>  [836] 6.871352e+01 3.361437e+02 6.497166e+01 7.926209e+01 7.101330e+01 #>  [841] 7.372509e+01 2.294193e+02 2.630182e+02 1.215807e+02 2.271131e+02 #>  [846] 2.807315e+05 2.877368e+02 2.120457e+02 6.286190e+01 7.094109e+01 #>  [851] 7.483188e+01 9.553520e+01 6.838069e+01 7.491676e+01 7.247958e+01 #>  [856] 7.531143e+01 8.548063e+01 6.939428e+01 1.214798e+02 9.173216e+01 #>  [861] 6.496346e+01 1.283491e+02 7.839318e+01 7.901542e+01 6.311125e+01 #>  [866] 7.715881e+01 8.900737e+02 1.616745e+02 7.141122e+01 6.669253e+01 #>  [871] 7.504125e+01 7.096415e+01 6.835251e+01 6.120517e+01 6.049157e+01 #>  [876] 1.746721e+02 6.939971e+01 5.337589e+02 2.898942e+02 8.974972e+01 #>  [881] 1.859449e+04 1.248245e+02 9.061592e+01 6.857166e+01 8.203598e+01 #>  [886] 1.098412e+02 1.256170e+02 1.024984e+02 8.446904e+01 7.827825e+01 #>  [891] 9.181739e+01 8.060172e+01 2.004689e+02 7.119009e+03 9.928365e+01 #>  [896] 7.173359e+01 7.053766e+01 7.805213e+01 7.281677e+01 7.996823e+01 #>  [901] 6.566792e+01 9.720937e+01 1.320696e+02 1.229359e+02 1.078188e+02 #>  [906] 7.464026e+01 1.001904e+02 6.425219e+02 6.930247e+01 9.630992e+01 #>  [911] 8.960073e+01 7.476841e+01 2.158500e+02 8.011825e+01 7.620360e+01 #>  [916] 6.580836e+01 7.804021e+01 6.749600e+01 1.016986e+02 7.290773e+01 #>  [921] 6.847846e+01 2.332101e+02 1.326364e+02 6.895802e+01 1.079530e+02 #>  [926] 8.009026e+01 6.937666e+01 8.349575e+01 6.612901e+01 1.031605e+02 #>  [931] 9.213425e+01 1.004542e+02 2.837423e+03 8.651951e+01 6.092642e+01 #>  [936] 7.022698e+01 8.028926e+01 6.254550e+01 1.394862e+02 9.120961e+01 #>  [941] 6.751041e+01 8.939930e+01 1.422072e+02 2.116331e+02 7.225448e+01 #>  [946] 7.747772e+01 8.737380e+01 7.037257e+01 8.877674e+01 1.308382e+02 #>  [951] 9.127290e+02 7.893247e+02 6.569689e+01 1.200407e+02 6.804761e+01 #>  [956] 1.299389e+02 1.628372e+02 9.299679e+01 9.227680e+01 9.607588e+01 #>  [961] 6.745105e+01 7.319091e+01 1.024963e+02 1.667325e+02 1.083688e+02 #>  [966] 6.482559e+02 8.946189e+01 7.028713e+01 1.312928e+02 7.412931e+01 #>  [971] 1.148463e+02 5.591560e+02 2.757608e+02 1.339870e+02 1.979073e+02 #>  [976] 7.850708e+01 1.541854e+02 6.257279e+01 7.845535e+01 6.702158e+01 #>  [981] 6.825997e+01 7.589213e+01 1.401152e+02 9.343483e+01 8.930004e+01 #>  [986] 6.994579e+01 6.678670e+01 7.290033e+01 8.264838e+01 7.766656e+01 #>  [991] 1.516577e+02 6.034953e+01 8.809673e+01 1.070284e+02 1.583198e+02 #>  [996] 7.225976e+01 4.415269e+02 9.877248e+01 1.531919e+02 9.277334e+01 doseFunction(   model,   alpha2 = samples@data$alpha2,   beta = samples@data$beta,   grade = 2L )(x = 0.25) #>    [1] 5.925999e+01 5.531300e+01 5.757795e+01 6.241956e+01 6.006592e+01 #>    [6] 6.952153e+01 6.620278e+01 5.413703e+01 5.530973e+01 5.876131e+01 #>   [11] 6.665219e+01 5.197982e+01 5.428308e+01 6.122297e+01 6.139928e+01 #>   [16] 6.156058e+01 5.438875e+01 6.331477e+01 6.219429e+01 7.093272e+01 #>   [21] 1.030714e+02 2.380767e+03 5.846617e+07 1.977158e+02 1.251535e+02 #>   [26] 1.420717e+02 1.759989e+02 6.358976e+01 6.630972e+01 8.977205e+01 #>   [31] 7.798844e+01 9.918325e+01 1.094710e+02 2.424146e+02 1.229974e+04 #>   [36] 6.247246e+01 2.222286e+02 1.927348e+02 6.033875e+01 6.093451e+01 #>   [41] 9.044765e+01 1.052997e+02 5.920084e+02 1.848245e+02 7.133188e+01 #>   [46] 6.338017e+01 9.047176e+01 1.620996e+02 7.112794e+01 7.193943e+01 #>   [51] 6.623888e+01 5.522173e+01 6.700597e+01 8.875116e+01 5.230368e+02 #>   [56] 5.841493e+01 5.278651e+01 5.502572e+01 6.490782e+01 6.059248e+01 #>   [61] 5.908302e+01 5.995270e+01 5.637005e+01 6.180411e+01 5.927403e+01 #>   [66] 6.193376e+01 6.293153e+01 6.783429e+01 7.257693e+01 6.219758e+01 #>   [71] 6.667685e+01 7.050440e+01 6.347017e+01 6.248917e+01 7.678850e+01 #>   [76] 6.675224e+01 6.128292e+01 8.324474e+01 1.964282e+02 9.070072e+01 #>   [81] 5.755098e+01 6.064838e+01 6.221818e+01 5.872740e+01 6.135591e+01 #>   [86] 7.083921e+01 6.813520e+01 6.422972e+01 6.118911e+01 8.790513e+01 #>   [91] 5.997962e+01 1.721951e+03 6.496347e+01 5.313675e+01 6.408342e+01 #>   [96] 1.075847e+02 5.644565e+01 6.537906e+01 6.615002e+01 7.975852e+01 #>  [101] 6.031103e+01 1.492777e+07 7.206497e+01 6.872091e+01 1.377792e+02 #>  [106] 5.718768e+01 7.181093e+01 8.307849e+01 6.048505e+01 6.063607e+01 #>  [111] 5.826860e+01 6.280562e+01 1.401992e+02 5.312371e+01 8.221577e+01 #>  [116] 5.605997e+02 1.349387e+02 1.131972e+02 6.344227e+01 8.188382e+01 #>  [121] 1.323929e+02 6.043183e+01 6.150978e+01 6.477632e+01 8.897522e+01 #>  [126] 6.380011e+01 6.620688e+01 5.953769e+01 8.454486e+01 7.601462e+01 #>  [131] 6.688170e+01 5.735713e+01 8.296696e+01 8.428273e+01 5.885041e+01 #>  [136] 6.795608e+01 6.889966e+01 6.043837e+01 8.203806e+01 6.407763e+01 #>  [141] 7.005452e+01 5.653859e+01 5.673094e+01 5.766764e+01 7.232964e+01 #>  [146] 6.441725e+01 6.459880e+01 6.473617e+01 5.510201e+01 5.648377e+01 #>  [151] 8.081666e+01 5.824293e+01 1.005133e+02 7.272083e+01 5.804155e+01 #>  [156] 7.011859e+01 8.329819e+01 9.808536e+04 6.608738e+01 8.541884e+01 #>  [161] 6.771562e+01 6.335705e+01 5.344768e+01 6.954527e+01 7.213937e+01 #>  [166] 5.736855e+01 2.180706e+03 6.637841e+01 6.160940e+01 6.995454e+01 #>  [171] 7.787638e+01 6.916036e+01 9.886831e+01 1.459570e+02 5.437401e+01 #>  [176] 9.448113e+01 6.264875e+01 8.257761e+01 6.406032e+01 7.842364e+01 #>  [181] 7.693698e+01 6.491393e+01 5.591294e+01 7.167586e+01 1.133229e+02 #>  [186] 5.028257e+02 7.443433e+01 7.402399e+01 2.770608e+02 5.213684e+01 #>  [191] 6.546315e+01 7.953096e+01 6.967340e+01 7.001715e+01 6.681571e+01 #>  [196] 7.212755e+01 5.715309e+01 8.202926e+01 6.017629e+01 6.127350e+01 #>  [201] 5.351081e+01 8.432281e+01 7.411437e+01 5.358135e+01 6.138732e+01 #>  [206] 7.494281e+01 6.046580e+01 7.737293e+01 7.477434e+01 7.947313e+01 #>  [211] 6.102070e+01 6.298819e+01 7.020264e+01 6.335712e+01 6.978381e+01 #>  [216] 1.402981e+02 5.400788e+01 5.798256e+01 6.028319e+01 5.760676e+01 #>  [221] 8.049233e+01 7.737539e+01 5.888053e+01 5.832421e+01 5.848106e+01 #>  [226] 6.100337e+01 5.759535e+01 7.377037e+01 6.291907e+01 6.186806e+01 #>  [231] 2.566241e+02 5.323519e+01 5.451338e+01 6.545852e+01 6.073211e+01 #>  [236] 5.623731e+01 6.482497e+01 1.560979e+02 6.665067e+01 1.021882e+02 #>  [241] 6.765248e+01 6.781585e+01 8.918029e+01 6.050308e+01 6.800536e+01 #>  [246] 7.042467e+01 7.103741e+01 7.274749e+01 6.103529e+01 1.023255e+02 #>  [251] 5.970299e+01 6.416927e+01 6.304258e+01 5.806523e+01 9.113304e+01 #>  [256] 5.711377e+01 9.817738e+01 6.290796e+01 8.749409e+01 6.130928e+01 #>  [261] 5.004077e+01 1.162352e+02 1.257128e+02 1.107053e+02 5.893841e+01 #>  [266] 5.384485e+01 6.909759e+01 6.613584e+01 5.406579e+01 5.624904e+01 #>  [271] 1.330870e+02 7.157112e+01 5.637626e+01 7.887567e+01 5.864633e+01 #>  [276] 7.528479e+01 8.255261e+01 5.785977e+01 7.582025e+01 7.071142e+01 #>  [281] 5.863349e+01 7.282418e+01 7.215456e+01 5.858658e+01 5.769198e+01 #>  [286] 7.253055e+01 5.194912e+01 6.541036e+01 6.193444e+01 7.389431e+01 #>  [291] 5.846365e+01 5.908411e+01 5.666328e+01 1.473721e+02 8.507580e+01 #>  [296] 8.934755e+01 6.823548e+01 6.115225e+01 5.914501e+01 1.428730e+03 #>  [301] 7.708992e+01 6.007561e+01 9.032299e+01 6.065484e+01 6.476470e+01 #>  [306] 5.628246e+01 6.346866e+01 6.108431e+01 1.120308e+02 6.743984e+01 #>  [311] 6.303131e+01 6.074384e+01 5.345669e+01 6.870173e+01 9.292199e+01 #>  [316] 1.798641e+02 7.066952e+01 7.228572e+01 6.243629e+01 5.982018e+01 #>  [321] 1.067181e+02 6.573551e+01 5.867966e+01 5.831897e+01 7.631543e+01 #>  [326] 6.089884e+01 5.930713e+01 6.617060e+01 1.298918e+02 8.186458e+01 #>  [331] 5.776012e+01 6.110486e+01 7.848297e+01 7.277774e+01 6.080560e+01 #>  [336] 9.705790e+01 7.012282e+01 6.216462e+01 7.080178e+01 9.813772e+01 #>  [341] 6.260192e+01 7.413979e+01 5.996880e+01 8.690276e+01 6.845416e+01 #>  [346] 6.601430e+01 5.557224e+01 5.971935e+01 6.083196e+01 8.657432e+01 #>  [351] 5.654607e+01 6.465489e+02 5.944430e+01 7.872979e+01 7.500291e+01 #>  [356] 2.076589e+02 1.416172e+02 6.855590e+01 5.671892e+01 6.042894e+01 #>  [361] 6.910907e+01 7.236936e+01 6.257249e+01 1.008598e+02 7.853487e+01 #>  [366] 1.131125e+02 7.925006e+01 1.608436e+02 7.829993e+01 7.554794e+01 #>  [371] 5.722196e+01 6.617468e+01 1.030007e+02 6.398481e+01 6.786560e+01 #>  [376] 5.995478e+01 7.699708e+01 1.552301e+02 5.183626e+01 1.000762e+02 #>  [381] 2.141539e+02 6.920143e+01 5.835959e+01 5.701992e+01 6.374865e+01 #>  [386] 6.221050e+01 8.007697e+01 6.842070e+01 5.940632e+01 5.645321e+01 #>  [391] 6.570648e+01 6.109174e+01 7.163749e+01 8.381254e+01 5.788787e+01 #>  [396] 1.112426e+02 5.809426e+01 6.058703e+01 7.656549e+01 6.955369e+01 #>  [401] 5.672806e+01 6.301195e+01 6.256980e+01 7.173117e+01 6.178571e+01 #>  [406] 6.626945e+01 5.755895e+01 3.156902e+02 2.007367e+02 1.288028e+02 #>  [411] 6.466365e+01 5.562166e+01 6.045585e+01 5.983036e+01 7.727624e+01 #>  [416] 7.653876e+01 6.858683e+01 6.626794e+01 5.314592e+01 5.878044e+01 #>  [421] 6.397041e+01 6.142082e+01 8.537902e+01 6.005171e+01 7.229292e+01 #>  [426] 5.711050e+01 9.978001e+01 5.960089e+01 5.539988e+01 6.841609e+01 #>  [431] 7.054980e+01 7.196136e+01 6.573115e+01 1.045859e+02 5.862926e+01 #>  [436] 5.761452e+01 7.499506e+01 6.445616e+01 5.999241e+01 9.589931e+01 #>  [441] 1.747023e+02 9.505710e+01 6.597796e+01 6.119122e+01 7.624678e+01 #>  [446] 9.376032e+01 5.289557e+01 9.275655e+01 6.555993e+01 5.913013e+01 #>  [451] 5.702510e+01 6.371019e+01 1.288302e+02 5.911758e+01 1.157185e+02 #>  [456] 5.793934e+01 6.129267e+01 7.982053e+01 5.598323e+01 6.790006e+01 #>  [461] 5.998137e+01 8.844763e+01 6.031463e+01 6.631541e+01 1.090007e+02 #>  [466] 5.927581e+01 5.248483e+01 9.627651e+01 7.894853e+01 5.846997e+01 #>  [471] 1.390022e+02 1.293503e+02 8.064559e+01 5.689126e+01 5.814462e+01 #>  [476] 5.924703e+01 7.348757e+01 6.824474e+01 4.941825e+01 5.065970e+01 #>  [481] 5.408972e+01 6.704526e+01 5.226991e+01 7.169470e+01 8.646030e+01 #>  [486] 8.534495e+01 6.361962e+01 6.744758e+01 6.123843e+01 9.587553e+01 #>  [491] 8.716355e+01 1.154201e+02 7.115728e+01 5.483179e+01 7.594228e+01 #>  [496] 7.166490e+01 6.000705e+01 7.980841e+01 6.473579e+01 1.362544e+02 #>  [501] 7.948554e+01 2.565728e+02 5.228536e+01 6.354964e+01 6.477680e+01 #>  [506] 6.102254e+01 5.618169e+01 6.642519e+01 6.690714e+01 7.079687e+01 #>  [511] 7.050391e+01 1.534186e+02 8.527529e+01 7.537359e+01 8.898290e+01 #>  [516] 5.371020e+01 5.646430e+01 6.332646e+01 6.312005e+01 7.411350e+01 #>  [521] 9.786201e+01 4.406054e+04 9.169280e+01 5.328488e+01 5.522532e+01 #>  [526] 5.715348e+01 9.673338e+01 6.241564e+01 6.629980e+01 3.402373e+02 #>  [531] 2.029432e+05 1.099463e+02 5.881373e+01 8.282073e+01 2.382367e+02 #>  [536] 6.381668e+01 5.932809e+01 7.213184e+01 1.242430e+02 6.281185e+01 #>  [541] 7.667187e+01 1.214731e+02 6.075627e+01 7.628732e+01 7.196453e+01 #>  [546] 6.141203e+01 5.862212e+01 5.552354e+01 5.603789e+01 5.714377e+01 #>  [551] 6.873717e+01 5.590693e+01 6.301428e+01 6.135309e+01 6.502996e+01 #>  [556] 7.292677e+01 6.518037e+01 5.908589e+01 6.744190e+01 6.653392e+01 #>  [561] 7.967147e+01 1.127113e+02 5.382597e+01 6.497792e+01 7.231788e+01 #>  [566] 7.207154e+01 2.814263e+02 7.835333e+01 5.660342e+01 8.490592e+01 #>  [571] 6.042019e+01 5.796723e+01 5.977916e+01 5.552054e+01 6.064995e+01 #>  [576] 1.373238e+02 7.104018e+01 7.553972e+01 1.261899e+02 7.196330e+01 #>  [581] 7.311982e+01 5.991836e+01 6.117449e+01 5.904820e+01 6.012511e+01 #>  [586] 6.393423e+01 7.777784e+01 5.948239e+01 6.089999e+01 6.624836e+01 #>  [591] 6.304928e+01 5.325522e+01 5.907758e+01 6.090495e+01 6.501884e+01 #>  [596] 8.123435e+01 7.884402e+01 7.229090e+01 7.804611e+01 1.085383e+02 #>  [601] 1.618358e+02 9.286781e+01 6.021284e+01 8.020074e+01 5.241559e+01 #>  [606] 8.420908e+01 5.856341e+01 1.100217e+02 1.542661e+02 3.214220e+02 #>  [611] 5.261496e+01 6.868463e+01 7.186517e+01 5.969738e+01 5.847243e+01 #>  [616] 6.152501e+01 5.983180e+01 8.740719e+01 7.540338e+01 6.223978e+01 #>  [621] 5.940524e+01 6.624094e+01 6.218525e+01 1.161805e+02 7.683708e+02 #>  [626] 5.560138e+01 5.950961e+01 6.105095e+01 6.179932e+01 5.801704e+01 #>  [631] 2.761702e+02 5.416631e+01 5.379108e+01 6.576074e+01 6.261029e+01 #>  [636] 6.391515e+01 1.205187e+02 6.373108e+01 5.534959e+01 5.987562e+01 #>  [641] 6.214496e+01 5.886530e+01 6.163170e+01 8.177808e+01 6.686396e+01 #>  [646] 9.825547e+01 6.084521e+01 6.417349e+01 5.747037e+01 5.472231e+01 #>  [651] 7.682555e+01 6.063066e+01 6.998713e+01 2.899332e+02 9.034729e+01 #>  [656] 6.269816e+01 6.005459e+01 9.880928e+01 7.024082e+01 6.229387e+01 #>  [661] 5.917588e+01 6.448105e+01 5.994281e+01 6.547345e+01 9.207563e+01 #>  [666] 5.850614e+01 1.541997e+02 2.249990e+02 3.079079e+03 8.717565e+01 #>  [671] 6.329659e+01 9.805770e+01 6.556458e+01 7.698731e+01 7.490594e+01 #>  [676] 5.753314e+01 5.439222e+01 7.661286e+01 6.521755e+01 2.814785e+03 #>  [681] 5.753753e+01 1.152582e+02 8.433249e+01 7.850917e+01 2.080579e+02 #>  [686] 1.727568e+02 5.266015e+01 6.710204e+01 6.405604e+01 6.427720e+01 #>  [691] 8.569056e+01 8.114634e+01 7.511584e+01 5.420978e+01 6.497548e+01 #>  [696] 6.435341e+01 6.466515e+01 5.953541e+01 7.175888e+01 6.650158e+01 #>  [701] 9.710741e+01 6.414676e+01 7.518516e+01 6.805202e+01 6.670789e+01 #>  [706] 8.775067e+01 5.562802e+01 7.026742e+01 6.222763e+01 6.671833e+01 #>  [711] 6.423482e+01 8.866427e+01 5.618518e+01 5.724844e+01 5.700937e+01 #>  [716] 6.528024e+01 6.197675e+01 5.731708e+01 1.948225e+02 2.499434e+02 #>  [721] 1.014445e+02 9.925354e+01 5.428000e+01 6.988520e+01 5.293694e+01 #>  [726] 6.134146e+01 6.203640e+01 6.109492e+01 5.617471e+01 1.870969e+02 #>  [731] 5.185216e+01 5.905997e+01 7.855297e+01 6.729018e+01 1.075215e+02 #>  [736] 7.075266e+01 5.662456e+01 6.646977e+01 6.579456e+01 7.782568e+01 #>  [741] 1.546116e+03 9.161376e+01 1.202621e+02 7.557432e+01 7.585201e+01 #>  [746] 5.609479e+01 7.992952e+01 6.153705e+01 5.479292e+01 1.150992e+02 #>  [751] 8.876304e+01 5.344199e+01 7.081530e+01 4.954859e+01 6.315657e+01 #>  [756] 6.821839e+01 7.075281e+01 5.926949e+01 6.495832e+01 6.960130e+01 #>  [761] 8.282852e+01 5.281443e+01 6.578474e+01 7.358812e+01 6.964384e+01 #>  [766] 5.192793e+01 7.525206e+01 7.519384e+01 8.074878e+01 5.766556e+01 #>  [771] 8.602789e+01 6.955279e+01 6.757387e+01 6.240710e+01 5.648755e+01 #>  [776] 5.711954e+01 5.535268e+01 1.685317e+02 9.510778e+01 6.334537e+01 #>  [781] 5.818247e+01 6.343283e+01 6.753514e+01 5.688799e+01 7.991068e+01 #>  [786] 5.787062e+01 1.186647e+02 5.821252e+01 6.529323e+01 7.225885e+01 #>  [791] 6.093333e+01 5.564508e+01 6.768882e+01 5.547205e+01 5.542377e+01 #>  [796] 6.723807e+01 5.481761e+01 6.565259e+01 6.200705e+01 6.254698e+01 #>  [801] 5.967568e+01 5.980686e+01 6.045464e+01 6.642233e+01 7.325786e+01 #>  [806] 6.533046e+01 7.059961e+01 1.093179e+02 8.254054e+01 6.111267e+01 #>  [811] 1.057113e+02 6.218005e+01 8.045206e+01 5.511948e+01 6.840295e+01 #>  [816] 5.852141e+01 5.575714e+01 6.496614e+01 8.590522e+01 1.120092e+02 #>  [821] 1.127239e+02 6.831783e+01 5.946455e+01 6.051781e+01 6.164526e+01 #>  [826] 6.234749e+01 7.209662e+01 5.591092e+01 5.968686e+01 6.675258e+01 #>  [831] 5.738323e+01 8.053653e+01 5.954092e+01 7.207861e+01 6.587337e+01 #>  [836] 5.862071e+01 7.459712e+01 5.678540e+01 6.276934e+01 6.083662e+01 #>  [841] 6.400852e+01 1.369590e+02 1.567997e+02 8.079597e+01 1.091060e+02 #>  [846] 1.206943e+03 1.375685e+02 1.013156e+02 5.626902e+01 6.035941e+01 #>  [851] 6.122133e+01 6.576108e+01 6.076685e+01 6.534866e+01 6.086371e+01 #>  [856] 6.223082e+01 5.539022e+01 5.082659e+01 8.853785e+01 5.016195e+01 #>  [861] 5.949811e+01 9.209960e+01 5.961611e+01 6.090262e+01 5.862822e+01 #>  [866] 6.446316e+01 1.683468e+02 6.942663e+01 6.024661e+01 5.800444e+01 #>  [871] 5.792102e+01 5.903047e+01 5.905064e+01 5.758922e+01 5.536758e+01 #>  [876] 1.038374e+02 5.657780e+01 1.797931e+02 1.205173e+02 5.026042e+01 #>  [881] 1.352633e+03 5.651420e+01 5.939997e+01 6.026428e+01 6.148543e+01 #>  [886] 7.363359e+01 6.466744e+01 7.523982e+01 6.833530e+01 6.593705e+01 #>  [891] 7.452247e+01 6.874107e+01 6.569660e+01 4.839410e+02 6.376657e+01 #>  [896] 5.813968e+01 5.918713e+01 6.865285e+01 5.877639e+01 6.473897e+01 #>  [901] 5.783480e+01 6.974691e+01 9.309600e+01 9.036875e+01 6.402417e+01 #>  [906] 6.163400e+01 6.576398e+01 2.830947e+02 5.684054e+01 6.567669e+01 #>  [911] 6.233642e+01 5.970481e+01 8.257443e+01 6.470069e+01 6.343986e+01 #>  [916] 6.039908e+01 6.910450e+01 5.551620e+01 6.055000e+01 5.760997e+01 #>  [921] 5.509072e+01 7.023425e+01 8.012904e+01 5.440013e+01 6.306826e+01 #>  [926] 5.999752e+01 5.803511e+01 6.498109e+01 5.718575e+01 6.617442e+01 #>  [931] 6.042074e+01 6.736858e+01 3.856940e+02 6.813931e+01 5.128529e+01 #>  [936] 6.188917e+01 6.471570e+01 5.217348e+01 7.190115e+01 6.325551e+01 #>  [941] 5.517755e+01 7.560331e+01 1.025642e+02 1.316912e+02 6.299246e+01 #>  [946] 5.942899e+01 6.616008e+01 6.086578e+01 6.898343e+01 5.952806e+01 #>  [951] 3.032688e+02 2.666652e+02 5.675221e+01 7.286205e+01 5.785451e+01 #>  [956] 8.164655e+01 8.706421e+01 7.186908e+01 6.213114e+01 7.138507e+01 #>  [961] 6.231327e+01 6.503073e+01 8.055056e+01 9.128891e+01 7.940133e+01 #>  [966] 1.224274e+02 6.848340e+01 6.013670e+01 6.865575e+01 6.015158e+01 #>  [971] 7.059110e+01 8.624808e+01 8.522626e+01 9.027253e+01 7.775198e+01 #>  [976] 5.222805e+01 9.874144e+01 5.168036e+01 6.110357e+01 6.080223e+01 #>  [981] 6.018341e+01 6.585143e+01 9.651483e+01 6.617380e+01 7.003466e+01 #>  [986] 5.747238e+01 5.603502e+01 6.206126e+01 6.271644e+01 6.393178e+01 #>  [991] 7.828052e+01 5.242859e+01 6.047430e+01 7.302376e+01 7.533527e+01 #>  [996] 5.843593e+01 1.363329e+02 7.232135e+01 8.744138e+01 7.187755e+01"},{"path":"https://openpharma.github.io/crmPack/reference/dose_grid_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Dose Grid Range — dose_grid_range","title":"Getting the Dose Grid Range — dose_grid_range","text":"function returns vector length two minimum maximum dose grid. returns c(-Inf, Inf) range determined, happens dose grid empty. User can choose whether placebo dose () counted .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dose_grid_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Dose Grid Range — dose_grid_range","text":"","code":"dose_grid_range(object, ...)  # S4 method for class 'Data' dose_grid_range(object, ignore_placebo = TRUE)  # S4 method for class 'DataOrdinal' dose_grid_range(object, ignore_placebo = TRUE)"},{"path":"https://openpharma.github.io/crmPack/reference/dose_grid_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Dose Grid Range — dose_grid_range","text":"object (Data) object dose grid. ... arguments passed class-specific methods. ignore_placebo (flag) placebo dose () counted?","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dose_grid_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Dose Grid Range — dose_grid_range","text":"numeric vector containing minimum maximum doses grid c(-Inf, Inf).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/dose_grid_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Dose Grid Range — dose_grid_range","text":"","code":"my_data <- Data(   x = c(10, 50, 90, 100, 0.001, 20, 30, 30),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(1L, 2L, 3L, 4L, 5L, 5L, 6L, 6L),   doseGrid = c(0.001, seq(from = 10, to = 100, by = 10)),   placebo = TRUE ) dose_grid_range(my_data) #> [1]  10 100 dose_grid_range(my_data, ignore_placebo = FALSE) #> [1] 1e-03 1e+02 data <- DataOrdinal(   x = c(10, 20, 30, 40, 50, 50, 50, 60, 60, 60),   y = as.integer(c(0, 0, 0, 0, 0, 1, 0, 0, 1, 2)),   ID = 1L:10L,   cohort = as.integer(c(1:4, 5, 5, 5, 6, 6, 6)),   doseGrid = c(seq(from = 10, to = 100, by = 10)),   yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L),   placebo = FALSE )  dose_grid_range(data) #> [1]  10 100"},{"path":"https://openpharma.github.io/crmPack/reference/efficacy.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"function computes value expected efficacy specified dose level, based model specific parameters. model parameters (samples) obtained based prior specified form pseudo data combined observed responses ().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/efficacy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"","code":"efficacy(dose, model, samples, ...)  # S4 method for class 'numeric,Effloglog,Samples' efficacy(dose, model, samples)  # S4 method for class 'numeric,Effloglog,missing' efficacy(dose, model)  # S4 method for class 'numeric,EffFlexi,Samples' efficacy(dose, model, samples)"},{"path":"https://openpharma.github.io/crmPack/reference/efficacy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"dose (numeric) dose targeted. following recycling rule applies samples missing: vectors size 1 recycled size sample (.e. size(samples)). Otherwise, dose must size sample. model (ModelEff) efficacy model pseudo data prior. samples (Samples) samples model's parameters used compute expected efficacy values. Can also missing models. ... model specific parameters samples used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/efficacy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"numeric vector values expected efficacy. non-scalar samples used, every element returned vector corresponds one element sample. Hence, case, output vector length sample vector. scalar samples used samples used, e.g. pseudo DLE/toxicity model, output length length dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/efficacy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"efficacy() function computes expected efficacy given doses, using samples model parameter(s). work multivariate model parameters, assume model specific efficacy() method receives samples matrix rows correspond sampling index, .e. layout nSamples x dimParameter.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/efficacy.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"efficacy(dose = numeric, model = Effloglog, samples = Samples): compute expected efficacy specified dose level, based samples Effloglog model parameters. efficacy(dose = numeric, model = Effloglog, samples = missing): compute expected efficacy specified dose level, based Effloglog model parameters. model parameters (except dose) present model object. efficacy(dose = numeric, model = EffFlexi, samples = Samples): compute expected efficacy specified dose level, based samples EffFlexi model parameters. given dose dose vector outside dose grid range, NA_real returned dose warning thrown.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/efficacy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing Expected Efficacy for a Given Dose, Model and Samples — efficacy","text":"","code":"# Obtain the expected efficacy value for a given dose, a given pseudo efficacy # model (in flexible form for prior) and efficacy samples.  # Empty data (i.e. no observed data), dose grid only. my_data <- DataDual(doseGrid = seq(25, 300, 25))  my_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = my_data )  my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 200,   rng_kind = \"Mersenne-Twister\",   rng_seed = 94 )  my_samples <- mcmc(data = my_data, model = my_model, options = my_options)  # Efficacy for dose 75. efficacy(dose = 75, model = my_model, samples = my_samples) #>   [1]   1.53309381  -0.36750631   7.55527614   5.25469404   3.66693278 #>   [6]   8.70838981   4.90252140  -0.69061135   1.34203932  -7.43545911 #>  [11]  -2.94369030  -0.31605961   0.50693514  -9.26862484   1.46306208 #>  [16]  -1.14134478   7.32450512  -1.62809243  -2.49305731  -1.66356028 #>  [21]   0.14878359  -0.49947849   4.42304913   4.56649426  -3.57361192 #>  [26]  -5.63080113  -1.94459230  14.44628993   7.35954897   3.02553881 #>  [31]  11.10188815  11.22388514   6.80186903   0.36884435  -2.82813022 #>  [36]  -4.73915711   9.09265745   0.45171075   7.47281283  -3.04597000 #>  [41]  12.38787082   2.42193236   0.61608253  -0.13622731  -6.08412025 #>  [46]  -1.86297634   3.28013838  -2.48647780   1.42981578  -6.81130220 #>  [51]  -5.26399353   2.63505491  -5.57528885  -1.18080239   0.68363630 #>  [56]   0.80957042   1.66747143   1.90085264   0.31491916  -2.97512796 #>  [61]   6.73581440   0.80529855  10.99746433  -4.50426438   2.35555834 #>  [66]  -2.03180783   3.97573796   4.27632858  -9.42646554  12.55749274 #>  [71]  -0.80789290  -1.90257411  -2.49043558   5.63952769   3.45659353 #>  [76]   0.47354025   2.52357271  -1.38263265  -7.15088137  -1.94147061 #>  [81]  -1.49545417  -4.77468458  -2.72741400   9.03347724   2.29069087 #>  [86]   3.92829723   2.63532137   1.82836285   0.58927326   4.21572326 #>  [91]  -2.45214763   7.88420978   0.19709801   0.89906020   4.88309101 #>  [96]   3.04825966  -1.81374639   1.45541231  14.61364519  10.31328290 #> [101]  -7.21042554   2.98659493   8.94809729  -0.36850893   0.77558282 #> [106]   3.24200951  -9.74784292  12.41222304   1.69010933  -1.74952128 #> [111]   5.69098809   2.62087863  -4.88471879  -1.90574868  -0.46153796 #> [116]   2.26830157  -1.42972655  10.97802797  -4.39581100   0.51699864 #> [121]   3.48569230   0.79299301  -6.87113975   3.24208183   6.76958848 #> [126]  -1.49208773   3.78647974   6.56550883   4.58980593  -0.41956371 #> [131]   3.92797953  -0.25794403   3.79244917  -3.41126635  -2.31361622 #> [136]   0.68751868   1.86167000   3.36000659   0.42099810   4.07698962 #> [141]   4.50480555   6.29500656  -4.07015627   6.86309949   4.04608404 #> [146]   1.83641311  -5.48623907  -4.74101984  -5.79376521   1.15017134 #> [151]  -2.50564693  -3.48767730   3.83157946   2.09528864  -1.72330218 #> [156]   8.21151143   6.95861675   5.57982266   8.51214305  -2.05622819 #> [161]   9.80142831  -5.12209892  -6.73822609   2.30227490   1.75097164 #> [166]   1.44273838   2.96978667  10.76845222   4.07874269   7.10792088 #> [171]  -2.05910186   7.30915648   2.61942655  -3.28100602  -0.59016549 #> [176]  -0.08740698   9.11846595  -2.74656639   2.79106308 -10.22195117 #> [181]  -1.57917435  -0.75159739  -0.42006406   5.53433055  -0.76741452 #> [186]  -4.14286245   1.27944063   3.12421033  -3.08574641  10.18627697 #> [191]   9.74964035  -1.02936258   4.68939972   1.95388350   0.99957216 #> [196]  -0.74528033  -0.29508297   2.96868789  14.94223266   4.32409978  # Obtain the expected efficacy value for a given dose, a given pseudo efficacy # model (linear log-log efficacy) and no samples. my_model_ll <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data,   const = 0 )  efficacy(dose = 75, model = my_model_ll) #> [1] 1.885121"},{"path":"https://openpharma.github.io/crmPack/reference/efficacyFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"function returns efficacy() function computes expected efficacy given dose level, based model specific parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/efficacyFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"","code":"efficacyFunction(model, ...)  # S4 method for class 'ModelEff' efficacyFunction(model, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/efficacyFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"model (ModelEff) model. ... model specific parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/efficacyFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"efficacy() function computes expected efficacy.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/efficacyFunction.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"efficacyFunction(ModelEff):","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/efficacyFunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Efficacy Function for a Given Model Type — efficacyFunction","text":"","code":"my_data <- DataDual(   doseGrid = c(0.001, seq(25, 300, 25)),   placebo = TRUE )  my_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data,   const = 2 )  eff_fun <- efficacyFunction(my_model, theta1 = -4.8, theta2 = 3.7) eff_fun(30) #> [1] -0.2011775"},{"path":"https://openpharma.github.io/crmPack/reference/enable_logging.html","id":null,"dir":"Reference","previous_headings":"","what":"Verbose Logging — enable_logging","title":"Verbose Logging — enable_logging","text":"family wrappers selected futile.logger::futile.logger functions control logging mechanism crmPack. crmPack uses futile.logger::futile.logger package logging purposes. messages logged crmPack logged crmPack logger futile.logger::TRACE level. Hence, enabling verbose logging means logging threshold set futile.logger::TRACE crmPack logger, disabling verbose logging means set futile.logger::FATAL.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/enable_logging.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Verbose Logging — enable_logging","text":"","code":"enable_logging()  disable_logging()  is_logging_enabled()  log_trace(msg, ..., capture = FALSE)"},{"path":"https://openpharma.github.io/crmPack/reference/enable_logging.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Verbose Logging — enable_logging","text":"msg message log ... Optional arguments populate format string capture Capture print output variables instead interpolate","code":""},{"path":"https://openpharma.github.io/crmPack/reference/enable_logging.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Verbose Logging — enable_logging","text":"enable_logging(): simple wrapper futile.logger::flog.threshold() enables crmPack verbose logging setting logging threshold futile.logger::TRACE crmPack logger. disable_logging(): simple wrapper futile.logger::flog.threshold() disables crmPack verbose logging setting logging threshold futile.logger::FATAL crmPack logger. is_logging_enabled(): simple wrapper futile.logger::flog.logger() checks whether current threshold level crmPack logger verbose, futile.logger::TRACE. returns TRUE current logging level verbose, FALSE otherwise. log_trace(): simple wrapper futile.logger::flog.trace() prints log message crmPack logger.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/examine.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain hypothetical trial course table for a design — examine","title":"Obtain hypothetical trial course table for a design — examine","text":"generic function takes design generates dataframe showing beginning several hypothetical trial courses design. means, generated dataframe one can read : many cohorts required optimal case (DLTs observed) order reach highest dose specified dose grid (stopping rule fulfilled) assuming DLTs observed certain dose level, next recommended dose possible number DLTs observed actual relative increments used cases whether trial stop certain cohort Examining \"single trial\" behavior dose escalation design first important step evaluating design, replaced studying solely operating characteristics \"many trials\". cohort sizes also taken design, assuming DLTs occur dose listed.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/examine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain hypothetical trial course table for a design — examine","text":"","code":"examine(object, ..., maxNoIncrement = 100L)  # S4 method for class 'Design' examine(object, mcmcOptions = McmcOptions(), ..., maxNoIncrement)  # S4 method for class 'RuleDesign' examine(object, ..., maxNoIncrement = 100L)  # S4 method for class 'DADesign' examine(object, mcmcOptions = McmcOptions(), ..., maxNoIncrement)"},{"path":"https://openpharma.github.io/crmPack/reference/examine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain hypothetical trial course table for a design — examine","text":"object design (Design RuleDesign object) want examine ... additional arguments (see methods) maxNoIncrement maximum number contiguous next doses 0 DLTs , .e. increment (default 100) mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/examine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain hypothetical trial course table for a design — examine","text":"data frame","code":""},{"path":"https://openpharma.github.io/crmPack/reference/examine.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Obtain hypothetical trial course table for a design — examine","text":"examine(Design): Examine model-based CRM examine(RuleDesign): Examine rule-based design examine(DADesign): Examine model-based CRM","code":""},{"path":"https://openpharma.github.io/crmPack/reference/examine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain hypothetical trial course table for a design — examine","text":"","code":"# Define the dose-grid. emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25))   # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )   my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingMinCohorts(nCohorts = 3) my_stopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) my_stopping3 <- StoppingMinPatients(nPatients = 20) my_stopping <- (my_stopping1 & my_stopping2) | my_stopping3  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. my_design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 3 )  my_options <- McmcOptions(   burnin = 10,   step = 1,   samples = 20,   rng_kind = \"Super-Duper\",   rng_seed = 94 )  # \\donttest{ examine(my_design, my_options) #>   dose DLTs nextDose  stop increment #> 1    3    0        5 FALSE        67 #> 2    3    1        1 FALSE       -67 #> 3    5    0       10 FALSE       100 #> 4    5    1        5 FALSE         0 #> 5   10    0       20 FALSE       100 #> 6   10    1        5 FALSE       -50 #> 7   20    0       25 FALSE        25 #> 8   20    1       20 FALSE         0 # }  # Example where examine stops because stopping rule already fulfilled. my_stopping4 <- StoppingMinPatients(nPatients = 3) my_stopping <- (my_stopping1 & my_stopping2) | my_stopping4  my_design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 3 )  # \\donttest{ examine(my_design, mcmcOptions = my_options) #>   dose DLTs nextDose  stop increment #> 1    3    0        5 FALSE        67 #> 2    3    1        1 FALSE       -67 #> 3    5    0       10 FALSE       100 #> 4    5    1        5 FALSE         0 #> 5   10    0       20  TRUE       100 #> 6   10    1        5  TRUE       -50 # }  # Example where examine stops because infinite looping # (note that here a very low threshold is used for the parameter # \"maxNoIncrement\" in \"examine\" to keep the execution time short). my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.00001) )  my_stopping <- (my_stopping1 & my_stopping2) | StoppingMissingDose()  design <- Design(   model = my_model,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 3 )  # \\donttest{ examine(my_design, mcmcOptions = my_options, maxNoIncrement = 2) #>   dose DLTs nextDose  stop increment #> 1    3    0        5 FALSE        67 #> 2    3    1        1 FALSE       -67 #> 3    5    0       10 FALSE       100 #> 4    5    1        5 FALSE         0 #> 5   10    0       20  TRUE       100 #> 6   10    1        5  TRUE       -50 # } # Define the dose-grid emptydata <- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))  # inizialing a 3+3 design with constant cohort size of 3 and # starting dose equal 5 myDesign <- RuleDesign(   nextBest = NextBestThreePlusThree(),   cohort_size = CohortSizeConst(size = 3L),   data = emptydata,   startingDose = 5 )  # Examine the design set.seed(4235) # \\donttest{ examine(myDesign) #>    dose DLTs nextDose  stop increment #> 1     5    0       10 FALSE       100 #> 2     5    1        5 FALSE         0 #> 3     5    2       NA  TRUE        NA #> 4     5    3       NA  TRUE        NA #> 5    10    0       15 FALSE        50 #> 6    10    1       10 FALSE         0 #> 7    10    2        5 FALSE       -50 #> 8    10    3        5 FALSE       -50 #> 9    15    0       25 FALSE        67 #> 10   15    1       15 FALSE         0 #> 11   15    2       10 FALSE       -33 #> 12   15    3       10 FALSE       -33 #> 13   25    0       35 FALSE        40 #> 14   25    1       25 FALSE         0 #> 15   25    2       15 FALSE       -40 #> 16   25    3       15 FALSE       -40 #> 17   35    0       50 FALSE        43 #> 18   35    1       35 FALSE         0 #> 19   35    2       25 FALSE       -29 #> 20   35    3       25 FALSE       -29 #> 21   50    0       80 FALSE        60 #> 22   50    1       50 FALSE         0 #> 23   50    2       35 FALSE       -30 #> 24   50    3       35 FALSE       -30 # } # nolint start  # Define the dose-grid and PEM parameters emptydata <- DataDA(doseGrid = c(   0.1, 0.5, 1, 1.5, 3, 6,   seq(from = 10, to = 80, by = 2) ), Tmax = 60) # Initialize the mDA-CRM model npiece_ <- 10 Tmax_ <- 60  lambda_prior <- function(k) {   npiece_ / (Tmax_ * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(as.matrix(c(1:npiece_), 1, npiece_), 2, lambda_prior))),   c_par = 2 ) # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping2 <- StoppingMinPatients(nPatients = 50)  myStopping <- (myStopping1 | myStopping2)  # Choose the safety window mysafetywindow <- SafetyWindowConst(c(6, 2), 7, 7)  # Initialize the design design <- DADesign(   model = model,   increments = myIncrements,   nextBest = myNextBest,   stopping = myStopping,   cohort_size = mySize,   data = emptydata,   safetyWindow = mysafetywindow,   startingDose = 3 )  set.seed(4235) # MCMC parameters are set to small values only to show this example. They should be # increased for a real case. # This procedure will take a while. options <- McmcOptions(   burnin = 10,   step = 1,   samples = 100,   rng_kind = \"Mersenne-Twister\",   rng_seed = 12 ) # \\donttest{ testthat::expect_warning(   result <- examine(design, mcmcOptions = options, maxNoIncrement = 2),   \"Stopping because 2 times no increment\" ) # }  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit method for the Samples class — fit","title":"Fit method for the Samples class — fit","text":"Note new generic function necessary fitted function allows first argument object appear signature. need also arguments signature.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit method for the Samples class — fit","text":"","code":"fit(object, model, data, ...)  # S4 method for class 'Samples,GeneralModel,Data' fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for class 'Samples,DualEndpoint,DataDual' fit(object, model, data, quantiles = c(0.025, 0.975), middle = mean, ...)  # S4 method for class 'Samples,LogisticIndepBeta,Data' fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for class 'Samples,Effloglog,DataDual' fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for class 'Samples,EffFlexi,DataDual' fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )  # S4 method for class 'Samples,LogisticLogNormalOrdinal,DataOrdinal' fit(   object,   model,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit method for the Samples class — fit","text":"object Samples object model GeneralModel object data Data object ... passed prob() method. points dose levels fit requested? default dose grid quantiles quantiles calculated (default: 0.025 0.975) middle function computing middle point. Default: mean","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit method for the Samples class — fit","text":"data frame required information (see method details)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fit.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Fit method for the Samples class — fit","text":"fit(object = Samples, model = GeneralModel, data = Data): method returns data frame dose, middle, lower upper quantiles dose-toxicity curve fit(object = Samples, model = DualEndpoint, data = DataDual): method returns data frame dose, middle, lower upper quantiles, dose-tox dose-biomarker (suffix \"Biomarker\") curves, grid points (Note currently grid points can used, DualEndpointRW models allow ) fit(object = Samples, model = LogisticIndepBeta, data = Data): method return data frame dose, middle lower upper quantiles dose-DLE curve using DLE samples “LogisticIndepBeta” model class fit(object = Samples, model = Effloglog, data = DataDual): method returns data frame dose, middle, lower, upper quantiles dose-efficacy curve using efficacy samples “Effloglog” model class fit(object = Samples, model = EffFlexi, data = DataDual): method returns data frame dose, middle, lower upper quantiles dose-efficacy curve using efficacy samples “EffFlexi” model class fit(object = Samples, model = LogisticLogNormalOrdinal, data = DataOrdinal): method returns data frame dose, middle, lower upper quantiles dose-efficacy curve using efficacy samples “LogisticLogNormalOrdinal” model class","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit method for the Samples class — fit","text":"","code":"# nolint start  # Create some data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize a model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get posterior for all model parameters options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Extract the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses fitted <- fit(   object = samples,   model = model,   data = data,   quantiles = c(0.025, 0.975),   middle = mean )   # ---------------------------------------------- # A different example using a different model ## we need a data object with doses >= 1: data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices!   model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) options <- McmcOptions(burnin = 100, step = 2, samples = 200) ## samples must be from 'Samples' class (object slot in fit) samples <- mcmc(data, model, options)  fitted <- fit(object = samples, model = model, data = data)  # nolint end # nolint start  # Create some data data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 50, 50, 50),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1),   w = c(     0.31,     0.42,     0.59,     0.45,     0.6,     0.7,     0.55,     0.6,     0.52,     0.54,     0.56,     0.43,     0.41,     0.39,     0.34,     0.38,     0.21   ),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the Dual-Endpoint model (in this case RW1) model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 500) set.seed(94) samples <- mcmc(data, model, options)  # Extract the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses and the Biomarker by doses fitted <- fit(   object = samples,   model = model,   data = data,   quantiles = c(0.025, 0.975),   middle = mean )  # nolint end ##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-DLE curve ## at all dose levels using a DLE sample, a DLE model and the data ## samples must be from 'Samples' class (object slot) ## we need a data object with doses >= 1: data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be from 'Model' or 'ModelTox' class e.g using 'LogisticIbdepBeta' model class model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ##options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 200) ## samples must be from 'Samples' class (object slot in fit) samples <- mcmc(data, model, options)  fit(object = samples, model = model, data = data) #>    dose    middle      lower     upper #> 1    25 0.2362155 0.08981218 0.4190492 #> 2    50 0.3682220 0.20111117 0.5781557 #> 3    75 0.4575540 0.27620943 0.6661194 #> 4   100 0.5223768 0.33161940 0.7239995 #> 5   125 0.5717475 0.37825701 0.7709958 #> 6   150 0.6107229 0.40917199 0.8141918 #> 7   175 0.6423542 0.42871110 0.8437866 #> 8   200 0.6685943 0.44575657 0.8651832 #> 9   225 0.6907535 0.46059389 0.8819519 #> 10  250 0.7097445 0.47392655 0.8953912 #> 11  275 0.7262234 0.48877922 0.9063659 #> 12  300 0.7406746 0.51041966 0.9148683 ##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-efficacy curve ## at all dose levels using an efficacy sample, a pseudo efficacy model and the data ## data must be from 'DataDual' class data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be from 'ModelEff' e.g using 'Effloglog' class Effmodel <- Effloglog(   c(1.223, 2.513),   c(25, 300),   nu = c(a = 1, b = 0.025),   data = data,   c = 0 ) ## samples must be from 'Samples' class (object slot in fit) options <- McmcOptions(burnin = 100, step = 2, samples = 200) Effsamples <- mcmc(data = data, model = Effmodel, options = options) fit(object = Effsamples, model = Effmodel, data = data) #>    dose   middle      lower    upper #> 1    25 0.465844 -0.1165332 1.007491 #> 2    50 0.822886  0.3886473 1.180275 #> 3    75 1.003435  0.5768330 1.403713 #> 4   100 1.121531  0.6228397 1.630016 #> 5   125 1.208159  0.6601782 1.787815 #> 6   150 1.276017  0.6894266 1.902756 #> 7   175 1.331491  0.7064292 2.018253 #> 8   200 1.378223  0.6925712 2.105017 #> 9   225 1.418476  0.6806345 2.173231 #> 10  250 1.453748  0.6701746 2.233005 #> 11  275 1.485081  0.6687583 2.286102 #> 12  300 1.513225  0.6801521 2.333796 # nolint start  ##Obtain the 'fit' the middle, uppper and lower quantiles for the dose-efficacy curve ## at all dose levels using an efficacy sample, the 'EffFlexi' efficacy model and the data ## data must be from 'DataDual' class data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be from 'ModelEff' e.g using 'Effloglog' class Effmodel <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = data )  ## samples must be from 'Samples' class (object slot in fit) options <- McmcOptions(burnin = 100, step = 2, samples = 200) Effsamples <- mcmc(data = data, model = Effmodel, options = options) fit(object = Effsamples, model = Effmodel, data = data) #>    dose    middle      lower     upper #> 1    25 0.7036011  0.6866660 0.7158120 #> 2    50 0.4494999  0.4100730 0.5051847 #> 3    75 0.5795760  0.5125865 0.6297975 #> 4   100 0.6321164 -1.3094061 2.4041159 #> 5   125 0.5879013 -1.3602565 2.2919075 #> 6   150 0.5246635  0.5162698 0.5419775 #> 7   175 0.6355070 -1.7183340 3.1674019 #> 8   200 0.8103666 -3.1066777 5.2791132 #> 9   225 1.0235281 -4.1707667 5.8087216 #> 10  250 1.4342934 -4.1558082 6.0408674 #> 11  275 1.9401852 -1.9698781 5.1282467 #> 12  300 2.5119573  2.5075891 2.5129950  # nolint end model <- .DefaultLogisticLogNormalOrdinal() ordinal_data <- .DefaultDataOrdinal() options <- .DefaultMcmcOptions() samples <- mcmc(ordinal_data, model, options) #> Warning: Unused variable \"y\" in data  grade1_fit <- fit(samples, model, ordinal_data, grade = 1L) grade2_fit <- fit(samples, model, ordinal_data, grade = 2L)"},{"path":"https://openpharma.github.io/crmPack/reference/fitGain.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the fitted values for the gain values at all dose levels based on a given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample and data. This method returns a data frame with dose, middle, lower and upper quantiles of the gain value samples — fitGain","title":"Get the fitted values for the gain values at all dose levels based on a given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample and data. This method returns a data frame with dose, middle, lower and upper quantiles of the gain value samples — fitGain","text":"Get fitted values gain values dose levels based given pseudo DLE model, DLE sample, pseudo efficacy model, Efficacy sample data. method returns data frame dose, middle, lower upper quantiles gain value samples","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fitGain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the fitted values for the gain values at all dose levels based on a given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample and data. This method returns a data frame with dose, middle, lower and upper quantiles of the gain value samples — fitGain","text":"","code":"fitGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for class 'ModelTox,Samples,ModelEff,Samples,DataDual' fitGain(   DLEmodel,   DLEsamples,   Effmodel,   Effsamples,   data,   points = data@doseGrid,   quantiles = c(0.025, 0.975),   middle = mean,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/fitGain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the fitted values for the gain values at all dose levels based on a given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample and data. This method returns a data frame with dose, middle, lower and upper quantiles of the gain value samples — fitGain","text":"DLEmodel DLE pseudo model ModelTox class object DLEsamples DLE samples Samples class object Effmodel efficacy pseudo model ModelEff class object Effsamples efficacy samples Samples class object data data input DataDual class object ... additional arguments methods points dose levels fit requested? default dose grid quantiles quantiles calculated (default: 0.025 0.975) middle function computing middle point. Default: mean","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fitGain.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get the fitted values for the gain values at all dose levels based on a given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample and data. This method returns a data frame with dose, middle, lower and upper quantiles of the gain value samples — fitGain","text":"fitGain(   DLEmodel = ModelTox,   DLEsamples = Samples,   Effmodel = ModelEff,   Effsamples = Samples,   data = DataDual ): method returns data frame dose, middle, lower, upper quantiles gain values obtained given DLE efficacy samples","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fitGain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the fitted values for the gain values at all dose levels based on a given pseudo DLE model, DLE sample, a pseudo efficacy model, a Efficacy sample and data. This method returns a data frame with dose, middle, lower and upper quantiles of the gain value samples — fitGain","text":"","code":"##Obtain the 'fitGain' the middle, uppper and lower quantiles for the samples of gain values ## at all dose levels using a pseudo DLE model, a DLE sample, a pseudo Efficacy model and ## a efficacy sample ## data must be from 'DataDual' class data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ## DLE model must be from 'ModelTox' class e.g using 'LogisticIndepBeta' model DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ## Efficacy model must be from 'ModelEff' class e.g using 'Effloglog' model Effmodel <- Effloglog(   c(1.223, 2.513),   c(25, 300),   nu = c(a = 1, b = 0.025),   data = data,   c = 0 ) ## samples must be from 'Samples' class (object slot in fit) options <- McmcOptions(burnin = 100, step = 2, samples = 200) ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x = data@x, y = data@y, doseGrid = data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices!  DLEsamples <- mcmc(data = data1, model = DLEmodel, options = options) Effsamples <- mcmc(data = data, model = Effmodel, options = options)  fitGain(   DLEmodel = DLEmodel,   DLEsamples = DLEsamples,   Effmodel = Effmodel,   Effsamples = Effsamples,   data = data ) #>    dose    middle       lower     upper #> 1    25 0.3005989 -0.08718754 0.7332158 #> 2    50 0.5185839  0.23160384 0.8886416 #> 3    75 0.6105264  0.30266627 0.9820510 #> 4   100 0.6618601  0.30095400 1.0883378 #> 5   125 0.6946738  0.28103149 1.1346464 #> 6   150 0.7174815  0.26318215 1.2011287 #> 7   175 0.7342843  0.25135980 1.2535173 #> 8   200 0.7472094  0.23857418 1.2962004 #> 9   225 0.7574892  0.22706268 1.3318520 #> 10  250 0.7658857  0.21668277 1.3754153 #> 11  275 0.7728943  0.20729352 1.4124810 #> 12  300 0.7788504  0.19876788 1.4322783 ##Obtain the 'fitGain' the middle, uppper and lower quantiles for the samples of gain values ## at all dose levels using a pseudo DLE model, a DLE sample, a pseudo Efficacy model and ## a efficacy sample ## data must be from 'DataDual' class data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ## DLE model must be from 'ModelTox' class e.g using 'LogisticIndepBeta' model DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ## Efficacy model must be from 'ModelEff' class e.g using 'Effloglog' model Effmodel <- Effloglog(   c(1.223, 2.513),   c(25, 300),   nu = c(a = 1, b = 0.025),   data = data,   c = 0 ) ## samples must be from 'Samples' class (object slot in fit) options <- McmcOptions(burnin = 100, step = 2, samples = 200) ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x = data@x, y = data@y, doseGrid = data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices!  DLEsamples <- mcmc(data = data1, model = DLEmodel, options = options) Effsamples <- mcmc(data = data, model = Effmodel, options = options)  fitGain(   DLEmodel = DLEmodel,   DLEsamples = DLEsamples,   Effmodel = Effmodel,   Effsamples = Effsamples,   data = data ) #>    dose    middle      lower     upper #> 1    25 0.3035639 -0.1419281 0.7336815 #> 2    50 0.5442238  0.2441919 0.8627864 #> 3    75 0.6400330  0.3130091 1.0534260 #> 4   100 0.6901998  0.3051387 1.1878586 #> 5   125 0.7198842  0.2679615 1.2763298 #> 6   150 0.7386820  0.2648011 1.3378176 #> 7   175 0.7510732  0.2812509 1.3772132 #> 8   200 0.7594264  0.2943053 1.4172885 #> 9   225 0.7651054  0.2841997 1.4543642 #> 10  250 0.7689465  0.2694592 1.4789627 #> 11  275 0.7714876  0.2563641 1.4993280 #> 12  300 0.7730880  0.2446324 1.5163999"},{"path":"https://openpharma.github.io/crmPack/reference/fitPEM.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the fitted DLT free survival (piecewise exponential model). This function returns a data frame with dose, middle, lower and upper quantiles for the PEM curve. If hazard=TRUE, — fitPEM","title":"Get the fitted DLT free survival (piecewise exponential model). This function returns a data frame with dose, middle, lower and upper quantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"Get fitted DLT free survival (piecewise exponential model). function returns data frame dose, middle, lower upper quantiles PEM curve. hazard=TRUE,","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fitPEM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the fitted DLT free survival (piecewise exponential model). This function returns a data frame with dose, middle, lower and upper quantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"","code":"fitPEM(   object,   model,   data,   quantiles = c(0.025, 0.975),   middle = mean,   hazard = FALSE,   ... )  # S4 method for class 'Samples,DALogisticLogNormal,DataDA' fitPEM(   object,   model,   data,   quantiles = c(0.025, 0.975),   middle = mean,   hazard = FALSE,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/fitPEM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the fitted DLT free survival (piecewise exponential model). This function returns a data frame with dose, middle, lower and upper quantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"object mcmc samples model mDA-CRM model data data input, DataDA class object quantiles quantiles calculated (default: 0.025 0.975) middle function computing middle point. Default: mean hazard hazard time plotted based PEM? (default) Otherwise ... ... additional arguments methods","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fitPEM.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Get the fitted DLT free survival (piecewise exponential model). This function returns a data frame with dose, middle, lower and upper quantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"fitPEM(object = Samples, model = DALogisticLogNormal, data = DataDA): method works DALogisticLogNormal model class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/fitPEM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the fitted DLT free survival (piecewise exponential model). This function returns a data frame with dose, middle, lower and upper quantiles for the PEM curve. If hazard=TRUE, — fitPEM","text":"","code":"# nolint start  # Create the data data <- DataDA(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   ID = 1L:8L,   cohort = as.integer(c(1:5, 6, 6, 6)),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ),   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60 )  # Initialize the CRM model used to model the data npiece_ <- 10 lambda_prior <- function(k) {   npiece_ / (data@Tmax * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(     as.matrix(c(1:npiece_), 1, npiece_),     2,     lambda_prior   ))),   c_par = 2 )  # Obtain the posterior  options <- McmcOptions(   burnin = 10,   step = 2,   samples = 1e2 )  set.seed(94) samples <- mcmc(data, model, options)   # Extract the posterior mean hazard (and empirical 2.5 and 97.5 percentile) # for the piecewise exponential model # If hazard=FALSE, the posterior PEM will be plot fitted <- fitPEM(   object = samples,   model = model,   data = data,   middle = mean,   hazard = TRUE,   quantiles = c(0.25, 0.75) )  # nolint end"},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/gain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and Using Optional Samples. — gain","text":"","code":"gain(dose, model_dle, samples_dle, model_eff, samples_eff, ...)  # S4 method for class 'numeric,ModelTox,Samples,ModelEff,Samples' gain(dose, model_dle, samples_dle, model_eff, samples_eff, ...)  # S4 method for class 'numeric,ModelTox,missing,Effloglog,missing' gain(dose, model_dle, samples_dle, model_eff, samples_eff, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/gain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and Using Optional Samples. — gain","text":"dose (number numeric) dose targeted. following recycling rule applies samples missing: vectors size 1 recycled size sample. Otherwise, dose must size sample. model_dle (ModelTox) pseudo DLE (dose-limiting events)/toxicity model. samples_dle (Samples) samples model's parameters used compute toxicity probabilities. Can also missing models. model_eff (ModelEff) efficacy model pseudo data prior. samples_eff (Samples) samples model's parameters used compute expected efficacy values. Can also missing models. ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/gain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and Using Optional Samples. — gain","text":"gain values.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/gain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and Using Optional Samples. — gain","text":"function computes gain values given dose level, pseudo DLE Efficacy models well given DLE Efficacy samples.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/gain.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and Using Optional Samples. — gain","text":"gain(   dose = numeric,   model_dle = ModelTox,   samples_dle = Samples,   model_eff = ModelEff,   samples_eff = Samples ): gain(   dose = numeric,   model_dle = ModelTox,   samples_dle = missing,   model_eff = Effloglog,   samples_eff = missing ): Compute gain value given dose level, pseudo DLE Efficacy models without DLE Efficacy samples.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/gain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Gain Values based on Pseudo DLE and a Pseudo Efficacy Models and Using Optional Samples. — gain","text":"","code":"# Obtain the gain value for a given dose, a pseudo DLE and efficacy models # as well as DLE and efficacy samples. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) mcmc_opts <- McmcOptions(burnin = 100, step = 2, samples = 200)  # DLE model and samples. model_dle <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  samples_dle <- mcmc(emptydata, model_dle, mcmc_opts)  # Efficacy model (Effloglog) and samples. model_effloglog <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  samples_effloglog <- mcmc(emptydata, model_effloglog, mcmc_opts)  # Gain values for dose level 75 and Effloglog efficacy model. gain(   dose = 75,   model_dle = model_dle,   samples_dle = samples_dle,   model_eff = model_effloglog,   samples_eff = samples_effloglog ) #>   [1] 1.3724463 1.1163011 1.1876543 0.5601303 1.6102540 0.6156309 1.0702110 #>   [8] 1.4812699 1.4689083 0.5991908 0.9135514 1.4188588 0.8914392 0.9510920 #>  [15] 0.9962461 0.8646416 1.4064603 0.6449197 0.6616455 0.8855359 0.6516058 #>  [22] 0.4573677 0.2922851 1.5184059 0.7864663 0.7575013 0.6550523 1.4341707 #>  [29] 0.6397446 0.5902374 1.3455265 0.5084815 0.6228258 0.2742999 1.1028332 #>  [36] 1.2683656 1.4552391 1.7914810 1.2640065 0.8954424 0.4557674 0.7072762 #>  [43] 0.6508919 0.9339104 0.6563602 1.0341947 0.5346614 0.9638692 1.2067207 #>  [50] 1.3048691 1.3450987 0.2951774 1.2150462 1.2154166 0.6994934 0.9380233 #>  [57] 1.6054284 1.4631007 0.7170195 1.1514112 1.2336247 0.7694697 0.6456181 #>  [64] 1.2906157 1.3531875 0.9304359 1.2255894 1.2325904 1.2405950 1.7368240 #>  [71] 0.8030362 1.3514498 1.2226824 0.4009393 1.0961200 1.3827692 1.3408870 #>  [78] 1.0155697 1.3858920 0.7852963 1.0389329 0.7076404 0.9516520 1.2265820 #>  [85] 0.6453395 1.1631187 1.1300966 1.0829065 1.3729595 0.6465427 0.9005294 #>  [92] 1.0391913 1.0106432 1.2346600 0.9347928 0.4895462 0.4382956 1.3669563 #>  [99] 1.2218775 0.8111870 0.4934214 1.1457987 1.1405332 1.1489580 1.4535811 #> [106] 0.3077070 1.2252347 1.5443211 1.3362472 1.1712998 1.0014473 1.1369257 #> [113] 0.8171996 0.2649928 1.1712471 0.4232131 1.0481358 1.4055183 1.3802208 #> [120] 1.1189702 0.9606329 1.2678369 1.2700036 0.5651039 1.8531221 1.5108585 #> [127] 1.5765327 1.1742238 1.5648763 1.0839926 0.9758415 0.8558122 1.1538830 #> [134] 1.1561811 1.4922312 0.9087434 0.6369058 1.1785576 1.2719208 0.7536225 #> [141] 0.4610063 1.0802367 1.2740320 0.7842036 1.5808339 1.4593170 0.6581335 #> [148] 0.5965571 1.1217183 1.6115560 0.9235499 1.4685061 0.9808467 0.4309496 #> [155] 1.4693931 1.1060406 1.7424236 0.6815545 0.9528618 1.3946497 1.0070073 #> [162] 0.9412750 0.6710952 1.3174514 1.4569902 0.9076429 0.1721784 0.6274587 #> [169] 1.0012481 0.6883088 1.0717720 1.3573660 1.2150049 1.7473766 1.1468327 #> [176] 0.6136378 1.1348749 1.0056950 1.2825347 1.2099100 1.1442010 1.3166977 #> [183] 0.6235300 1.0662774 0.8839399 0.8752322 1.2075558 0.8035865 1.1490294 #> [190] 0.8053042 0.8663338 1.7354374 0.9656245 0.7848750 1.0084461 1.1694038 #> [197] 1.1076468 1.2395853 1.3728410 1.1775367  # Efficacy model (EffFlexi) and samples. model_effflexi <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  samples_effflexi <- mcmc(emptydata, model_effflexi, mcmc_opts)  # Gain values for dose level 75 and EffFlexi efficacy model. gain(   dose = 75,   model_dle = model_dle,   samples_dle = samples_dle,   model_eff = model_effflexi,   samples_eff = samples_effflexi ) #>   [1] -7.797762012 -0.199336986  2.523438672  0.214818998 -0.547251404 #>   [6] -0.828895061 -0.077208139  4.198925893 -2.514839633 -0.993067176 #>  [11] -2.132389402  3.077140329  1.501540022  0.965118633  2.448944419 #>  [16]  1.603548539  0.184034225  0.557697919 -1.952719644  2.492728818 #>  [21] -0.846354589  1.614736279  0.041034314 -1.658099056  0.062305215 #>  [26]  0.929473739  1.467771682  5.695943231  2.757768442 -0.081225987 #>  [31]  6.972030665  3.929777824  0.289435533  0.816732419  2.506860558 #>  [36] -0.425530328 -2.334480198  0.586245417 -3.720766029  0.137125761 #>  [41]  1.426266668  2.928028475  2.507657658  0.594944379  1.404831845 #>  [46] -1.769188692  2.344694257  2.425595600 -3.724049447  5.721211847 #>  [51]  1.240789611  0.661480509 -0.935456834  1.859864240  3.598570254 #>  [56]  4.066092601 -0.283984842 -1.789499719  2.291953834 -0.340493900 #>  [61]  2.729746082  3.088494146  0.002428012  5.549212571  2.237065518 #>  [66] -1.146073828 -1.215629407  4.093263442  4.365740674 -3.579946118 #>  [71]  0.868637136 -0.796092404  1.728214732  1.480074653  3.188259955 #>  [76]  1.805344902 -1.316897949  0.917944815  2.347651429 -2.057661335 #>  [81]  1.924687634 -0.059670211  2.093612794 -0.844486312 -1.187736649 #>  [86]  4.166443525 -6.163708089 -2.062453988  0.389062104 -0.293947515 #>  [91]  3.633662621  7.428196399 -0.427327028  0.842044527  1.278787634 #>  [96] -1.228131627  1.172618349  7.690292673 -2.492784535  1.276139945 #> [101]  0.093697215 -0.505052555 -0.776274633  0.063380404 -2.593648360 #> [106]  0.261357399 -1.711652634  1.622242271 -0.362393167  4.461089005 #> [111]  3.450033563  6.051686737 -1.351043509  1.375461317 -3.742672152 #> [116]  0.242883309 -3.645677222  4.822342119  2.679937625  2.173108830 #> [121]  0.348438489  0.070456192  4.777059451  5.306383005  3.369429858 #> [126]  6.363568789  2.947605736  0.669428991 -4.638862209 -0.544622733 #> [131]  0.993147986  0.850065911  4.797947307 -0.434228667 -0.487685678 #> [136] -0.263474416 -0.130119997 -1.364954217  1.327120227  1.435113453 #> [141]  1.800903129  2.340832586 -2.214719403 -2.190862346 -1.090888958 #> [146] -0.571400968  1.106625717  3.326360639  0.832149924  4.986322978 #> [151]  4.470591160 -0.643807544  3.225924662  1.616645210 -3.171086291 #> [156] -1.400515992 -7.580812166 -1.147022482  3.689024159  5.515599083 #> [161] -0.133504677  1.728566992  2.175123544  8.539899820  2.385615370 #> [166]  6.408512552 -0.585672716 -1.243101730  7.299838519  0.975173504 #> [171]  4.320059944 -4.355521566 -0.778941163  2.320029619  4.591606364 #> [176]  1.794935961  3.213033813 -1.320620632  3.283390555  3.408311801 #> [181]  2.528529997  0.216659653 -0.362232228  0.796268488  3.334793341 #> [186]  3.359729037  3.392465865  1.565422596  5.336320093 -0.466097505 #> [191]  1.968541610  3.428795440 -0.408071475  1.622276788 -4.710188753 #> [196] -1.358776379  1.004604940  2.729044949  2.522123248 -0.558105107 # Obtain the gain value for a given dose, a pseudo DLE and efficacy models # without DLE and efficacy samples. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) data <- Data(doseGrid = seq(25, 300, 25), placebo = FALSE) mcmc_opts <- McmcOptions(burnin = 100, step = 2, samples = 200)  # DLE model and samples. model_dle <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  # Efficacy model and samples. model_eff <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # Gain value for dose level 75. gain(   dose = 75,   model_dle = model_dle,   model_eff = model_eff ) #> [1] 1.020657"},{"path":"https://openpharma.github.io/crmPack/reference/get-Samples-character-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"specify pos parameter like extract Samples object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/get-Samples-character-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"","code":"# S4 method for class 'Samples,character' get(x, pos = -1L, envir = NULL, mode = NULL, inherits = NULL)"},{"path":"https://openpharma.github.io/crmPack/reference/get-Samples-character-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"x Samples object pos name parameter envir vectorial parameters, can give indices elements like extract. NULL, whole vector samples returned mode used inherits used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/get-Samples-character-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"data frame suitable use ggmcmc","code":""},{"path":"https://openpharma.github.io/crmPack/reference/get-Samples-character-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get specific parameter samples and produce a data.frame — get,Samples,character-method","text":"","code":"# nolint start  # Create some data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize a model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get posterior for all model parameters options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # now extract the alpha0 samples (intercept of the regression model) alpha0samples <- get(samples, \"alpha0\")  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/getEff.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"method extracts efficacy responses subjects categorizes respect DLT, .e. DLT DLT. efficacy responses reported together corresponding dose levels.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/getEff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"","code":"getEff(object, ...)  # S4 method for class 'DataDual' getEff(object, no_dlt = FALSE)"},{"path":"https://openpharma.github.io/crmPack/reference/getEff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"object (DataDual) object responses dose levels extracted. ... arguments passed class-specific methods. no_dlt (flag) DLT responses returned? Otherwise, responses returned.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/getEff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"list efficacy responses categorized DLT value.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/getEff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extracting Efficacy Responses for Subjects Categorized by the DLT — getEff","text":"","code":"# Example data. data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Get the efficacy response and their corresponding dose levels # categorized by the DLT. getEff(data) #> $x_no_dlt #> [1]  25  50  25  50  75 150 #>  #> $w_no_dlt #> [1] 0.31 0.42 0.59 0.45 0.60 0.52 #>  #> $x_dlt #> [1] 300 250 #>  #> $w_dlt #> [1] 0.7 0.6 #>"},{"path":"https://openpharma.github.io/crmPack/reference/get_result_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to Obtain Simulation Results List — get_result_list","title":"Helper Function to Obtain Simulation Results List — get_result_list","text":"function fun can use variables visible . names variables given vector vars.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/get_result_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to Obtain Simulation Results List — get_result_list","text":"","code":"get_result_list(fun, nsim, vars, parallel, n_cores)"},{"path":"https://openpharma.github.io/crmPack/reference/get_result_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to Obtain Simulation Results List — get_result_list","text":"fun (function) simulation function single iteration, takes single parameter iteration index. nsim number simulations conducted. vars names variables. parallel simulation runs parallelized across clusters computer? n_cores many cores used parallel computing?","code":""},{"path":"https://openpharma.github.io/crmPack/reference/get_result_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to Obtain Simulation Results List — get_result_list","text":"list simulation results (one iteration corresponds one list element).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_all_equivalent.html","id":null,"dir":"Reference","previous_headings":"","what":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"helper function ensures default tolerance level equal 1e-10, ignores names attributes. contrast .equal(), always returns logical type object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_all_equivalent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"","code":"h_all_equivalent(target, current, tolerance = 1e-10)"},{"path":"https://openpharma.github.io/crmPack/reference/h_all_equivalent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"target (numeric) target values. current (numeric) current values. tolerance (number) relative differences smaller reported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_all_equivalent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Comparison with Numerical Tolerance and Without Name Comparison — h_all_equivalent","text":"TRUE target current differ desired tolerance without looking names attributes, FALSE otherwise.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_barplot_percentages.html","id":null,"dir":"Reference","previous_headings":"","what":"Convenience function to make barplots of percentages — h_barplot_percentages","title":"Convenience function to make barplots of percentages — h_barplot_percentages","text":"Convenience function make barplots percentages","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_barplot_percentages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convenience function to make barplots of percentages — h_barplot_percentages","text":"","code":"h_barplot_percentages(x, description, xaxisround = 0)"},{"path":"https://openpharma.github.io/crmPack/reference/h_barplot_percentages.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convenience function to make barplots of percentages — h_barplot_percentages","text":"x vector samples description xlab string xaxisround rounding xaxis labels (default: 0, .e. integers used)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_barplot_percentages.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convenience function to make barplots of percentages — h_barplot_percentages","text":"ggplot2 object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_blind_plot_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to Blind Plot Data — h_blind_plot_data","title":"Helper Function to Blind Plot Data — h_blind_plot_data","text":"Helper Function Blind Plot Data","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_blind_plot_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to Blind Plot Data — h_blind_plot_data","text":"","code":"h_blind_plot_data(df, blind, has_placebo, pbo_dose)"},{"path":"https://openpharma.github.io/crmPack/reference/h_blind_plot_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to Blind Plot Data — h_blind_plot_data","text":"df (GeneralData) data blinded blind (flag) data blinded? has_placebo (flag) data contain placebo dose? pbo_dose (positive_number) dose taken placebo. Ignored has_placebo FALSE","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_blind_plot_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to Blind Plot Data — h_blind_plot_data","text":"blinded data","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_calc_report_label_percentage.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to calculate percentage of true stopping rules for report label output calculates true column means and converts output into percentages before combining the output with the report label; output is passed to show() and output with cat to console — h_calc_report_label_percentage","title":"Helper function to calculate percentage of true stopping rules for report label output calculates true column means and converts output into percentages before combining the output with the report label; output is passed to show() and output with cat to console — h_calc_report_label_percentage","text":"Helper function calculate percentage true stopping rules report label output calculates true column means converts output percentages combining output report label; output passed show() output cat console","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_calc_report_label_percentage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to calculate percentage of true stopping rules for report label output calculates true column means and converts output into percentages before combining the output with the report label; output is passed to show() and output with cat to console — h_calc_report_label_percentage","text":"","code":"h_calc_report_label_percentage(stop_report)"},{"path":"https://openpharma.github.io/crmPack/reference/h_calc_report_label_percentage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to calculate percentage of true stopping rules for report label output calculates true column means and converts output into percentages before combining the output with the report label; output is passed to show() and output with cat to console — h_calc_report_label_percentage","text":"stop_report object summary method","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_calc_report_label_percentage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to calculate percentage of true stopping rules for report label output calculates true column means and converts output into percentages before combining the output with the report label; output is passed to show() and output with cat to console — h_calc_report_label_percentage","text":"named list label percentage rule activation","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_check_fun_formals.html","id":null,"dir":"Reference","previous_headings":"","what":"Checking Formals of a Function — h_check_fun_formals","title":"Checking Formals of a Function — h_check_fun_formals","text":"helper function checks whether given function fun required allowed arguments. argument check based names arguments. logic verified .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_check_fun_formals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checking Formals of a Function — h_check_fun_formals","text":"","code":"h_check_fun_formals(fun, mandatory = NULL, allowed = NULL)"},{"path":"https://openpharma.github.io/crmPack/reference/h_check_fun_formals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checking Formals of a Function — h_check_fun_formals","text":"fun (function) function name whose argument names checked. mandatory (character NULL) names arguments must present fun. mandatory specified NULL (default) requirement ignored. allowed (character NULL) names arguments allowed fun. Names belong allowed simply allowed. allowed parameter independent mandatory, sense mandatory specified character vector, repeated allowed. allowed specified NULL (default), means must arguments fun (except ones specified mandatory).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a Ordinal Data to the Equivalent Binary Data for a Specific Grade — h_convert_ordinal_data","title":"Convert a Ordinal Data to the Equivalent Binary Data for a Specific Grade — h_convert_ordinal_data","text":"simple helper function takes DataOrdinal object integer grade converts equivalent Data object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a Ordinal Data to the Equivalent Binary Data for a Specific Grade — h_convert_ordinal_data","text":"","code":"h_convert_ordinal_data(data_ord, grade)"},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a Ordinal Data to the Equivalent Binary Data for a Specific Grade — h_convert_ordinal_data","text":"data_ord (DataOrdinal) DataOrdinal object covert grade (integer) toxicity grade equivalent data required.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a Ordinal Data to the Equivalent Binary Data for a Specific Grade — h_convert_ordinal_data","text":"Data object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an ordinal CRM model to the Equivalent Binary CRM Model for a Specific Grade — h_convert_ordinal_model","title":"Convert an ordinal CRM model to the Equivalent Binary CRM Model for a Specific Grade — h_convert_ordinal_model","text":"simple helper function takes LogisticLogNormalOrdinal integer grade converts equivalent LogisticLogNormal model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an ordinal CRM model to the Equivalent Binary CRM Model for a Specific Grade — h_convert_ordinal_model","text":"","code":"h_convert_ordinal_model(x, grade)"},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an ordinal CRM model to the Equivalent Binary CRM Model for a Specific Grade — h_convert_ordinal_model","text":"x (LogisticLogNormalOrdinal) LogisticLogNormalOrdinal model covert grade (integer) toxicity grade equivalent model required.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an ordinal CRM model to the Equivalent Binary CRM Model for a Specific Grade — h_convert_ordinal_model","text":"LogisticLogNormal model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a Samples Object from an ordinal Model to the Equivalent Samples Object from a Binary Model — h_convert_ordinal_samples","title":"Convert a Samples Object from an ordinal Model to the Equivalent Samples Object from a Binary Model — h_convert_ordinal_samples","text":"simple helper function converts Samples object fit ordinal CRM model obtained fitting binary CRM model toxicities specified grade observed data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a Samples Object from an ordinal Model to the Equivalent Samples Object from a Binary Model — h_convert_ordinal_samples","text":"","code":"h_convert_ordinal_samples(obj, grade)"},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a Samples Object from an ordinal Model to the Equivalent Samples Object from a Binary Model — h_convert_ordinal_samples","text":"obj (Samples) Samples object covert grade (integer) toxicity grade equivalent data required.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_convert_ordinal_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a Samples Object from an ordinal Model to the Equivalent Samples Object from a Binary Model — h_convert_ordinal_samples","text":"Samples object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_covr_helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"Workarounds allow package continue work running covr minimal changes package code.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_covr_helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"","code":"h_covr_active()  h_covr_detrace(expr)  h_is_covr_trace(expr)  h_covr_detrace_call(expr)"},{"path":"https://openpharma.github.io/crmPack/reference/h_covr_helpers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"expr (language) R expression call test strip covr trace counters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_covr_helpers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"logical value transformed expression calls covr:::count removed.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_covr_helpers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"using covr, source code package objects modified add callbacks expression log execution. Given arbitrary expression, :   code modified executing package code look like:   functions used stripping expressions code package continues work intended running tests part running covr calculate package coverage. method non-exhaustive, covering subset covr's tracing behaviors necessary package.","code":"expr if (TRUE) {   covr:::count(\"file.R:1:2:3:4:5:6:7:8\")   expr }"},{"path":"https://openpharma.github.io/crmPack/reference/h_covr_helpers.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Helpers for stripping expressions of covr-inserted trace code — h_covr_helpers","text":"h_covr_active(): Determine whether covr currently running h_covr_detrace(): Remove covr traces expression h_is_covr_trace(): Determine whether current expression covr-modified expression h_covr_detrace_call(): Extract original expression covr-modified expression","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_default_if_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the default value for an empty object — h_default_if_empty","title":"Getting the default value for an empty object — h_default_if_empty","text":"simple helper function sets default value empty missing object, object length() function returns 0L length 1 .na() returns TRUE.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_default_if_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the default value for an empty object — h_default_if_empty","text":"","code":"h_default_if_empty(x, default)"},{"path":"https://openpharma.github.io/crmPack/reference/h_default_if_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the default value for an empty object — h_default_if_empty","text":"x ()  object handle. can object length() function defined. default ()  default value x object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_default_if_empty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the default value for an empty object — h_default_if_empty","text":"","code":"h_default_if_empty(character(0), default = \"default label\") #> [1] \"default label\" h_default_if_empty(\"custom label\", default = \"default label\") #> [1] \"custom label\" h_default_if_empty(NA, default = \"default label\") #> [1] \"default label\""},{"path":"https://openpharma.github.io/crmPack/reference/h_determine_dlts.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to determine the dlts including first separate and placebo condition — h_determine_dlts","title":"Helper function to determine the dlts including first separate and placebo condition — h_determine_dlts","text":"Helper function determine dlts including first separate placebo condition","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_determine_dlts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to determine the dlts including first separate and placebo condition — h_determine_dlts","text":"","code":"h_determine_dlts(   data,   dose,   prob,   prob_placebo,   cohort_size,   cohort_size_placebo,   dose_grid,   first_separate )"},{"path":"https://openpharma.github.io/crmPack/reference/h_determine_dlts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to determine the dlts including first separate and placebo condition — h_determine_dlts","text":"data (Data) data start . dose (number) current dose. prob (function) defines true probability DLT dose. prob_placebo (function) defines true probability DLT placebo condition. cohort_size (number) cohort size use. cohort_size_placebo (number) cohort size use placebo condition. dose_grid (numeric) dose_grid specified user. first_separate (flag) whether first patient enrolled separately.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_determine_dlts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to determine the dlts including first separate and placebo condition — h_determine_dlts","text":"updated data object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_find_interval.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"simple wrapper findInterval() function invokes findInterval(), takes output replaces elements \\(0\\) value custom number specified replacement argument.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_find_interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"","code":"h_find_interval(..., replacement = -Inf)"},{"path":"https://openpharma.github.io/crmPack/reference/h_find_interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"... Arguments passed base::findInterval x numeric. vec numeric, sorted (weakly) increasingly, length N,     say. rightmost.closed logical; true, rightmost interval,     vec[N-1] .. vec[N] treated closed, see . .inside logical; true, returned indices coerced     1,...,N-1, .e., 0 mapped 1     N N-1. left.open logical; true intervals open left     closed right; formulas , \\(\\le\\)     swapped \\(<\\) (\\(>\\) \\(\\ge\\)),     rightmost.closed means ‘leftmost closed’.  may     useful, e.g., survival analysis computations. checkSorted logical indicating vec checked,     .e., .unsorted(vec) asserted false.  Setting     FALSE skips check gaining speed, may return     nonsense results case vec sorted. checkNA logical indicating x[] checked     .na(.).  Setting FALSE case     NA's x[] may result platform dependent nonsense. replacement (number) custom number used replacement \\(0\\). Default -Inf.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_find_interval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find Interval Numbers or Indices and Return Custom Number For 0. — h_find_interval","text":"","code":"h_find_interval(1, c(2, 4, 6)) #> [1] -Inf h_find_interval(3, c(2, 4, 6)) #> [1] 1 h_find_interval(1, c(2, 4, 6), replacement = -1) #> [1] -1"},{"path":"https://openpharma.github.io/crmPack/reference/h_format_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Formatting Using C-style Formats — h_format_number","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"helper function conditionally formats number formatC() function using \"E\" format specific number digits given user. number formatted absolute value less 0.001 greater 10000. Otherwise, number formatted. Additionally, custom prefix suffix can appended character string formatted number, changes marked.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_format_number.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"","code":"h_format_number(x, digits = 5, prefix = \"\", suffix = \"\")"},{"path":"https://openpharma.github.io/crmPack/reference/h_format_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"x (number) number formatted. digits (function) desired number significant digits. prefix (string) prefix added front formatted number. suffix (string) suffix appended formatted number.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_format_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"Either formatted x string unchanged x formatting condition met.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_format_number.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"function primarily designed helper h_jags_write_model() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_format_number.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Formatting Using C-style Formats — h_format_number","text":"","code":"h_format_number(50000) #> [1] \"5.00000E+04\" h_format_number(50000, prefix = \"P\", suffix = \"S\") #> [1] \"P5.00000E+04S\""},{"path":"https://openpharma.github.io/crmPack/reference/h_get_formatted_dosegrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Format a doseGrid for Printing — h_get_formatted_dosegrid","title":"Format a doseGrid for Printing — h_get_formatted_dosegrid","text":"Format doseGrid Printing","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_get_formatted_dosegrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format a doseGrid for Printing — h_get_formatted_dosegrid","text":"","code":"h_get_formatted_dosegrid(grid, units = NA, fmt = NA, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/h_get_formatted_dosegrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format a doseGrid for Printing — h_get_formatted_dosegrid","text":"grid (numeric) dose grid units (character) units values doseGrid fmt (character) format used display values doseGrid. NA, grid values pre-formatted ... used present measured.  Appended value doseGrid knit_printed.  default, NA, omits units.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_get_formatted_dosegrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format a doseGrid for Printing — h_get_formatted_dosegrid","text":"character string containing formatted dose grid.  grid c(1, 2, 3) units \"mg\", returned value \"1 mg, 2 mg 3 mg\".","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_get_min_inf_beta.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper for Minimal Informative Unimodal Beta Distribution — h_get_min_inf_beta","title":"Helper for Minimal Informative Unimodal Beta Distribution — h_get_min_inf_beta","text":"defined Neuenschwander et al (2008), function computes parameters minimal informative unimodal beta distribution, given request p-quantile q, .e. X ~ (, b) Pr(X <= q) = p.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_get_min_inf_beta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper for Minimal Informative Unimodal Beta Distribution — h_get_min_inf_beta","text":"","code":"h_get_min_inf_beta(p, q)"},{"path":"https://openpharma.github.io/crmPack/reference/h_get_min_inf_beta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper for Minimal Informative Unimodal Beta Distribution — h_get_min_inf_beta","text":"p (number) probability. q (number) quantile.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_get_min_inf_beta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper for Minimal Informative Unimodal Beta Distribution — h_get_min_inf_beta","text":"list two resulting beta parameters b.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_group_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Group Together Mono and Combo Data — h_group_data","title":"Group Together Mono and Combo Data — h_group_data","text":"used simulation method DesignGrouped combine separately generated data sets mono combo arms fit combined logistic regression model. Hence ID cohort information relevant arbitrarily assigned avoid problems DataGrouped validation.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_group_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group Together Mono and Combo Data — h_group_data","text":"","code":"h_group_data(mono_data, combo_data)"},{"path":"https://openpharma.github.io/crmPack/reference/h_group_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group Together Mono and Combo Data — h_group_data","text":"mono_data (Data) mono data. combo_data (Data) combo data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_group_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group Together Mono and Combo Data — h_group_data","text":"DataGrouped object containing mono_data combo_data, arbitrary ID cohort slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_in_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Check which elements are in a given range — h_in_range","title":"Check which elements are in a given range — h_in_range","text":"simple helper function tests whether elements given vector matrix within specified interval.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_in_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check which elements are in a given range — h_in_range","text":"","code":"h_in_range(x, range = c(0, 1), bounds_closed = TRUE)"},{"path":"https://openpharma.github.io/crmPack/reference/h_in_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check which elements are in a given range — h_in_range","text":"x (numeric) vector matrix elements test. range (numeric) interval, .e. sorted two-elements vector. bounds_closed (logical) bounds range treated closed? can scalar vector length two. scalar, value applies lower bound range[1] upper bound range[2]. vector two flags, first flag corresponds lower bound , second upper bound .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_in_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check which elements are in a given range — h_in_range","text":"logical vector matrix length equal length x, every element x, indicates whether given element x range.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_in_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check which elements are in a given range — h_in_range","text":"","code":"x <- 1:4 h_in_range(x, range = c(1, 3)) #> [1]  TRUE  TRUE  TRUE FALSE h_in_range(x, range = c(1, 3), bounds_closed = FALSE) #> [1] FALSE  TRUE FALSE FALSE h_in_range(x, range = c(1, 3), bounds_closed = c(FALSE, TRUE)) #> [1] FALSE  TRUE  TRUE FALSE mat <- matrix(c(2, 5, 3, 10, 4, 9, 1, 8, 7), nrow = 3) h_in_range(mat, range = c(1, 5)) #>      [,1]  [,2]  [,3] #> [1,] TRUE FALSE  TRUE #> [2,] TRUE  TRUE FALSE #> [3,] TRUE FALSE FALSE"},{"path":"https://openpharma.github.io/crmPack/reference/h_info_theory_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculating the Information Theoretic Distance — h_info_theory_dist","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"Helper function provides value divergence given equation (7) reference https://doi.org/10.1002/sim.8450.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_info_theory_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"","code":"h_info_theory_dist(prob, target, asymmetry)"},{"path":"https://openpharma.github.io/crmPack/reference/h_info_theory_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"prob (numeric) vector matrix probabilities DLT occurring. target (number ) single target probability DLT. asymmetry (number) describes rate penalization overly toxic , range 0 2.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_info_theory_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculating the Information Theoretic Distance — h_info_theory_dist","text":"","code":"h_info_theory_dist(c(0.5, 0.2), 0.4, 1.2) #> [1] 0.040000 0.329877"},{"path":"https://openpharma.github.io/crmPack/reference/h_is_positive_definite.html","id":null,"dir":"Reference","previous_headings":"","what":"Testing Matrix for Positive Definiteness — h_is_positive_definite","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"helper function checks whether given numerical matrix x positive-definite square matrix given size, without missing values. function used test given matrix covariance matrix, since every symmetric positive semi-definite matrix covariance matrix.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_is_positive_definite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"","code":"h_is_positive_definite(x, size = 2, tol = 1e-08)"},{"path":"https://openpharma.github.io/crmPack/reference/h_is_positive_definite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"x (matrix) matrix checked. size (integer) size square matrix x checked . tol (number) given tolerance number used check whether eigenvalue positive . eigenvalue considered positive greater tol.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_is_positive_definite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"TRUE given matrix positive-definite, FALSE otherwise.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_is_positive_definite.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Testing Matrix for Positive Definiteness — h_is_positive_definite","text":"positive definiteness test implemented function based following characterization valid real matrices: symmetric matrix positive-definite eigenvalues positive. function eigenvalue considered positive greater tol.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_add_dummy.html","id":null,"dir":"Reference","previous_headings":"","what":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"helper function appends dummy value given slots GeneralData class object, total number observations (indicated object@nObs) equals 1. Otherwise, object changed.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_add_dummy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"","code":"h_jags_add_dummy(object, where, dummy = 0)"},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_add_dummy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"object (GeneralData) object dummy values added. (character) names slots object dummy number appended. dummy (number) dummy number appended selected slots object. Default 0.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_add_dummy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"GeneralData object slots updated dummy number.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_add_dummy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"main motivation behind function related JAGS. one observation, data passed correctly JAGS, .e. e.g. x y treated like scalars data file. Therefore necessary add dummy values vectors case change number observations (nObs), addition zeros affect results JAGS computations.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_add_dummy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Appending a Dummy Number for Selected Slots in Data — h_jags_add_dummy","text":"","code":"# Create some data of class 'Data' my_data <- Data(   x = 0.1,   y = 0,   doseGrid = c(0.1, 0.5) ) #> Used default patient IDs! #> Used best guess cohort indices!  my_data_2 <- Data(   x = c(0.1, 0.5),   y = c(0, 1),   doseGrid = c(0.1, 0.5) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Append dummy to `x` and `y`. h_jags_add_dummy(my_data, where = c(\"x\", \"y\")) #> An object of class \"Data\" #> Slot \"x\": #> [1] 0.1 0.0 #>  #> Slot \"y\": #> [1] 0 0 #>  #> Slot \"doseGrid\": #> [1] 0.1 0.5 #>  #> Slot \"nGrid\": #> [1] 2 #>  #> Slot \"xLevel\": #> [1] 1 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 #>  #> Slot \"cohort\": #> [1] 1 #>  #> Slot \"nObs\": #> [1] 1 #>   # Append dummy to `x` and `y`. No effect as `my_data_2@nObs != 1`. h_jags_add_dummy(my_data_2, where = c(\"x\", \"y\")) #> An object of class \"Data\" #> Slot \"x\": #> [1] 0.1 0.5 #>  #> Slot \"y\": #> [1] 0 1 #>  #> Slot \"doseGrid\": #> [1] 0.1 0.5 #>  #> Slot \"nGrid\": #> [1] 2 #>  #> Slot \"xLevel\": #> [1] 1 2 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 #>  #> Slot \"cohort\": #> [1] 1 2 #>  #> Slot \"nObs\": #> [1] 2 #>"},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_extract_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","title":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","text":"simple helper function extracts sample rjags::mcarray.object S3 class object. rjags::mcarray.object object used rjags::jags.samples() function represent MCMC output JAGS model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_extract_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","text":"","code":"h_jags_extract_samples(x)"},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_extract_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracting Samples from JAGS mcarray Object — h_jags_extract_samples","text":"x rjags::mcarray.object object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_get_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting Data for JAGS — h_jags_get_data","title":"Getting Data for JAGS — h_jags_get_data","text":"simple helper function prepares object data argument rjags::jags.model(), invoked mcmc() method.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_get_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting Data for JAGS — h_jags_get_data","text":"","code":"h_jags_get_data(model, data, from_prior)"},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_get_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting Data for JAGS — h_jags_get_data","text":"model (GeneralModel) input model. data (GeneralData) input data. from_prior (flag) sample prior ? case data appended output, .e. variables required model@priormodel model returned data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_get_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting Data for JAGS — h_jags_get_data","text":"","code":"# Create some data from the class `Data`. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  jags_data <- h_jags_get_data(my_model, my_data, from_prior = FALSE) jags_data #> $nObs #> [1] 8 #>  #> $y #> [1] 0 0 0 0 0 0 1 0 #>  #> $x #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 #>  #> $mean #> [1] -0.85  1.00 #>  #> $prec #>           [,1]      [,2] #> [1,] 1.3333333 0.6666667 #> [2,] 0.6666667 1.3333333 #>  #> $ref_dose #> [1] 56 #>"},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_get_model_inits.html","id":null,"dir":"Reference","previous_headings":"","what":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"simple helper function prepares object inits argument rjags::jags.model(), invoked mcmc() method. inits argument specifies initial values model parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_get_model_inits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"","code":"h_jags_get_model_inits(model, data)"},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_get_model_inits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"model (GeneralModel) input model. data (GeneralData) input data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_get_model_inits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"list starting values parameters required initialized MCMC JAGS sampler.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_get_model_inits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Setting Initial Values for JAGS Model Parameters — h_jags_get_model_inits","text":"","code":"# Create some data from the class `Data`. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  h_jags_get_model_inits(model = my_model, data = my_data) #> $theta #> [1] 0 1 #>"},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_join_models.html","id":null,"dir":"Reference","previous_headings":"","what":"Joining JAGS Models — h_jags_join_models","title":"Joining JAGS Models — h_jags_join_models","text":"helper function joins two JAGS models way body second model appended body first model (order). , first, body-extended model returned. arguments model1, model2 model functions () combined way.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_join_models.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Joining JAGS Models — h_jags_join_models","text":"","code":"h_jags_join_models(model1, model2)"},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_join_models.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Joining JAGS Models — h_jags_join_models","text":"model1 (function) first model join. model2 (function) second model join.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_join_models.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Joining JAGS Models — h_jags_join_models","text":"joined models.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_join_models.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Joining JAGS Models — h_jags_join_models","text":"model1 model2 functions must multi-expression body, .e. braced expression(s). Environments attributes function bodies preserved way joining.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_write_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Writing JAGS Model to a File — h_jags_write_model","title":"Writing JAGS Model to a File — h_jags_write_model","text":"function converts R function JAGS model text writes given file. \"model text\" conversion, format numbers absolute value less 0.001 greater 10000 changed. numbers converted scientific format specified number significant digits using formatC() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_write_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Writing JAGS Model to a File — h_jags_write_model","text":"","code":"h_jags_write_model(model, file = NULL, digits = 5)"},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_write_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Writing JAGS Model to a File — h_jags_write_model","text":"model (function) function containing JAGS model. file (string NULL) name file (including optional path) model saved. NULL, file created R_crmPack folder placed temporary directory indicated tempdir() function. digits (count) desired number significant digits numbers used JAGS input, see formatC().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_write_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Writing JAGS Model to a File — h_jags_write_model","text":"name file model saved.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_write_model.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Writing JAGS Model to a File — h_jags_write_model","text":"JAGS syntax allows truncation specification like dnorm(...) (...), illegal R. overcome incompatibility, use dummy operator \\%_\\% (...), .e. dnorm(...) \\%_\\% (...) model's code. dummy operator \\%_\\% removed just saving JAGS code file. Due technical issues related conversion numbers scientific format, required body model function contain TEMP_NUM_PREF_ _TEMP_NUM_SUF character constants body.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_jags_write_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Writing JAGS Model to a File — h_jags_write_model","text":"","code":"# Some model function my_model <- function() {   alpha0 <- mean(1:10)   alpha1 <- 600000 }  h_jags_write_model(my_model, digits = 5) #> [1] \"/tmp/Rtmp7tNNY7/R_crmPack/jags_model_fun2af665a2ee.txt\""},{"path":"https://openpharma.github.io/crmPack/reference/h_knit_format_func.html","id":null,"dir":"Reference","previous_headings":"","what":"Used to obtain expected format. — h_knit_format_func","title":"Used to obtain expected format. — h_knit_format_func","text":"Used obtain expected format.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_knit_format_func.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Used to obtain expected format. — h_knit_format_func","text":"","code":"h_knit_format_func(x)"},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_beta.html","id":null,"dir":"Reference","previous_headings":"","what":"Update certain components of DualEndpoint model with regard to parameters of the function that models dose-biomarker relationship defined in the DualEndpointBeta class. — h_model_dual_endpoint_beta","title":"Update certain components of DualEndpoint model with regard to parameters of the function that models dose-biomarker relationship defined in the DualEndpointBeta class. — h_model_dual_endpoint_beta","text":"simple helper function takes DualEndpoint object updates use_fixed, priormodel, modelspecs, init, sample slots regard given parameter dose-biomarker relationship \\(f(x)\\) defined DualEndpointBeta class. update solely depends whether given parameter's value param fixed-valued scalar two-elements numeric vector. later case, assumed param represents two parameters probability distribution used priormodel function generate values param_name parameter \\(f(x)\\). See help page DualEndpointBeta class details.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_beta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update certain components of DualEndpoint model with regard to parameters of the function that models dose-biomarker relationship defined in the DualEndpointBeta class. — h_model_dual_endpoint_beta","text":"","code":"h_model_dual_endpoint_beta(   param,   param_name,   param_suffix = c(\"_low\", \"_high\"),   priormodel = NULL,   de )"},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_beta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update certain components of DualEndpoint model with regard to parameters of the function that models dose-biomarker relationship defined in the DualEndpointBeta class. — h_model_dual_endpoint_beta","text":"param (numeric) value given param_name parameter dose-biomarker relationship function \\(f(x)\\). Either fixed-valued scalar vector two elements parameters probability distribution used priormodel function generate values param_name parameter \\(f(x)\\). param_name (string) name parameter \\(f(x)\\), whose value depends param. param_suffix (character) two suffixes appended elements param_name used updating modelspecs. value argument ignored param scalar. priormodel (function NULL) function representing JAGS prior specification appended existing de@priormodel specification param scalar. Otherwise, de@priormodel remains unchanged. de (DualEnpoint) dual endpoint model whose slots updated.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_beta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update certain components of DualEndpoint model with regard to parameters of the function that models dose-biomarker relationship defined in the DualEndpointBeta class. — h_model_dual_endpoint_beta","text":"DualEndpoint model updated use_fixed, priormodel, modelspecs, init, sample slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_rho.html","id":null,"dir":"Reference","previous_headings":"","what":"Update DualEndpoint class model components with regard to DLT and biomarker correlation. — h_model_dual_endpoint_rho","title":"Update DualEndpoint class model components with regard to DLT and biomarker correlation. — h_model_dual_endpoint_rho","text":"simple helper function takes DualEndpoint model existing components (priormodel, modelspecs, init, sample), updates regard DLT biomarker correlation rho.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_rho.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update DualEndpoint class model components with regard to DLT and biomarker correlation. — h_model_dual_endpoint_rho","text":"","code":"h_model_dual_endpoint_rho(use_fixed, rho, comp)"},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_rho.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update DualEndpoint class model components with regard to DLT and biomarker correlation. — h_model_dual_endpoint_rho","text":"use_fixed (flag) indicates whether fixed value DLT biomarker correlation rho used . rho supposed fixed value, prior distribution scaled Beta family used. See details , rho argument. rho (numeric) DLT biomarker correlation. must either fixed value (-1 1), named vector two elements, named b Beta prior transformation kappa = (rho + 1) / 2, (0, 1). example, = 1, b = 1 leads uniform prior rho. comp (list) named list model components updated. names : priormodel, modelspecs, init, sample. definitions components, see GeneralModel class. modelspecs init components comp list specified body corresponding GeneralModel@modelspecs GeneralModel@init functions. bodies simply lists .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_rho.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update DualEndpoint class model components with regard to DLT and biomarker correlation. — h_model_dual_endpoint_rho","text":"list updated model components.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_sigma2W.html","id":null,"dir":"Reference","previous_headings":"","what":"Update DualEndpoint class model components with regard to biomarker regression variance. — h_model_dual_endpoint_sigma2W","title":"Update DualEndpoint class model components with regard to biomarker regression variance. — h_model_dual_endpoint_sigma2W","text":"simple helper function takes DualEndpoint model existing components (priormodel, modelspecs, init, sample), updates regard biomarker regression variance sigma2W.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_sigma2W.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update DualEndpoint class model components with regard to biomarker regression variance. — h_model_dual_endpoint_sigma2W","text":"","code":"h_model_dual_endpoint_sigma2W(use_fixed, sigma2W, comp)"},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_sigma2W.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update DualEndpoint class model components with regard to biomarker regression variance. — h_model_dual_endpoint_sigma2W","text":"use_fixed (flag) indicates whether fixed value biomarker regression variance sigma2W used . sigma2W supposed fixed value, prior distribution Inverse-Gamma distribution used. See details , sigma2W argument. sigma2W (numeric) biomarker variance. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. comp (list) named list model components updated. names : priormodel, modelspecs, init, sample. definitions components, see GeneralModel class. modelspecs init components comp list specified body corresponding GeneralModel@modelspecs GeneralModel@init functions. bodies simply lists .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_sigma2W.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update DualEndpoint class model components with regard to biomarker regression variance. — h_model_dual_endpoint_sigma2W","text":"list updated model components.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_sigma2betaW.html","id":null,"dir":"Reference","previous_headings":"","what":"Update certain components of DualEndpoint model with regard to prior variance factor of the random walk. — h_model_dual_endpoint_sigma2betaW","title":"Update certain components of DualEndpoint model with regard to prior variance factor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"simple helper function takes DualEndpoint object updates priormodel, modelspecs, init, sample slots according random walk variance.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_sigma2betaW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update certain components of DualEndpoint model with regard to prior variance factor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"","code":"h_model_dual_endpoint_sigma2betaW(use_fixed, sigma2betaW, de)"},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_sigma2betaW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update certain components of DualEndpoint model with regard to prior variance factor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"use_fixed (flag) indicates whether fixed value sigma2betaW used . sigma2betaW supposed fixed value, prior distribution Inverse-Gamma distribution used. See details , sigma2betaW argument. sigma2betaW (numeric) prior variance factor random walk prior biomarker model. Either fixed value Inverse-Gamma distribution parameters, .e. vector two elements named b. de (DualEnpoint) dual endpoint model whose slots updated.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_model_dual_endpoint_sigma2betaW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update certain components of DualEndpoint model with regard to prior variance factor of the random walk. — h_model_dual_endpoint_sigma2betaW","text":"DualEndpoint model updated priormodel, modelspecs, init, sample slots.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"Helper function gets eligible doses dose grid. eligible doses doses exceed given doselimit. placebo design, safety allows (.e. least one non-placebo dose exceed dose limit), placebo dose excluded eligible doses.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"","code":"h_next_best_eligible_doses(dose_grid, doselimit, placebo, levels = FALSE)"},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"dose_grid (numeric) possible doses. doselimit (number) maximum allowed next dose. placebo (flag) TRUE first dose level dose_grid considered placebo. levels (flag) TRUE levels eligible doses returned, otherwise, doses (default).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"numeric vector eligible doses eligible dose levels levels flag TRUE.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_eligible_doses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Eligible Doses from the Dose Grid. — h_next_best_eligible_doses","text":"","code":"dose_grid <- c(0.001, seq(25, 200, 25)) h_next_best_eligible_doses(dose_grid, 79, TRUE) #> [1] 25 50 75 h_next_best_eligible_doses(dose_grid, 24, TRUE) #> [1] 0.001"},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"Helper function nextBest-NextBestMaxGain() method. computes 95% credibility intervals given target dose max gain dose. also returns ratio upper lower bounds interval.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"","code":"h_next_best_mg_ci(dose_target, dose_mg, prob_target, placebo, model, model_eff)"},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"dose_target (number) target dose estimate. dose_mg (number) dose corresponding maximum gain. prob_target (proportion) target DLT probability. placebo (flag) TRUE first dose level dose grid used considered placebo. needed adjust max gain dose using efficacy constant value. placebo used, model_eff@const added dose_mg. model (ModelTox) DLT model. model_eff (Effloglog) efficacy model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_ci.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Credibility Intervals for Max Gain and Target Doses at nextBest-NextBestMaxGain Method. — h_next_best_mg_ci","text":"Yeung, W.Y., Whitehead, J., Reigner, B., Beyer, U., Diack, Ch., Jaki, T. (2015), Bayesian adaptive dose-escalation procedures binary continuous responses utilizing gain function, Pharmaceutical Statistics, doi:10.1002/pst.1706","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_doses_at_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","title":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","text":"Helper function given target doses finds dose grid closest target. four different targets context nextBest-NextBestMaxGain() method: \\(min(`dose_mg`, `dose_target_drt`)\\), dose_mg, dose_target_drt dose_target_eot.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_doses_at_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","text":"","code":"h_next_best_mg_doses_at_grid(   dose_target_drt,   dose_target_eot,   dose_mg,   dose_grid,   doselimit,   placebo )"},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_doses_at_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Closest Grid Doses for a Given Target Doses for nextBest-NextBestMaxGain Method. — h_next_best_mg_doses_at_grid","text":"dose_target_drt (number) target dose estimate trial. dose_target_eot (number) target dose estimate end trial. dose_mg (number) dose corresponding maximum gain. dose_grid (numeric) possible doses. doselimit (number) maximum allowed next dose. placebo (flag) TRUE first dose level dose_grid considered placebo.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","title":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","text":"Helper function creates plot nextBest-NextBestMaxGain() method.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","text":"","code":"h_next_best_mg_plot(   prob_target_drt,   dose_target_drt,   prob_target_eot,   dose_target_eot,   dose_mg,   max_gain,   next_dose,   doselimit,   data,   model,   model_eff )"},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mg_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestMaxGain Method. — h_next_best_mg_plot","text":"prob_target_drt (proportion) target DLT probability trial. dose_target_drt (number) target dose estimate trial. prob_target_eot (proportion) target DLT probability end trial. dose_target_eot (number) target dose estimate end trial. dose_mg (number) dose corresponding maximum gain. max_gain (number) maximum gain estimate. next_dose (number) next best dose. doselimit (number) maximum allowed next dose. data (DataDual) data object dose grid fetched. model (ModelTox) DLT model. model_eff (Effloglog) efficacy model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mgsamples_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","title":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","text":"Helper function creates plot nextBest-NextBestMaxGainSamples() method.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mgsamples_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","text":"","code":"h_next_best_mgsamples_plot(   prob_target_drt,   dose_target_drt,   prob_target_eot,   dose_target_eot,   dose_mg,   dose_mg_samples,   next_dose,   doselimit,   dose_grid_range )"},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_mgsamples_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestMaxGainSamples Method. — h_next_best_mgsamples_plot","text":"prob_target_drt (proportion) target DLT probability trial. dose_target_drt (number) target dose estimate trial. prob_target_eot (proportion) target DLT probability end trial. dose_target_eot (number) target dose estimate end trial. dose_mg (number) dose corresponding maximum gain. dose_mg_samples (numeric) every sample, dose (dose grid) gives maximum gain value. next_dose (number) next best dose. doselimit (number) maximum allowed next dose. dose_grid_range (numeric) dose grid range.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_ncrm_loss_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","title":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","text":"Helper function creates plot nextBest-NextBestNCRMLoss() method.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_ncrm_loss_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","text":"","code":"h_next_best_ncrm_loss_plot(   prob_mat,   posterior_loss,   max_overdose_prob,   dose_grid,   max_eligible_dose_level,   doselimit,   next_dose,   is_unacceptable_specified )"},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_ncrm_loss_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestNCRMLoss Method. — h_next_best_ncrm_loss_plot","text":"prob_mat (numeric) matrix probabilities grid doses given interval. is_unacceptable_specified TRUE, must 4 intervals (columns) prob_mat: underdosing, target, excessive, unacceptable. Otherwise, must 3 intervals (columns): underdosing, target, overdose. Number rows must equal number doses grid. posterior_loss (numeric) posterior losses. max_overdose_prob (number) maximum overdose posterior probability allowed. dose_grid (numeric) dose grid. max_eligible_dose_level (number) maximum eligible dose level dose_grid. doselimit (number) maximum allowed next dose. next_dose (number) next best dose. is_unacceptable_specified (flag) unacceptable interval specified?","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_td_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","title":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","text":"Helper function creates plot nextBest-NextBestTD() method.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_td_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","text":"","code":"h_next_best_td_plot(   prob_target_drt,   dose_target_drt,   prob_target_eot,   dose_target_eot,   data,   prob_dlt,   doselimit,   next_dose )"},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_td_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestTD Method. — h_next_best_td_plot","text":"prob_target_drt (proportion) target DLT probability trial. dose_target_drt (number) target dose estimate trial. prob_target_eot (proportion) target DLT probability end trial. dose_target_eot (number) target dose estimate end trial. data (Data) data object dose grid fetched. prob_dlt (numeric) DLT probabilities doses grid. doselimit (number) maximum allowed next dose. next_dose (number) next best dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_tdsamples_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","title":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","text":"Helper function creates plot nextBest-NextBestTDsamples() method.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_tdsamples_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","text":"","code":"h_next_best_tdsamples_plot(   dose_target_drt_samples,   dose_target_eot_samples,   dose_target_drt,   dose_target_eot,   dose_grid_range,   nextBest,   doselimit,   next_dose )"},{"path":"https://openpharma.github.io/crmPack/reference/h_next_best_tdsamples_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Building the Plot for nextBest-NextBestTDsamples Method. — h_next_best_tdsamples_plot","text":"dose_target_drt_samples (numeric) vector -trial samples. dose_target_eot_samples (numeric) vector end--trial samples. dose_target_drt (number) target -trial estimate. dose_target_eot (number) target end--trial estimate. dose_grid_range (numeric) range dose grid. nextBest (NextBestTDsamples) rule next best dose. doselimit (number) maximum allowed next dose. next_dose (number) next best dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_null_if_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting NULL for NA — h_null_if_na","title":"Getting NULL for NA — h_null_if_na","text":"simple helper function replaces NA object NULL object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_null_if_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting NULL for NA — h_null_if_na","text":"","code":"h_null_if_na(x)"},{"path":"https://openpharma.github.io/crmPack/reference/h_null_if_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting NULL for NA — h_null_if_na","text":"x () atomic object length 1. definition \"atomic\", see .atomic().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_null_if_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting NULL for NA — h_null_if_na","text":"NULL x NA, otherwise, x.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_null_if_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting NULL for NA — h_null_if_na","text":"","code":"h_null_if_na(NA) #> NULL"},{"path":"https://openpharma.github.io/crmPack/reference/h_obtain_dose_grid_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function Containing Common Functionality — h_obtain_dose_grid_range","title":"Helper Function Containing Common Functionality — h_obtain_dose_grid_range","text":"Used dose_grid_range-Data dose_grid_range-DataOrdinal","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_obtain_dose_grid_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function Containing Common Functionality — h_obtain_dose_grid_range","text":"","code":"h_obtain_dose_grid_range(object, ignore_placebo)"},{"path":"https://openpharma.github.io/crmPack/reference/h_obtain_dose_grid_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function Containing Common Functionality — h_obtain_dose_grid_range","text":"object (Data DataOrdinal) object dose grid range required ignore_placebo (flag) placebo dose () counted?","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_plot_data_cohort_lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"helper function prepares ggplot geom reference lines separating different cohorts plot Data class object. Lines either vertical horizontal green color longdash type.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_plot_data_cohort_lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"","code":"h_plot_data_cohort_lines(cohort, placebo, vertical = TRUE)"},{"path":"https://openpharma.github.io/crmPack/reference/h_plot_data_cohort_lines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"cohort (integer) cohort indices. placebo (flag) placebo included doses? , function returns NULL object case doses given cohort equal need separate . vertical (flag) line vertical? Otherwise horizontal.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_plot_data_cohort_lines.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Preparing Cohort Lines for Data Plot — h_plot_data_cohort_lines","text":"geom object returned placebo equal TRUE one unique values cohort. Otherwise, function returns NULL object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_plot_data_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Preparing Data for Plotting — h_plot_data_df","title":"Preparing Data for Plotting — h_plot_data_df","text":"helper function prepares data.frame object based Data class object. resulting data frame used plot function Data class objects.  method transforms GeneralData  objects tibble suitable plotting ggplot2 methods","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_plot_data_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preparing Data for Plotting — h_plot_data_df","text":"","code":"h_plot_data_df(data, ...)  h_plot_data_df(data, ...)  # S4 method for class 'Data' h_plot_data_df(data, blind = FALSE, legend = TRUE, ...)  # S4 method for class 'DataOrdinal' h_plot_data_df(data, blind = FALSE, legend = TRUE, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/h_plot_data_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preparing Data for Plotting — h_plot_data_df","text":"data (Data) object data extracted converted data frame. ... arguments passed data.frame constructor. can e.g. extra column_name = value pair based slot x (case might subclass Data) appear Data. blind (flag) data blinded? TRUE, cohort, DLTs assigned first subjects cohort. addition, placebo () set active dose level cohort. legend (flag) Display legend toxicity categories","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_plot_data_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Preparing Data for Plotting — h_plot_data_df","text":"data.frame object values plot. data.frame containing columns patient, cohort, dose toxicity grade data.frame object columns patient, ID, cohort, dose toxicity.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_plot_data_df.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Preparing Data for Plotting — h_plot_data_df","text":"h_plot_data_df(Data): method Data. h_plot_data_df(DataOrdinal): Class specific method DataOrdinal","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_prepare_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Check That Labels Are Valid and Useful — h_prepare_labels","title":"Check That Labels Are Valid and Useful — h_prepare_labels","text":"vector labels valid useful length 2, type character values distinct.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_prepare_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check That Labels Are Valid and Useful — h_prepare_labels","text":"","code":"h_prepare_labels(x)"},{"path":"https://openpharma.github.io/crmPack/reference/h_prepare_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check That Labels Are Valid and Useful — h_prepare_labels","text":"x (character) vector checked","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_prepare_labels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check That Labels Are Valid and Useful — h_prepare_labels","text":"character vector length 2 whose values distinct","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_prepare_labels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check That Labels Are Valid and Useful — h_prepare_labels","text":"x scalar, second element added, whose value value scalar \"s\" appended.  x \"toxicity\", plural handled appropriately.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_prepare_units.html","id":null,"dir":"Reference","previous_headings":"","what":"Append Units to a Numeric Dose — h_prepare_units","title":"Append Units to a Numeric Dose — h_prepare_units","text":"Append Units Numeric Dose","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_prepare_units.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Append Units to a Numeric Dose — h_prepare_units","text":"","code":"h_prepare_units(units = NA)"},{"path":"https://openpharma.github.io/crmPack/reference/h_prepare_units.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Append Units to a Numeric Dose — h_prepare_units","text":"units (character) units displayed","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_prepare_units.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Append Units to a Numeric Dose — h_prepare_units","text":"units NA, NA.  Otherwise, units, ensuring exactly one space precedes first non-whitespace character","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_rapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursively Apply a Function to a List — h_rapply","title":"Recursively Apply a Function to a List — h_rapply","text":"helper function recursively iterates \"list-like\" object checks whether element given class. , replaces element result execution given function. Otherwise, element length greater 1 (.e. scalar), replaces element result h_rapply(), recursively called element. remaining case, , element given class scalar, element remains unchanged.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_rapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursively Apply a Function to a List — h_rapply","text":"","code":"h_rapply(x, fun, classes, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/h_rapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursively Apply a Function to a List — h_rapply","text":"x () \"list-like\" object subsetting operator [[ defined. fun (function) function one \"principal\" argument, passing arguments via .... classes (character) class names. ... arguments passed function fun.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_rapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recursively Apply a Function to a List — h_rapply","text":"\"list-like\" object similar structure x.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_rapply.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Recursively Apply a Function to a List — h_rapply","text":"helper function conceptually similar rapply() function. However, differs rapply() two major ways. First, h_rapply() limited objects type list expression . can \"list-like\" object type subsetting operator [[ defined. can , example, object type language, often obtained body() function. second difference flexibility rapply() result structured available h_rapply() user. , h_rapply() element x, class included classes, replaced result applying fun element. behavior corresponds rapply() invoked fixed = replace. function primarily designed helper h_jags_write_model() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_rapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recursively Apply a Function to a List — h_rapply","text":"","code":"# Some model function. my_model <- function() {   alpha0 <- mean(1:10)   alpha1 <- 600000 }  # Replace format of numbers using `formatC` function. h_rapply(   x = body(my_model),   fun = formatC,   classes = c(\"integer\", \"numeric\"),   digits = 3,   format = \"E\" ) #> { #>     alpha0 <- mean(\"1.000E+00\":\"1.000E+01\") #>     alpha1 <- \"6.000E+05\" #> }"},{"path":"https://openpharma.github.io/crmPack/reference/h_simulations_output_format.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to create return list for Simulations output — h_simulations_output_format","title":"Helper Function to create return list for Simulations output — h_simulations_output_format","text":"Helper Function create return list Simulations output","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_simulations_output_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to create return list for Simulations output — h_simulations_output_format","text":"","code":"h_simulations_output_format(resultList)"},{"path":"https://openpharma.github.io/crmPack/reference/h_simulations_output_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to create return list for Simulations output — h_simulations_output_format","text":"resultList (list) raw iteration output.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_simulations_output_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to create return list for Simulations output — h_simulations_output_format","text":"aggregated output simulation object list.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_slots.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Slots from a S4 Object — h_slots","title":"Getting the Slots from a S4 Object — h_slots","text":"helper function extracts requested slots S4 class object. simple wrapper methods::slot() function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_slots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Slots from a S4 Object — h_slots","text":"","code":"h_slots(object, names, simplify = FALSE)"},{"path":"https://openpharma.github.io/crmPack/reference/h_slots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Slots from a S4 Object — h_slots","text":"object (S4) object formally defined S4 class. names (character) vector names slots fetched. function assumes every element names, exists slot name object. simplify (flag) output simplified? effect single slot extracted, .e. names just single string.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_slots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Slots from a S4 Object — h_slots","text":"list slots extracted object according names, single slot simplification required possible.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_summarize_add_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to calculate average across iterations for each additional reporting parameter extracts parameter names as specified by user and averaged the values for each specified parameter to show() and output with cat to console — h_summarize_add_stats","title":"Helper function to calculate average across iterations for each additional reporting parameter extracts parameter names as specified by user and averaged the values for each specified parameter to show() and output with cat to console — h_summarize_add_stats","text":"Helper function calculate average across iterations additional reporting parameter extracts parameter names specified user averaged values specified parameter show() output cat console","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_summarize_add_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to calculate average across iterations for each additional reporting parameter extracts parameter names as specified by user and averaged the values for each specified parameter to show() and output with cat to console — h_summarize_add_stats","text":"","code":"h_summarize_add_stats(stats_list)"},{"path":"https://openpharma.github.io/crmPack/reference/h_summarize_add_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to calculate average across iterations for each additional reporting parameter extracts parameter names as specified by user and averaged the values for each specified parameter to show() and output with cat to console — h_summarize_add_stats","text":"stats_list object simulation nested parameter values (sublist parameter)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_summarize_add_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to calculate average across iterations for each additional reporting parameter extracts parameter names as specified by user and averaged the values for each specified parameter to show() and output with cat to console — h_summarize_add_stats","text":"list parameter names averaged values console output","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_test_named_numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that an argument is a named vector of type numeric — h_test_named_numeric","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"simple helper function tests whether object named numerical vector.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_test_named_numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"","code":"h_test_named_numeric(   x,   subset.of = NULL,   must.include = NULL,   permutation.of = NULL,   identical.to = NULL,   disjunct.from = NULL,   lower = 0 + .Machine$double.xmin,   finite = TRUE,   any.missing = FALSE,   len = 2,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/h_test_named_numeric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"x () object check. subset.[character] Names provided x must subset set subset.. must.include [character] Names provided x must superset set must.include. permutation.[character] Names provided x must permutation set permutation.. Duplicated names permutation.stripped duplicated names x thus lead failed check. Use argument instead identical.order names relevant. identical.[character] Names provided x must identical vector identical.. Use argument instead permutation.order names relevant. disjunct.[character] Names provided x must may present vector disjunct.. lower [numeric(1)] Lower value elements x must greater equal . finite [logical(1)] Check finite values? Default FALSE. .missing [logical(1)] vectors missing values allowed? Default TRUE. len [integer(1)] Exact expected length x. ... parameters passed checkmate::test_numeric().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_test_named_numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"TRUE x named vector type numeric, otherwise FALSE.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_test_named_numeric.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"function based checkmate::test_numeric() checkmate::test_names() functions.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_test_named_numeric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that an argument is a named vector of type numeric — h_test_named_numeric","text":"","code":"h_test_named_numeric(1:2, permutation.of = c(\"a\", \"b\")) #> [1] FALSE h_test_named_numeric(c(a = 1, b = 2), permutation.of = c(\"a\", \"b\")) #> [1] TRUE h_test_named_numeric(c(a = 1, b = 2), permutation.of = c(\"b\", \"a\")) #> [1] TRUE"},{"path":"https://openpharma.github.io/crmPack/reference/h_this_truth.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to call truth calculation — h_this_truth","title":"Helper Function to call truth calculation — h_this_truth","text":"Helper Function call truth calculation","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_this_truth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to call truth calculation — h_this_truth","text":"","code":"h_this_truth(dose, this_args, truth)"},{"path":"https://openpharma.github.io/crmPack/reference/h_this_truth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to call truth calculation — h_this_truth","text":"dose (number) current dose. this_args (data.frame) list arguments truth. truth (function) defines true probability DLT dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_this_truth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to call truth calculation — h_this_truth","text":"updated this_truth.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_unpack_stopit.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to recursively unpack stopping rules and return lists with logical value and label given — h_unpack_stopit","title":"Helper function to recursively unpack stopping rules and return lists with logical value and label given — h_unpack_stopit","text":"Helper function recursively unpack stopping rules return lists logical value label given","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_unpack_stopit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to recursively unpack stopping rules and return lists with logical value and label given — h_unpack_stopit","text":"","code":"h_unpack_stopit(stopit_tree)"},{"path":"https://openpharma.github.io/crmPack/reference/h_unpack_stopit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to recursively unpack stopping rules and return lists with logical value and label given — h_unpack_stopit","text":"stopit_tree object simulate method","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_unpack_stopit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to recursively unpack stopping rules and return lists with logical value and label given — h_unpack_stopit","text":"named list","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_validate_combine_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Combining S4 Class Validation Results — h_validate_combine_results","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"simple helper function combines two outputs calls result() function placed slot Validate() reference class.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_validate_combine_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"","code":"h_validate_combine_results(v1, v2)"},{"path":"https://openpharma.github.io/crmPack/reference/h_validate_combine_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"v1 (logical character) output result() function Validate() reference class, combined v2. v2 (logical character) output result() function Validate() reference class, combined v1.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_validate_combine_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combining S4 Class Validation Results — h_validate_combine_results","text":"","code":"h_validate_combine_results(TRUE, \"some_message\") #> [1] \"some_message\""},{"path":"https://openpharma.github.io/crmPack/reference/h_validate_common_data_slots.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","title":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","text":"Helper Function performing validation Common Data DataOrdinal","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_validate_common_data_slots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","text":"","code":"h_validate_common_data_slots(object)"},{"path":"https://openpharma.github.io/crmPack/reference/h_validate_common_data_slots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","text":"object (Data DataOrdinal) object validated","code":""},{"path":"https://openpharma.github.io/crmPack/reference/h_validate_common_data_slots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function performing validation Common to Data and DataOrdinal — h_validate_common_data_slots","text":"Validate object containing result validation","code":""},{"path":"https://openpharma.github.io/crmPack/reference/is.wholenumber.html","id":null,"dir":"Reference","previous_headings":"","what":"checks for whole numbers (integers) — is.wholenumber","title":"checks for whole numbers (integers) — is.wholenumber","text":"checks whole numbers (integers)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/is.wholenumber.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"checks for whole numbers (integers) — is.wholenumber","text":"","code":"is.wholenumber(x, tol = .Machine$double.eps^0.5)"},{"path":"https://openpharma.github.io/crmPack/reference/is.wholenumber.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"checks for whole numbers (integers) — is.wholenumber","text":"x numeric vector tol tolerance","code":""},{"path":"https://openpharma.github.io/crmPack/reference/is.wholenumber.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"checks for whole numbers (integers) — is.wholenumber","text":"TRUE FALSE element x","code":""},{"path":"https://openpharma.github.io/crmPack/reference/knit_print.html","id":null,"dir":"Reference","previous_headings":"","what":"Render a CohortSizeConst Object — knit_print","title":"Render a CohortSizeConst Object — knit_print","text":"provide additional utility functions allow human-friendly rendition crmPack objects Markdown Quarto files         provide additional utility functions allow human-friendly rendition crmPack objects Markdown Quarto files.  file contains methods design classes, just direct descendants Design.                                               provide additional utility functions allow human-friendly rendition crmPack objects Markdown Quarto files","code":""},{"path":"https://openpharma.github.io/crmPack/reference/knit_print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render a CohortSizeConst Object — knit_print","text":"","code":"# S3 method for class 'CohortSizeConst' knit_print(x, ..., asis = TRUE, label = c(\"participant\", \"participants\"))  # S3 method for class 'CohortSizeRange' knit_print(x, ..., asis = TRUE)  # S3 method for class 'CohortSizeDLT' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'CohortSizeParts' knit_print(x, ..., asis = TRUE, label = c(\"participant\", \"participants\"))  # S3 method for class 'CohortSizeMax' knit_print(x, ..., asis = TRUE)  # S3 method for class 'CohortSizeMin' knit_print(x, ..., asis = TRUE)  # S3 method for class 'CohortSizeOrdinal' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'StartingDose' knit_print(x, ..., asis = TRUE)  # S3 method for class 'RuleDesign' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'Design' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'DualDesign' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'DADesign' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'TDDesign' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'DualResponsesDesign' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'DesignOrdinal' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'DesignGrouped' knit_print(   x,   ...,   level = 2L,   title = \"Design\",   sections = c(model = \"Dose toxicity model\", mono = \"Monotherapy rules\", combo =     \"Combination therapy rules\", other = \"Other details\"),   asis = TRUE )  # S3 method for class 'TDsamplesDesign' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'DualResponsesDesign' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'DualResponsesSamplesDesign' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'RuleDesignOrdinal' knit_print(x, ..., level = 2L, title = \"Design\", sections = NA, asis = TRUE)  # S3 method for class 'GeneralData' knit_print(   x,   ...,   asis = TRUE,   label = c(\"participant\", \"participants\"),   full_grid = FALSE,   summarise = c(\"none\", \"dose\", \"cohort\"),   summarize = summarise,   units = NA,   format_func = h_knit_format_func )  # S3 method for class 'DataParts' knit_print(   x,   ...,   asis = TRUE,   label = c(\"participant\", \"participants\"),   full_grid = FALSE,   summarise = c(\"none\", \"dose\", \"cohort\"),   summarize = summarise,   units = NA,   format_func = h_knit_format_func )  # S3 method for class 'DualEndpoint' knit_print(   x,   ...,   asis = TRUE,   use_values = TRUE,   fmt = \"%5.2f\",   units = NA,   tox_label = \"toxicity\",   biomarker_label = \"PD biomarker\" )  # S3 method for class 'ModelParamsNormal' knit_print(   x,   use_values = TRUE,   fmt = \"%5.2f\",   params = c(\"alpha\", \"beta\"),   preamble = \"The prior for &theta; is given by\\\\n\",   asis = TRUE,   theta = \"\\\\theta\",   ... )  # S3 method for class 'GeneralModel' knit_print(   x,   ...,   params = c(\"alpha\", \"beta\"),   asis = TRUE,   use_values = TRUE,   fmt = \"%5.2f\",   units = NA )  # S3 method for class 'LogisticKadane' knit_print(   x,   ...,   asis = TRUE,   use_values = TRUE,   fmt = \"%5.2f\",   units = NA,   tox_label = \"toxicity\" )  # S3 method for class 'LogisticKadaneBetaGamma' knit_print(   x,   ...,   asis = TRUE,   use_values = TRUE,   fmt = \"%5.2f\",   tox_label = \"toxicity\",   units = NA )  # S3 method for class 'LogisticLogNormal' knit_print(   x,   ...,   use_values = TRUE,   fmt = \"%5.2f\",   params = c(`\\\\alpha` = \"alpha\", `log(\\\\beta)` = \"beta\"),   preamble = \"The prior for &theta; is given by\\\\n\",   asis = TRUE )  # S3 method for class 'LogisticLogNormalMixture' knit_print(x, ..., asis = TRUE, use_values = TRUE, fmt = \"%5.2f\", units = NA)  # S3 method for class 'LogisticLogNormalSub' knit_print(   x,   ...,   use_values = TRUE,   fmt = \"%5.2f\",   params = c(`\\\\alpha` = \"alpha\", `log(\\\\beta)` = \"beta\"),   preamble = \"The prior for &theta; is given by\\\\n\",   asis = TRUE )  # S3 method for class 'LogisticNormalMixture' knit_print(x, ..., asis = TRUE, use_values = TRUE, fmt = \"%5.2f\", units = NA)  # S3 method for class 'LogisticNormalFixedMixture' knit_print(x, ..., asis = TRUE, use_values = TRUE, fmt = \"%5.2f\", units = NA)  # S3 method for class 'OneParLogNormalPrior' knit_print(   x,   ...,   tox_label = \"toxicity\",   asis = TRUE,   use_values = TRUE,   fmt = \"%5.2f\" )  # S3 method for class 'OneParExpPrior' knit_print(x, ..., asis = TRUE)  # S3 method for class 'LogisticLogNormalGrouped' knit_print(   x,   ...,   use_values = TRUE,   fmt = \"%5.2f\",   params = c(`\\\\alpha` = \"alpha\", `\\\\beta` = \"beta\", `log(\\\\delta_0)` = \"delta_0\",     `log(\\\\delta_1)` = \"delta_1\"),   preamble = \"The prior for &theta; is given by\\\\n\",   asis = TRUE )  # S3 method for class 'LogisticLogNormalOrdinal' knit_print(   x,   ...,   use_values = TRUE,   fmt = \"%5.2f\",   params = NA,   preamble = \"The prior for &theta; is given by\\\\n\",   asis = TRUE )  # S3 method for class 'LogisticIndepBeta' knit_print(   x,   ...,   use_values = TRUE,   fmt = \"%5.2f\",   params = NA,   tox_label = \"DLAE\",   preamble = \"The prior for &theta; is given by\\\\n\",   asis = TRUE )  # S3 method for class 'Effloglog' knit_print(   x,   ...,   use_values = TRUE,   fmt = \"%5.2f\",   params = NA,   tox_label = \"DLAE\",   eff_label = \"efficacy\",   label = \"participant\",   preamble = \"The prior for &theta; is given by\\\\n\",   asis = TRUE )  # S3 method for class 'IncrementsRelative' knit_print(x, ..., asis = TRUE)  # S3 method for class 'IncrementsRelativeDLT' knit_print(x, ..., asis = TRUE)  # S3 method for class 'IncrementsDoseLevels' knit_print(x, ..., asis = TRUE)  # S3 method for class 'IncrementsHSRBeta' knit_print(x, ..., asis = TRUE)  # S3 method for class 'IncrementsMin' knit_print(x, ..., asis = TRUE)  # S3 method for class 'IncrementsOrdinal' knit_print(x, ..., asis = TRUE)  # S3 method for class 'IncrementsRelativeParts' knit_print(x, ..., asis = TRUE, tox_label = c(\"toxicity\", \"toxicities\"))  # S3 method for class 'IncrementsRelativeDLTCurrent' knit_print(x, ..., asis = TRUE, tox_label = c(\"DLT\", \"DLTs\"))  # S3 method for class 'NextBestMTD' knit_print(   x,   ...,   target_label = \"the 25th centile\",   tox_label = \"toxicity\",   asis = TRUE )  # S3 method for class 'NextBestNCRM' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'NextBestThreePlusThree' knit_print(   x,   ...,   tox_label = c(\"toxicity\", \"toxicities\"),   label = \"participant\",   asis = TRUE )  # S3 method for class 'NextBestDualEndpoint' knit_print(   x,   ...,   tox_label = \"toxicity\",   biomarker_label = \"the biomarker\",   biomarker_units = ifelse(x@target_relative, \"%\", \"\"),   asis = TRUE )  # S3 method for class 'NextBestMinDist' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'NextBestInfTheory' knit_print(   x,   ...,   tox_label = \"toxicity\",   citation_text = \"Mozgunov & Jaki (2019)\",   citation_link = \"https://doi.org/10.1002/sim.8450\",   asis = TRUE )  # S3 method for class 'NextBestTD' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'NextBestMaxGain' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'NextBestProbMTDLTE' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'NextBestProbMTDMinDist' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'NextBestNCRMLoss' knit_print(   x,   ...,   tox_label = \"toxicity\",   asis = TRUE,   format_func = h_knit_format_func )  # S3 method for class 'NextBestTDsamples' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'NextBestMaxGainSamples' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'NextBestOrdinal' knit_print(x, ..., tox_label = \"toxicity\", asis = TRUE)  # S3 method for class 'SafetyWindow' knit_print(x, ..., asis = TRUE, time_unit = \"day\", label = \"participant\")  # S3 method for class 'SafetyWindowConst' knit_print(   x,   ...,   asis = TRUE,   label = \"participant\",   ordinals = c(\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\",     \"eighth\", \"ninth\", \"tenth\"),   time_unit = \"day\" )  # S3 method for class 'SafetyWindowSize' knit_print(   x,   ...,   asis = TRUE,   ordinals = c(\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\",     \"eighth\", \"ninth\", \"tenth\"),   label = \"participant\",   time_unit = \"day\",   level = 2L )  # S3 method for class 'StoppingOrdinal' knit_print(x, ..., asis = TRUE)  # S3 method for class 'StoppingMaxGainCIRatio' knit_print(x, ..., asis = TRUE)  # S3 method for class 'StoppingList' knit_print(x, ..., preamble, indent = 0L, asis = TRUE)  # S3 method for class 'StoppingAny' knit_print(x, ..., preamble, asis = TRUE)  # S3 method for class 'StoppingAll' knit_print(x, ..., preamble, asis = TRUE)  # S3 method for class 'StoppingTDCIRatio' knit_print(   x,   ...,   dose_label = \"the next best dose\",   tox_label = \"toxicity\",   fmt_string =     paste0(\"%sIf, at %s, the ratio of the upper to the lower limit of the posterior \",     \"95%% credible interval for %s (targetting %2.0f%%) is less than or equal to \"),   asis = TRUE )  # S3 method for class 'StoppingTargetBiomarker' knit_print(   x,   ...,   dose_label = \"the next best dose\",   biomarker_label = \"the target biomarker\",   fmt_string =     paste0(\"%sIf, at %s, the posterior probability that %s is in the range \",     \"(%.2f, %.2f)%s is %.0f%% or more.\\n\\n\"),   asis = TRUE )  # S3 method for class 'StoppingLowestDoseHSRBeta' knit_print(   x,   ...,   tox_label = \"toxicity\",   fmt_string =     paste0(\"%sIf, using a Hard Stopping Rule with a prior of Beta(%.0f, %.0f), the \",     \"lowest dose in the dose grid has a posterior probability of %s of \",     \"%.0f%% or more.\\n\\n\"),   asis = TRUE )  # S3 method for class 'StoppingMTDCV' knit_print(   x,   ...,   fmt_string =     paste0(\"%sIf the posterior estimate of the robust coefficient of variation of \",     \"the MTD (targetting %2.0f%%), is than or equal to %.0f%%.\\n\\n\"),   asis = TRUE )  # S3 method for class 'StoppingMTDdistribution' knit_print(   x,   ...,   fmt_string =     \"%sIf the mean posterior probability of %s at %.0f%% of %s is at least %4.2f.\\n\\n\",   dose_label = \"the next best dose\",   tox_label = \"toxicity\",   asis = TRUE )  # S3 method for class 'StoppingHighestDose' knit_print(   x,   ...,   dose_label = \"the highest dose in the dose grid\",   asis = TRUE )  # S3 method for class 'StoppingSpecificDose' knit_print(x, ..., dose_label = as.character(x@dose), asis = TRUE)  # S3 method for class 'StoppingTargetProb' knit_print(   x,   ...,   fmt_string =     paste0(\"%sIf the probability of %s at %s is in the range [%4.2f, %4.2f] \",     \"is at least %4.2f.\\n\\n\"),   dose_label = \"the next best dose\",   tox_label = \"toxicity\",   asis = TRUE )  # S3 method for class 'StoppingMinCohorts' knit_print(x, ..., asis = TRUE)  # S3 method for class 'StoppingMinPatients' knit_print(x, ..., label = \"participant\", asis = TRUE)  # S3 method for class 'StoppingPatientsNearDose' knit_print(   x,   ...,   dose_label = \"the next best dose\",   label = \"participants\",   asis = TRUE )  # S3 method for class 'StoppingCohortsNearDose' knit_print(x, ..., dose_label = \"the next best dose\", asis = TRUE)  # S3 method for class 'StoppingMissingDose' knit_print(x, ..., asis = TRUE)"},{"path":"https://openpharma.github.io/crmPack/reference/knit_print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render a CohortSizeConst Object — knit_print","text":"x (ModelParamsNormal) object rendered ... passed knitr::kable() asis (flag) used present label (character) term used label participants tox_label (character) term used describe toxicity level (count) markdown level headings cohort size printed.  integer 1 6 title (character) text heading section describing design sections (character) named vector length least 4 defining headings used define sections corresponding design's slots. element names must match Design's slot names. full_grid (flag) full dose grid appear output table simply doses least one evaluable participant available? Ignored unless summarise == \"dose\". summarise (character) summarise observed data.  default, \"none\", lists observed data participant level.  \"dose\" presents participant counts dose \"cohort\" cohort. summarize (character) Synonym summarise units (character) units values doseGrid format_func (function) function used format range table. use_values (flag) print values associated hyperparameters, symbols used define hyper-parameters.  , example, mu 1. fmt (character) sprintf format string used render numerical values.  Ignored use_values FALSE. biomarker_label (character) term used describe biomarker params (character) names model parameters.  See Usage Notes . preamble (character) text introduces list rules theta (character) LaTeX representation theta vector eff_label (character) term used describe efficacy target_label (character) term used describe target toxicity rate biomarker_units (character) units biomarker measured citation_text (character) text used cite Mozgunov & Jaki citation_link (character) link Mozgunov & Jaki time_unit (character) word used describe units time. See Usage Notes . ordinals (character) character vector whose nth defines word used written representation nth ordinal number. indent (integer) indent level current stopping rule list. Spaces length indent * 4 prepended beginning rendered stopping rule list. dose_label (character) term used describe target dose fmt_string (character) character string defines format output","code":""},{"path":"https://openpharma.github.io/crmPack/reference/knit_print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Render a CohortSizeConst Object — knit_print","text":"character string represents object markdown. markdown representation object, character string character string represents object markdown. character string containing LaTeX rendition object. character string represents object markdown.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/knit_print.html","id":"usage-notes","dir":"Reference","previous_headings":"","what":"Usage Notes","title":"Render a CohortSizeConst Object — knit_print","text":"label describes trial's participants. character vector length 1 2.  length 2, first element describes cohort_size 1 second describes cohort_sizes.  length 1, character s appended value cohort_size 1. default value col.names c(\"Lower\", \"Upper\", \"Cohort size\") caption \"Defined dose used next cohort\". values can overridden passing col.names caption function call. default, columns labelled Lower, Upper Cohort size. table's caption Defined number <tox_label[2]> far observed. values can overridden passing col.names caption function call. label describes trial's participants. character vector length 1 2.  length 2, first element describes single participant second describes situations.  length 1, character s appended value number participants 1. default values col.names caption vary depending summary requested. default values can overridden passing col.names caption function call. params must character vector length equal x@mean (x@cov).  values represent parameters model entries vector theta, left-hand side \"~\" definition prior. named, names valid LaTeX, escaped usual R character variables. example, \"\\\\alpha\" \"\\\\beta_0\".  unnamed, names constructed pre-pending escaped backslash value provided. default value col.names c(\"Min\", \"Max\", \"Increment\") caption \"Defined highest dose administered far\".  values can overridden passing col.names caption function call. default value col.names c(\"Min\", \"Max\", \"Increment\") caption \"Defined number DLTs reported far\". values can overridden passing col.names caption function call. label defines toxicities described. character vector length 1 2.  length 2, first element describes single toxicity second describes toxicity counts.  length 1, character s appended value describing single toxicity. default value col.names c(\"Min\", \"Max\", \"Increment\") caption \"Defined number DLTs current cohort\". values can overridden passing col.names caption function call. tox_label defines toxicities described. character vector length 1 2.  length 2, first element describes single toxicity second describes toxicity counts.  length 1, character s appended value describing single toxicity. section describes use label tox_label, collectively referred labels. label scalar vector length 2.  scalar, converted adding second element equal first, suffixed s. example, tox_label = \"DLT\" becomes tox_label = c(\"DLT\", \"DLTs\").  first element vector used describe count 1.  second used cases. use BibTeX-style citation, specify (example) citation_text = \"@MOZGUNOV\", citation_link = \"\". label character vector length 1 2.  length 2, first element describes count 1 second describes counts. length 1, character s appended value count 1. label time_unit , collectively, labels. label character vector length 1 2.  length 2, first element describes count 1 second describes counts. length 1, character s appended value count 1. label describes trial's participants. character vector length 1 2.  length 2, first element describes cohort_size 1 second describes cohort_sizes.  length 1, character s appended value cohort_size 1. default value col.names c(\"Lower\", \"Upper\", \"Cohort size\") caption \"Defined dose used next cohort\". values can overridden passing col.names caption function call. default, columns labelled Lower, Upper Cohort size. table's caption Defined number <tox_label[2]> far observed. values can overridden passing col.names caption function call. label describes trial's participants. character vector length 1 2.  length 2, first element describes single participant second describes situations.  length 1, character s appended value number participants 1. default values col.names caption vary depending summary requested. default values can overridden passing col.names caption function call. params must character vector length equal x@mean (x@cov).  values represent parameters model entries vector theta, left-hand side \"~\" definition prior. named, names valid LaTeX, escaped usual R character variables. example, \"\\\\alpha\" \"\\\\beta_0\".  unnamed, names constructed pre-pending escaped backslash value provided. default value col.names c(\"Min\", \"Max\", \"Increment\") caption \"Defined highest dose administered far\".  values can overridden passing col.names caption function call. default value col.names c(\"Min\", \"Max\", \"Increment\") caption \"Defined number DLTs reported far\". values can overridden passing col.names caption function call. label defines toxicities described. character vector length 1 2.  length 2, first element describes single toxicity second describes toxicity counts.  length 1, character s appended value describing single toxicity. default value col.names c(\"Min\", \"Max\", \"Increment\") caption \"Defined number DLTs current cohort\". values can overridden passing col.names caption function call. tox_label defines toxicities described. character vector length 1 2.  length 2, first element describes single toxicity second describes toxicity counts.  length 1, character s appended value describing single toxicity. section describes use label tox_label, collectively referred labels. label scalar vector length 2.  scalar, converted adding second element equal first, suffixed s. example, tox_label = \"DLT\" becomes tox_label = c(\"DLT\", \"DLTs\").  first element vector used describe count 1.  second used cases. use BibTeX-style citation, specify (example) citation_text = \"@MOZGUNOV\", citation_link = \"\". label character vector length 1 2.  length 2, first element describes count 1 second describes counts. length 1, character s appended value count 1. label time_unit , collectively, labels. label character vector length 1 2.  length 2, first element describes count 1 second describes counts. length 1, character s appended value count 1.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/logit.html","id":null,"dir":"Reference","previous_headings":"","what":"Shorthand for logit function — logit","title":"Shorthand for logit function — logit","text":"Shorthand logit function","code":""},{"path":"https://openpharma.github.io/crmPack/reference/logit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shorthand for logit function — logit","text":"","code":"logit(x)"},{"path":"https://openpharma.github.io/crmPack/reference/logit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shorthand for logit function — logit","text":"x function argument","code":""},{"path":"https://openpharma.github.io/crmPack/reference/logit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shorthand for logit function — logit","text":"logit(x)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/match_within_tolerance.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for value matching with tolerance — match_within_tolerance","title":"Helper function for value matching with tolerance — match_within_tolerance","text":"modified version match supports tolerance.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/match_within_tolerance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for value matching with tolerance — match_within_tolerance","text":"","code":"match_within_tolerance(x, table)"},{"path":"https://openpharma.github.io/crmPack/reference/match_within_tolerance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for value matching with tolerance — match_within_tolerance","text":"x values matched table values matched ","code":""},{"path":"https://openpharma.github.io/crmPack/reference/match_within_tolerance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for value matching with tolerance — match_within_tolerance","text":"vector length x empty vector table empty.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/maxDose.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the Maximum Possible Next Dose — maxDose","title":"Determine the Maximum Possible Next Dose — maxDose","text":"function determines upper limit next dose based incrementsand data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/maxDose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the Maximum Possible Next Dose — maxDose","text":"","code":"maxDose(increments, data, ...)  # S4 method for class 'IncrementsRelative,Data' maxDose(increments, data, ...)  # S4 method for class 'IncrementsRelativeDLT,Data' maxDose(increments, data, ...)  # S4 method for class 'IncrementsRelativeDLTCurrent,Data' maxDose(increments, data, ...)  # S4 method for class 'IncrementsRelativeParts,DataParts' maxDose(increments, data, ...)  # S4 method for class 'IncrementsDoseLevels,Data' maxDose(increments, data, ...)  # S4 method for class 'IncrementsHSRBeta,Data' maxDose(increments, data, ...)  # S4 method for class 'IncrementsMin,Data' maxDose(increments, data, ...)  # S4 method for class 'IncrementsMin,DataOrdinal' maxDose(increments, data, ...)  # S4 method for class 'IncrementsOrdinal,DataOrdinal' maxDose(increments, data, ...)  # S4 method for class 'IncrementsMaxToxProb,DataOrdinal' maxDose(increments, data, model, samples, ...)  # S4 method for class 'IncrementsMaxToxProb,Data' maxDose(increments, data, model, samples, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/maxDose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the Maximum Possible Next Dose — maxDose","text":"increments (Increments) rule next best dose. data (Data) input data. ... additional arguments without method dispatch. model (GeneralModel) model probabilities based samples (Samples) MCMC samples model applied","code":""},{"path":"https://openpharma.github.io/crmPack/reference/maxDose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the Maximum Possible Next Dose — maxDose","text":"number, maximum possible next dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/maxDose.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Determine the Maximum Possible Next Dose — maxDose","text":"maxDose(increments = IncrementsRelative, data = Data): determine maximum possible next dose based relative increments. maxDose(increments = IncrementsRelativeDLT, data = Data): determine maximum possible next dose based relative increments determined DLTs far. maxDose(increments = IncrementsRelativeDLTCurrent, data = Data): determine maximum possible next dose based relative increments determined DLTs current cohort. maxDose(increments = IncrementsRelativeParts, data = DataParts): determine maximum possible next dose based relative increments well part 1 beginning part 2. maxDose(increments = IncrementsDoseLevels, data = Data): determine maximum possible next dose based number dose grid levels. , max dose determined one level equal : base dose level + level increment. base dose level level last dose grid level maximum dose applied, defined increments object. Find IncrementsDoseLevels. maxDose(increments = IncrementsHSRBeta, data = Data): determine maximum possible next dose escalation. maxDose(increments = IncrementsMin, data = Data): determine maximum possible next dose based multiple increment rules, taking minimum across individual increments. maxDose(increments = IncrementsMin, data = DataOrdinal): determine maximum possible next dose based multiple increment rules, taking minimum across individual increments. maxDose(increments = IncrementsOrdinal, data = DataOrdinal): determine maximum possible next dose ordinal CRM trial maxDose(increments = IncrementsMaxToxProb, data = DataOrdinal): determine maximum possible next dose based probability toxicity maxDose(increments = IncrementsMaxToxProb, data = Data): determine maximum possible next dose based probability toxicity","code":""},{"path":"https://openpharma.github.io/crmPack/reference/maxDose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine the Maximum Possible Next Dose — maxDose","text":"","code":"# Example of usage for `IncrementsRelative` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, 10:40) )  # Define a rule for dose increments which allows for: #  - doubling the dose if the last dose was below 20, #  - increasing the dose by 33% of the last dose, only if the last dose was #    above or equal to 20. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Based on the rule above, the maximum dose allowed is: max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsRelativeDLT` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, seq(from = 10, to = 80, by = 2)) )  # Define a rule for dose increments which allows for: #  - doubling the dose if no DLTs were yet observed, #  - increasing the dose by 33% if 1 or 2 DLTs were already observed, #  - increasing the dose by 20% if at least 3 DLTs were already observed. my_increments <- IncrementsRelativeDLT(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # Based on the rule above, the maximum dose allowed is: max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsRelativeDLTCurrent` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Define a rule for dose increments which allows for: #  - doubling the dose if no DLTs were observed in current (i.e. last) cohort, #  - only increasing the dose by 33% if 1 or 2 DLTs were observed in current cohort, #  - only increasing the dose by 20% if at least 3 DLTs were observed in current cohort. my_increments <- IncrementsRelativeDLTCurrent(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # Based on the rule above, the maximum dose allowed is: max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsRelativeParts` maxDose class.  # Create an object of class `DataParts`. my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 10),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) )  my_increments <- IncrementsRelativeParts(   dlt_start = 0,   clean_start = 1 )  max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsDoseLevels` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 12, 12, 12, 16, 16, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1),   ID = 1:14,   cohort = c(1, 2, 3, 4, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, 10:30) )  # In this first example we define a rule for dose increments which allows for # maximum skip one dose level, that is 2 dose levels higher than the last dose # given. my_increments_1 <- IncrementsDoseLevels(levels = 2, basis_level = \"last\")  # Based on the rule above, the maximum dose allowed is: max_dose_1 <- maxDose(my_increments_1, data = my_data)  # In this second example we define a rule for dose increments which allows for # maximum skip one dose level, that is 2 dose levels higher than the max dose # given. my_increments_2 <- IncrementsDoseLevels(levels = 2, basis_level = \"max\")  # Based on the rule above, the maximum dose allowed is: max_dose_2 <- maxDose(my_increments_2, data = my_data) # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8, 6, 6, 6),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5, 6, 6, 6),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # In this example we define a rule for dose increments that limits the further # dose escalation to doses below 6, because dose 6 is above the probability # toxicity threshold. my_increments <- IncrementsHSRBeta(target = 0.3, prob = 0.95)  # Based on the rule above, we then calculate the maximum dose allowed. my_next_max_dose <- maxDose(my_increments, data = my_data) # Example of usage for `IncrementsRelativeDLTCurrent` maxDose class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 8, 8, 8),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, 8, 10:80) )  # Here, we combine two different increment rules.  # The first rule allows for: #  - doubling the dose if no DLTs were observed at the current dose, #  - increasing the dose by 33% if 1 or 2 DLTs were observed at the current dose, #  - increasing the dose by 22% if 3 or more DLTs were observed. my_increments_1 <- IncrementsRelativeDLT(   intervals = c(0, 1, 3),   increments = c(1, 0.33, 0.2) )  # The second rule allows for: #  - doubling the dose if the current dose is <20, #  - increasing the dose by 33% if the current dose is >=20. my_increments_2 <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Finally, the maximum dose allowed is computed by taking the minimum dose from # the maximum doses computed by the two rules. my_increments <- IncrementsMin(   increments_list = list(my_increments_1, my_increments_2) ) max_dose <- maxDose(my_increments, my_data) maxDose(   increments = IncrementsOrdinal(2L, .DefaultIncrementsRelative()),   data = .DefaultDataOrdinal() ) #> [1] 79.8 model <- LogisticLogNormalOrdinal(   mean = c(0.25, 0.15, 0.5),   cov = matrix(c(1.5, 0, 0, 0, 2, 0, 0, 0, 1), nrow = 3),   ref_dose = 30 )  emptyData <- DataOrdinal(   doseGrid = c(1, 3, 9, 25, 50, 75, 100),   yCategories = c(\"No tox\" = 0L, \"DLAE\" = 1L, \"CRS\" = 2L) )  # For warning regarding tox, see issue #748 https://github.com/openpharma/crmPack/issues/748 suppressWarnings({   samples <- mcmc(emptyData, model, .DefaultMcmcOptions()) }) toxIncrements <- IncrementsMaxToxProb(prob = c(\"DLAE\" = 0.2, \"CRS\" = 0.05)) maxDose(toxIncrements, emptyData, model, samples) #> [1] 1 model <- LogisticLogNormalOrdinal(   mean = c(0.25, 0.15, 0.5),   cov = matrix(c(1.5, 0, 0, 0, 2, 0, 0, 0, 1), nrow = 3),   ref_dose = 30 )  emptyData <- DataOrdinal(   doseGrid = c(1, 3, 9, 25, 50, 75, 100),   yCategories = c(\"No tox\" = 0L, \"DLAE\" = 1L, \"CRS\" = 2L) )  # For warning regarding tox, see issue #748 https://github.com/openpharma/crmPack/issues/748 suppressWarnings({   samples <- mcmc(emptyData, model, .DefaultMcmcOptions()) }) toxIncrements <- IncrementsMaxToxProb(prob = c(\"DLAE\" = 0.2, \"CRS\" = 0.05)) maxDose(toxIncrements, emptyData, model, samples) #> [1] 3"},{"path":"https://openpharma.github.io/crmPack/reference/maxSize.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"function combines cohort size rules taking maximum sizes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/maxSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"maxSize(...)  # S4 method for class 'CohortSize' maxSize(...)"},{"path":"https://openpharma.github.io/crmPack/reference/maxSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"... Objects class CohortSize","code":""},{"path":"https://openpharma.github.io/crmPack/reference/maxSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"combination object class CohortSizeMax","code":""},{"path":"https://openpharma.github.io/crmPack/reference/maxSize.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"","text":"maxSize(CohortSize): method combining cohort size rules taking maximum","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/maxSize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"# Here is the rule for: #   having cohort of size 1 for doses <30 #   and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3))  # Here is the rule for: #   having cohort of size 1 until no DLT were observed #   and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))  # This is combining the two rules above by taking the maximum of the sample sizes of # the single rules mySize <- maxSize(mySize1, mySize2)"},{"path":"https://openpharma.github.io/crmPack/reference/mcmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtaining Posterior Samples for all Model Parameters — mcmc","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"function actually runs JAGS MCMC machinery produce posterior samples model parameters required derived values. generic function, customized versions may conveniently defined specific subclasses GeneralData, GeneralModel, McmcOptions input.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/mcmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"","code":"mcmc(data, model, options, ...)  # S4 method for class 'GeneralData,GeneralModel,McmcOptions' mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for class 'GeneralData,DualEndpointRW,McmcOptions' mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for class 'GeneralData,DualEndpointBeta,McmcOptions' mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for class 'GeneralData,DualEndpointEmax,McmcOptions' mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for class 'GeneralData,OneParLogNormalPrior,McmcOptions' mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for class 'GeneralData,OneParExpPrior,McmcOptions' mcmc(data, model, options, from_prior = data@nObs == 0L, ...)  # S4 method for class 'DataMixture,GeneralModel,McmcOptions' mcmc(   data,   model,   options,   from_prior = data@nObs == 0L & data@nObsshare == 0L,   ... )  # S4 method for class 'Data,LogisticIndepBeta,McmcOptions' mcmc(data, model, options, ...)  # S4 method for class 'DataDual,Effloglog,McmcOptions' mcmc(data, model, options, ...)  # S4 method for class 'DataDual,EffFlexi,McmcOptions' mcmc(data, model, options, ...)  # S4 method for class 'DataOrdinal,LogisticLogNormalOrdinal,McmcOptions' mcmc(data, model, options, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/mcmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"data (GeneralData) input data. model (GeneralModel) input model. options (McmcOptions) MCMC options. ... used. from_prior (flag) sample prior ? Default TRUE number observations data 0. models might necessary specify manually though.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/mcmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"posterior samples, object class Samples.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/mcmc.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"mcmc(data = GeneralData, model = GeneralModel, options = McmcOptions): Standard method uses JAGS. mcmc(data = GeneralData, model = DualEndpointRW, options = McmcOptions): Standard method uses JAGS. DualEndpointRW model, required least two (case random walk prior first order biomarker level) three doses grid. mcmc(data = GeneralData, model = DualEndpointBeta, options = McmcOptions): Standard method uses JAGS. DualEndpointBeta model, required value ref_dose_beta slot greater maximum dose grid. requirement comes definition beta function used model dose-biomarker relationship DualEndpointBeta model. requirement must least one dose grid. mcmc(data = GeneralData, model = DualEndpointEmax, options = McmcOptions): Standard method uses JAGS. DualEndpointEmax model, required least one dose grid. mcmc(data = GeneralData, model = OneParLogNormalPrior, options = McmcOptions): Standard method uses JAGS. OneParLogNormalPrior model, required length skeleton prior probabilities vector equal length number doses. mcmc(data = GeneralData, model = OneParExpPrior, options = McmcOptions): Standard method uses JAGS. OneParExpPrior model, required length skeleton prior probabilities vector equal length number doses. mcmc(data = DataMixture, model = GeneralModel, options = McmcOptions): Method DataMixture different from_prior default mcmc(data = Data, model = LogisticIndepBeta, options = McmcOptions): Obtain posterior samples model parameters based pseudo 'LogisticsIndepBeta' DLE model. joint prior posterior probability density function intercept \\(\\phi_1\\) (phi1) slope \\(\\phi_2\\) (phi2) given Whitehead Williamson (1998) TsuTakawa (1975). However, since asymptotically, joint posterior probability density bivariate normal use bivariate normal distribution generate posterior samples intercept slope parameters. prior samples intercept slope bivariate normal distribution mean covariance matrix given Whitehead Williamson (1998) used. mcmc(data = DataDual, model = Effloglog, options = McmcOptions): Obtain posterior samples model parameters Efficacy log log model. Given value \\(\\nu\\), precision efficacy responses, joint prior posterior probability intercept \\(\\theta_1\\) (theta1) slope \\(\\theta_2\\) (theta2) bivariate normal distribution.  \\(\\nu\\) (nu), precision efficacy responses either fixed value gamma distribution. gamma distribution used, samples nu first generated. mean nu samples used generate samples intercept slope parameters model mcmc(data = DataDual, model = EffFlexi, options = McmcOptions): Obtain posterior samples estimates Efficacy Flexible form. mcmc procedure based described Lang Brezger (2004) samples mean efficacy responses dose levels, samples sigma2 \\(sigma^2\\), variance efficacy response samples sigma2betaW \\(sigma^2_{beta_W}\\), variance random walk model generated. Please refer Lang Brezger (2004) procedures form joint prior posterior probability density mean efficacy responses. addition, sigma2 sigma2betaW can fixed inverse-gamma prior posterior distribution. Therefore, inverse gamma distribution(s) used, parameters distribution first updated samples sigma2 sigma2betaW generated using updated parameters. mcmc(   data = DataOrdinal,   model = LogisticLogNormalOrdinal,   options = McmcOptions ): Obtain posterior samples model parameters LogisticLogNormalOrdinal. generic mcmc method returns Samples object elements data slot named alpha[1], alpha[2], ..., alpha[k] beta passed LogisticLogNormalOrdinal object.  makes \"alpha elements\" awkward access inconsistent Model objects.  rename alpha elements alpha1, alpha2, ..., alpha<k> ease consistency.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/mcmc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"type Random Number Generator (RNG) initial seed used JAGS taken options argument. initial values supplied (.e RNG kind seed slot options NA), generated automatically JAGS.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/mcmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtaining Posterior Samples for all Model Parameters — mcmc","text":"","code":"# Create some data from the class `Data`. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Sample from the posterior distribution. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 1000 )  samples <- mcmc(data = my_data, model = my_model, options = my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $alpha0 #>    [1] -0.9803242769 -0.0555692516 -0.4565358597 -0.4565358597 -0.4565358597 #>    [6] -0.4565358597 -0.4565358597 -0.4565358597 -0.4565358597 -0.4565358597 #>   [11] -0.4565358597 -0.4565358597 -0.4565358597 -0.4565358597 -0.4565358597 #>   [16] -0.6924376299 -0.3622310659  0.7355212912  0.7355212912 -0.7536455437 #>   [21] -0.7536455437 -0.7536455437 -0.7536455437 -0.7536455437 -0.7536455437 #>   [26] -1.4672037559 -1.4672037559 -0.1450371742  0.0010795073  0.0010795073 #>   [31]  0.0010795073  0.0010795073 -0.5784126920 -0.5784126920 -0.5784126920 #>   [36] -0.7308205154  0.0136697254  0.0136697254 -0.0118166690 -0.0118166690 #>   [41] -0.0274772804 -0.0274772804 -0.3727554156  0.7390243756 -0.4422041260 #>   [46] -0.3220332677 -0.3220332677 -0.3220332677 -0.4019084735  0.2607676968 #>   [51]  0.2607676968 -1.5860238390 -1.7665135629 -1.7665135629 -0.8114582692 #>   [56]  1.0139354162  0.7982357891  0.7982357891  0.7982357891  0.7982357891 #>   [61]  0.7982357891 -0.4468045332 -0.5580606558 -0.5580606558 -0.5580606558 #>   [66] -0.3610626585 -0.3610626585  0.1931466239 -0.0788998470 -0.0788998470 #>   [71] -0.0788998470  0.8348088336  0.8348088336  0.8348088336  0.8348088336 #>   [76] -0.2583839431 -0.2583839431 -0.9132300834 -0.2621365950 -0.2702670918 #>   [81] -0.2702670918 -0.2702670918 -0.2702670918 -0.2702670918 -0.2702670918 #>   [86] -0.8000381757 -0.8000381757 -0.8000381757 -0.8000381757 -0.6026908777 #>   [91] -0.6026908777 -0.6026908777 -0.0953751680 -0.0953751680 -0.0953751680 #>   [96] -0.0953751680  0.4117409295 -0.0054615468 -0.0054615468 -0.5118858405 #>  [101] -0.5118858405 -0.5118858405 -0.5118858405 -0.0748645417 -0.0748645417 #>  [106] -0.0748645417 -0.0748645417 -0.0748645417 -0.0748645417  1.0203934335 #>  [111] -1.2120424162 -0.5714269120 -1.4622473077 -0.6305212830  0.3835945771 #>  [116] -0.3872288484 -0.3872288484 -0.7831721333 -0.6416484378 -0.6416484378 #>  [121] -0.6416484378 -0.6416484378  0.2783461767 -0.0268045330  0.4870686287 #>  [126]  0.4870686287  0.4870686287  0.4870686287  0.4870686287  0.4870686287 #>  [131]  0.4870686287  0.4870686287  0.4870686287  0.4870686287 -0.1269655119 #>  [136] -0.8750076612 -1.0378811551 -1.5181268193 -1.5181268193 -1.0601489850 #>  [141] -1.0601489850 -0.4731909874  0.6512903236 -0.7049887608 -0.0723963484 #>  [146]  0.4119466328 -0.0411525671 -0.0411525671  1.5016319582  2.1480611077 #>  [151]  2.3586724941 -0.5146874540 -0.5146874540 -0.5146874540  0.3167205672 #>  [156]  0.3167205672  0.3167205672  0.3167205672  0.0246023060  0.0246023060 #>  [161]  0.0246023060  0.0246023060 -1.0945504412 -1.0945504412 -1.0082029086 #>  [166] -1.0082029086 -1.0082029086 -1.0082029086 -0.2184929863 -0.2184929863 #>  [171] -0.2184929863 -0.2184929863  0.1983956093  0.1983956093  0.1983956093 #>  [176]  0.1983956093  0.1983956093  0.5144812180  0.5144812180  1.3189662470 #>  [181]  0.4457429141  0.4457429141  0.4457429141  1.0242213464 -0.3979641208 #>  [186] -0.3979641208 -0.3979641208 -0.5125625414 -0.5011061963 -0.5011061963 #>  [191] -0.4830371548 -0.4830371548 -0.4830371548 -0.4830371548 -0.4830371548 #>  [196] -0.4830371548 -0.4830371548 -0.4830371548 -0.4830371548 -1.3704417084 #>  [201] -1.3704417084 -0.0786824572 -0.0786824572 -0.0786824572 -0.0786824572 #>  [206]  0.0250126015  0.0250126015  0.0250126015 -0.1907706853 -0.1907706853 #>  [211] -0.6307787229 -1.5076638110 -1.5076638110 -1.5076638110 -1.5076638110 #>  [216] -1.5076638110 -1.5076638110 -0.5486572680 -0.2389175287 -0.2389175287 #>  [221] -0.2389175287 -0.2389175287 -0.2389175287 -0.2016414251 -0.2016414251 #>  [226] -0.2016414251 -0.2016414251 -0.2016414251 -0.2016414251 -0.2016414251 #>  [231] -0.2016414251 -0.6638881406 -0.6638881406  0.2044229939 -0.4246475217 #>  [236] -0.4246475217  1.2245761788  1.2245761788 -0.2981387167 -0.2981387167 #>  [241] -0.2981387167  0.4723624111  0.4723624111  0.4723624111 -1.4379143909 #>  [246] -1.4379143909 -1.3428695947 -0.5987295041 -0.5987295041 -0.1175982855 #>  [251] -1.2570071622 -0.3254292026 -0.3254292026 -0.3254292026 -0.4111892870 #>  [256] -0.4111892870 -1.7273621499 -0.5251745193 -0.5251745193 -0.5251745193 #>  [261] -0.5251745193 -0.5251745193 -0.5251745193  0.0626233232 -1.0198612769 #>  [266] -0.6445036206 -0.5925339625 -0.5925339625 -0.5925339625 -0.5925339625 #>  [271] -0.5925339625 -0.5925339625 -0.5925339625 -0.5925339625 -0.8311303937 #>  [276] -0.8311303937 -0.8311303937 -0.8311303937 -0.8311303937 -0.5696766751 #>  [281] -0.5696766751 -0.8583405894  0.0517890416  0.4086117783  0.4086117783 #>  [286]  1.0610711568 -0.8135646640  1.1143224457  0.1745175783  2.1172126261 #>  [291]  0.2200953372 -0.1335451969 -0.1335451969 -0.1335451969 -0.1335451969 #>  [296] -0.1335451969 -0.1335451969 -0.1335451969 -0.1335451969 -0.2689616839 #>  [301] -0.2772670205 -0.8520584689 -0.8520584689 -0.3633588892 -0.3633588892 #>  [306] -0.3633588892 -0.7220553795 -0.7220553795 -0.7220553795 -0.7220553795 #>  [311] -0.7220553795  0.4499781930  1.6864562190  1.6864562190  1.4835587005 #>  [316]  1.4835587005  1.4835587005  1.4835587005 -0.2244278747 -0.2244278747 #>  [321] -1.4043822110 -0.6758340800 -0.3614377101 -0.3614377101 -0.3614377101 #>  [326] -0.8072139689 -0.8072139689 -0.6728652896 -0.4317057248 -0.4317057248 #>  [331] -0.5865837912 -0.8265393607 -0.8265393607 -0.8265393607  0.1156093507 #>  [336]  0.1156093507  0.1156093507 -0.8710024568 -0.8710024568 -0.9843479401 #>  [341] -0.4192394367 -0.4192394367 -0.4192394367 -1.3458347158  0.6780777305 #>  [346]  0.6780777305 -0.6692462012 -0.6692462012 -0.6692462012  0.3247445211 #>  [351]  0.3247445211  0.1797214290 -0.6415840724  0.6358964938  0.5382177789 #>  [356] -0.2928294653 -0.2928294653 -0.2928294653 -0.2928294653  0.7858738543 #>  [361]  0.7858738543  0.7858738543 -0.6092522790 -0.6092522790 -0.0235838103 #>  [366]  0.5558315953  0.5558315953  0.3996224103 -2.1745414072 -1.7784789604 #>  [371] -1.0579070933 -1.0579070933 -1.8960975140 -2.2817082294 -1.3618786996 #>  [376] -1.3618786996  0.3436184143  0.3436184143  0.6078368327  0.6078368327 #>  [381]  0.6078368327  0.6078368327  0.6078368327  0.6078368327  0.9080426635 #>  [386]  0.6605749357  0.6605749357 -0.4723297211 -0.4723297211 -0.0403265207 #>  [391] -0.7124314477 -0.7124314477 -0.7124314477 -0.7124314477 -0.7124314477 #>  [396] -1.1611527767 -0.3065865284 -0.3065865284 -0.3065865284 -0.3065865284 #>  [401] -0.3065865284 -0.3065865284 -0.3065865284 -0.6345215672 -1.1624045428 #>  [406]  0.2559154697 -0.6202152672 -0.6202152672 -0.6202152672 -0.6202152672 #>  [411] -0.6202152672  0.0230629460  0.7029131202  0.7029131202  0.7029131202 #>  [416]  0.7029131202  0.3510616239  0.3510616239  0.3510616239  0.6484374012 #>  [421]  0.6484374012  0.6484374012 -0.4854679813  0.5243589188  0.5243589188 #>  [426]  0.5243589188  0.5243589188  0.5243589188  0.5243589188  0.3367168507 #>  [431]  0.3367168507  0.8207947016 -1.0999060992 -1.4422116381 -1.4422116381 #>  [436] -1.4422116381 -1.4422116381 -0.0186412257 -0.0186412257 -0.0186412257 #>  [441] -0.0186412257 -0.0186412257  0.3276247662  0.4623044387  0.4442256334 #>  [446] -0.4845119829 -0.4845119829 -0.4845119829  0.2951342283  0.2951342283 #>  [451]  0.2951342283  0.2506175286  0.2506175286  0.2506175286  0.2506175286 #>  [456] -0.9000328926 -1.2630918334 -0.8871395688  0.0874244008  1.0349483656 #>  [461] -0.0030104673  0.1039304155  0.1039304155  0.1039304155  1.5364108133 #>  [466]  1.5364108133 -0.4521557054 -1.0416331253 -0.7631031037 -0.7631031037 #>  [471] -0.7631031037  0.0292676370  1.4693148999  1.4693148999  1.4693148999 #>  [476]  1.4693148999  1.5050604193  0.3403634400 -1.2162658375 -1.2162658375 #>  [481] -1.0300972843 -0.9395576641 -0.9395576641 -0.9395576641 -0.9395576641 #>  [486]  0.6333877562 -0.5921603296 -0.5921603296  0.2782549731  0.2782549731 #>  [491] -1.0251653716 -1.0117919433 -0.2900259857 -0.3456247009 -0.3456247009 #>  [496]  0.0779907073 -1.4786548347 -1.4900577392 -1.4900577392 -1.4900577392 #>  [501] -1.4900577392 -1.4900577392 -0.7192130261 -0.7192130261 -0.7192130261 #>  [506] -0.7192130261 -0.7192130261 -0.7192130261 -0.7192130261 -0.4103475187 #>  [511] -0.1757177966 -0.1757177966 -0.1757177966 -0.1757177966 -0.1757177966 #>  [516] -1.7752721239 -1.7752721239 -0.4022910864 -0.4022910864 -0.8893941069 #>  [521] -0.8893941069 -1.2014131028 -0.9015230348 -0.9015230348 -0.9015230348 #>  [526] -1.2598831003 -1.2598831003 -0.2468652643 -1.6400228777 -1.6400228777 #>  [531] -1.0347891789 -0.3442857496 -0.3442857496  0.0496566674  0.0496566674 #>  [536]  0.0496566674 -0.0636221171  0.4544381350  0.4544381350  1.1535729468 #>  [541]  0.4305775720  0.4305775720  0.4305775720  0.4305775720  0.4305775720 #>  [546]  0.4305775720  0.4305775720  0.4305775720 -0.3475358057 -0.4952566950 #>  [551]  0.2872217854  1.4922261565  1.5226714655  1.5226714655  1.5226714655 #>  [556]  1.5226714655  1.2436359141  1.2436359141  0.0877510277  0.0877510277 #>  [561] -0.4426205856 -0.4426205856 -0.4426205856 -0.4426205856 -0.2738686795 #>  [566] -0.2738686795 -0.2738686795 -0.2738686795 -0.2738686795  0.1184534741 #>  [571]  0.9847283408 -0.0043664579 -0.0043664579 -1.0542821869 -0.6100180765 #>  [576] -0.6100180765 -0.6100180765 -0.2366437338 -0.2836311156 -1.0363846706 #>  [581] -1.0363846706  0.1950832014 -0.3724116206 -0.3724116206 -0.8325471274 #>  [586] -0.8325471274 -0.8325471274 -0.1979069592 -0.1979069592 -0.1979069592 #>  [591] -0.6367463127 -0.6367463127 -0.6367463127 -0.3318525797 -0.3318525797 #>  [596] -0.9228859271 -0.9228859271 -0.7825625079 -0.7825625079 -0.7825625079 #>  [601] -0.3193267121 -0.8186207836 -0.1354235353 -0.4073888752 -0.5559502960 #>  [606]  0.2805189176  0.2805189176  0.2805189176  0.2805189176  0.2805189176 #>  [611]  0.2805189176 -0.6400170252 -0.3151920354  0.3554648577  0.3554648577 #>  [616]  0.5043955912  0.5043955912 -1.0424243605 -0.6042603940 -0.2335302199 #>  [621] -0.2335302199 -0.2335302199 -0.5285077274 -0.5285077274  0.0947907461 #>  [626]  0.7594474990  0.7594474990  0.7594474990  0.0094951942  0.0094951942 #>  [631]  0.0094951942  0.0094951942  0.6566927803  0.5499546632  0.5499546632 #>  [636]  0.7786001043 -0.2246074023 -0.2246074023 -0.2246074023 -0.2246074023 #>  [641] -0.2246074023 -0.2091624585 -0.2091624585  0.3181348055  0.2039014456 #>  [646]  0.2039014456  0.7154644074  0.7154644074 -0.3647873133  0.8353158200 #>  [651]  1.1732544496  1.1732544496  0.6617179438  0.6617179438  0.6617179438 #>  [656]  0.6617179438  0.6617179438  0.6617179438  0.6617179438  0.6617179438 #>  [661]  0.6617179438 -0.4900383425 -1.5014153670 -1.5014153670 -1.5014153670 #>  [666] -1.5014153670 -1.3813140514 -1.3813140514 -1.3813140514 -0.9152082041 #>  [671] -1.3112607795 -1.3112607795 -1.0871286637 -0.1816144017  1.2302374280 #>  [676]  0.0816146559  0.0816146559  0.3558825682  0.3558825682  0.3558825682 #>  [681]  0.6375973870  0.6375973870  0.6375973870  0.6375973870  0.6375973870 #>  [686]  0.2606508494 -0.3342160696 -0.3342160696 -0.3342160696 -0.5294608423 #>  [691] -0.5294608423 -0.5294608423 -0.5294608423 -0.6095339382 -0.6095339382 #>  [696]  0.1493108918  0.1493108918  0.6051919588  0.6051919588  0.6051919588 #>  [701] -0.7862484409 -0.6051209406 -1.6032510477 -0.4834849190 -0.4834849190 #>  [706] -0.6346175081 -0.0240971814 -0.4265422570 -0.4265422570  1.6222957069 #>  [711]  1.6222957069  1.1128434398  0.6199925048  0.6199925048 -1.0031133936 #>  [716] -1.0031133936 -1.0031133936 -1.0031133936 -1.0031133936 -0.2636312619 #>  [721] -0.2636312619 -0.2636312619 -0.2636312619 -0.2636312619 -0.2636312619 #>  [726] -0.2636312619 -0.2636312619 -0.2636312619 -0.2636312619 -0.2636312619 #>  [731]  0.3690192777 -1.4723322133 -1.4723322133 -1.1012976387 -0.0139075395 #>  [736]  0.5845836989  0.5845836989 -0.0002709123  0.6086667859  0.6086667859 #>  [741]  0.6086667859  0.6086667859  0.3702618881  0.6360347450  0.6360347450 #>  [746]  0.6360347450  0.6360347450  0.6360347450  0.6360347450  0.6360347450 #>  [751]  0.6360347450  0.6360347450 -0.1146732676 -0.1146732676 -0.1146732676 #>  [756] -0.1146732676  0.8743848908  0.7779903300  0.7779903300  1.4830625916 #>  [761]  1.4830625916  1.4830625916  2.1814255096  2.1814255096  1.8093032740 #>  [766]  1.8093032740  1.1853356880  1.1853356880  1.1853356880  1.1853356880 #>  [771]  0.2921730423  0.2921730423  1.3440314142  1.3440314142 -1.1115191653 #>  [776] -1.6134941756 -0.2207363600 -0.2207363600 -0.2207363600 -0.0904072587 #>  [781] -0.0904072587  0.6804714520  0.6804714520  0.6804714520 -0.1725213174 #>  [786]  0.6039439186  0.6039439186  0.2963955540  0.2963955540  0.2963955540 #>  [791] -0.6380248593 -0.6380248593 -0.6380248593 -0.1209636271 -0.1209636271 #>  [796] -0.1209636271  0.0387198456  0.0387198456  0.0387198456  0.6047740819 #>  [801]  0.6047740819  0.6047740819  0.6047740819  0.2514866179 -1.0146531516 #>  [806]  0.0321180157  0.0321180157  0.0321180157 -1.6930824648 -1.6930824648 #>  [811] -1.6930824648 -1.6930824648 -0.9938308496 -0.7082474170 -0.0948465919 #>  [816] -0.0948465919 -0.0948465919  0.7726428955 -0.8626375440 -0.1479722055 #>  [821]  0.7108544912 -1.7823190942 -0.3090962701 -0.3090962701 -0.3090962701 #>  [826] -0.3090962701 -0.3090962701 -0.3635090836 -0.3635090836 -0.3635090836 #>  [831] -0.8776919870 -0.8776919870 -1.2770492723 -1.5677915562 -1.5677915562 #>  [836] -0.3844365335 -0.3844365335 -0.3844365335  0.7684755074  0.7684755074 #>  [841]  1.1173891234  0.7689458706  0.7689458706  0.7689458706  0.7689458706 #>  [846] -0.1038978813  0.6009632115  0.6009632115  0.6009632115  0.6009632115 #>  [851] -0.7325078027 -0.8739041135 -0.9327481710 -0.9327481710  0.5613196290 #>  [856]  0.5613196290  0.5613196290  0.2293374810  0.2293374810 -0.7250267243 #>  [861] -0.7250267243  0.5644620409  0.5644620409 -1.1223758758  0.5470337386 #>  [866]  0.6056704768  0.6056704768  0.6056704768  0.7249065436  0.7249065436 #>  [871]  0.7249065436 -0.0886652816 -0.0886652816 -0.2026210692 -0.4661145534 #>  [876] -0.4661145534 -0.4661145534 -0.4661145534 -0.4661145534 -0.4661145534 #>  [881] -0.4661145534 -0.4661145534 -0.8250260818 -0.0397888013 -0.5754065315 #>  [886] -0.5754065315 -1.7868653951 -1.7868653951 -2.0778965127 -1.8042552591 #>  [891] -1.0332629283 -0.1962099905 -0.1962099905  0.7865385370  0.7865385370 #>  [896]  0.7865385370  0.9521133536  0.9521133536  0.9521133536  0.9521133536 #>  [901]  0.9521133536  1.0238349628  1.0238349628 -0.2951349170  0.0452354061 #>  [906]  0.0452354061 -0.3848014781 -1.1405732481 -1.1405732481 -1.1405732481 #>  [911] -0.7133946887  0.1574228766  0.1574228766  0.5472715808  0.5472715808 #>  [916]  0.5472715808 -1.3759547322 -1.3759547322 -1.3759547322 -1.3759547322 #>  [921]  0.2556333099  0.2556333099 -0.9921215407  1.2568853921 -0.7126321310 #>  [926] -0.7126321310 -0.7126321310  0.9068727664 -0.8121531055 -0.8121531055 #>  [931]  0.7036523701  0.7036523701  0.7036523701 -0.5140239700  0.2494416256 #>  [936] -0.9557051604 -0.9557051604 -0.5001325146 -0.5001325146 -0.5001325146 #>  [941] -0.5001325146 -1.7700187269 -1.1072420037 -0.9337122366 -0.9337122366 #>  [946] -0.9337122366 -0.8175073535 -0.8175073535 -1.3948757865 -1.3948757865 #>  [951] -0.7126787029 -0.7126787029 -1.8032222750 -1.8032222750 -1.1483983763 #>  [956] -1.1483983763 -0.4004525514 -0.4004525514 -0.4004525514  0.3093326803 #>  [961] -1.1941970251 -0.6704337705  1.5708644142  1.9480609895  1.0072805286 #>  [966]  1.0072805286  1.0072805286  1.0072805286  1.0072805286  1.0072805286 #>  [971]  0.9660645185 -0.3698112965 -0.3698112965 -0.3698112965 -0.3698112965 #>  [976] -0.3698112965 -1.1127815489 -1.1127815489 -1.5383492422 -1.0771194062 #>  [981] -1.0771194062 -1.0771194062  0.4257629534  0.4257629534 -0.0341378820 #>  [986] -0.6262972257 -0.6262972257  0.0783498694  0.0783498694 -0.4553090114 #>  [991] -0.4553090114 -0.4553090114 -0.4553090114 -0.4553090114 -0.4818297238 #>  [996] -0.4818297238 -0.4818297238 -1.2750651579 -1.5116690803 -0.5873263718 #>  #> $alpha1 #>    [1] 0.3239490 2.3330549 1.3792523 1.3792523 1.3792523 1.3792523 1.3792523 #>    [8] 1.3792523 1.3792523 1.3792523 1.3792523 1.3792523 1.3792523 1.3792523 #>   [15] 1.3792523 1.2317684 2.0283008 1.1982493 1.1982493 1.3318384 1.3318384 #>   [22] 1.3318384 1.3318384 1.3318384 1.3318384 0.3477409 0.3477409 0.2031670 #>   [29] 0.3852282 0.3852282 0.3852282 0.3852282 0.7216876 0.7216876 0.7216876 #>   [36] 1.5768667 1.7366935 1.7366935 0.3574566 0.3574566 2.3067245 2.3067245 #>   [43] 2.5108184 1.5300733 0.7020562 1.7795894 1.7795894 1.7795894 1.0465585 #>   [50] 1.9906549 1.9906549 0.7596186 0.7207746 0.7207746 0.5506507 0.9286689 #>   [57] 0.9347603 0.9347603 0.9347603 0.9347603 0.9347603 0.7988310 1.5579403 #>   [64] 1.5579403 1.5579403 1.4769673 1.4769673 1.1139434 1.0017041 1.0017041 #>   [71] 1.0017041 1.2385096 1.2385096 1.2385096 1.2385096 1.5985137 1.5985137 #>   [78] 3.2425972 2.0420770 1.9517627 1.9517627 1.9517627 1.9517627 1.9517627 #>   [85] 1.9517627 0.5031393 0.5031393 0.5031393 0.5031393 0.9683737 0.9683737 #>   [92] 0.9683737 0.8138013 0.8138013 0.8138013 0.8138013 1.5486590 1.7506041 #>   [99] 1.7506041 1.2816795 1.2816795 1.2816795 1.2816795 1.1774099 1.1774099 #>  [106] 1.1774099 1.1774099 1.1774099 1.1774099 3.4586253 2.1363995 1.0344392 #>  [113] 1.0765233 1.3067499 1.6940278 0.7413460 0.7413460 0.2814712 1.5682591 #>  [120] 1.5682591 1.5682591 1.5682591 1.2814688 0.5208250 1.0464878 1.0464878 #>  [127] 1.0464878 1.0464878 1.0464878 1.0464878 1.0464878 1.0464878 1.0464878 #>  [134] 1.0464878 0.3274896 1.7428814 2.2981573 0.8472447 0.8472447 1.2086083 #>  [141] 1.2086083 0.6497807 0.6239638 0.8885691 0.6224413 0.8448855 0.3434885 #>  [148] 0.3434885 0.7177985 2.2815327 2.7040054 1.0103227 1.0103227 1.0103227 #>  [155] 1.9919389 1.9919389 1.9919389 1.9919389 2.7041194 2.7041194 2.7041194 #>  [162] 2.7041194 1.4924414 1.4924414 0.8021752 0.8021752 0.8021752 0.8021752 #>  [169] 1.6799201 1.6799201 1.6799201 1.6799201 1.2462798 1.2462798 1.2462798 #>  [176] 1.2462798 1.2462798 0.7622378 0.7622378 1.2163109 1.4267812 1.4267812 #>  [183] 1.4267812 1.1765813 1.3142749 1.3142749 1.3142749 0.4140979 0.5137030 #>  [190] 0.5137030 1.7427984 1.7427984 1.7427984 1.7427984 1.7427984 1.7427984 #>  [197] 1.7427984 1.7427984 1.7427984 1.3460301 1.3460301 1.4691429 1.4691429 #>  [204] 1.4691429 1.4691429 1.0559056 1.0559056 1.0559056 1.2151473 1.2151473 #>  [211] 2.1038221 0.9122461 0.9122461 0.9122461 0.9122461 0.9122461 0.9122461 #>  [218] 1.8541530 0.9756710 0.9756710 0.9756710 0.9756710 0.9756710 1.6181531 #>  [225] 1.6181531 1.6181531 1.6181531 1.6181531 1.6181531 1.6181531 1.6181531 #>  [232] 0.8175282 0.8175282 0.7701420 0.7394677 0.7394677 1.2066679 1.2066679 #>  [239] 0.9567028 0.9567028 0.9567028 1.7025407 1.7025407 1.7025407 3.9446809 #>  [246] 3.9446809 0.6129820 0.4707670 0.4707670 1.2310169 1.4351050 1.0481927 #>  [253] 1.0481927 1.0481927 1.0003428 1.0003428 1.8618746 0.3338011 0.3338011 #>  [260] 0.3338011 0.3338011 0.3338011 0.3338011 0.4076856 1.5110387 1.2529564 #>  [267] 1.1246776 1.1246776 1.1246776 1.1246776 1.1246776 1.1246776 1.1246776 #>  [274] 1.1246776 0.6848799 0.6848799 0.6848799 0.6848799 0.6848799 0.6640241 #>  [281] 0.6640241 1.7833261 1.9633573 2.9666299 2.9666299 1.9015560 1.4510665 #>  [288] 2.3385186 2.4800257 1.3496409 1.8729244 1.1498071 1.1498071 1.1498071 #>  [295] 1.1498071 1.1498071 1.1498071 1.1498071 1.1498071 1.1220627 1.8557411 #>  [302] 0.4704785 0.4704785 0.5235002 0.5235002 0.5235002 1.5189229 1.5189229 #>  [309] 1.5189229 1.5189229 1.5189229 1.7731634 1.3598923 1.3598923 1.4029357 #>  [316] 1.4029357 1.4029357 1.4029357 1.1105426 1.1105426 1.0206177 0.7400556 #>  [323] 1.9282176 1.9282176 1.9282176 0.7965591 0.7965591 1.6000918 0.2169661 #>  [330] 0.2169661 0.3893936 1.9296936 1.9296936 1.9296936 1.2583258 1.2583258 #>  [337] 1.2583258 0.9403441 0.9403441 1.0743773 0.7928295 0.7928295 0.7928295 #>  [344] 0.4559070 1.0818705 1.0818705 1.2177302 1.2177302 1.2177302 0.4777202 #>  [351] 0.4777202 0.4230876 1.7171217 0.9904152 0.7695243 1.3021840 1.3021840 #>  [358] 1.3021840 1.3021840 0.8499017 0.8499017 0.8499017 0.8378590 0.8378590 #>  [365] 0.3418656 0.6334153 0.6334153 0.6654126 0.7263400 0.3300603 0.1908282 #>  [372] 0.1908282 0.4776810 1.7089710 0.6144809 0.6144809 0.4335065 0.4335065 #>  [379] 1.0796604 1.0796604 1.0796604 1.0796604 1.0796604 1.0796604 1.0284404 #>  [386] 0.5471656 0.5471656 1.3800206 1.3800206 1.1826103 1.0795969 1.0795969 #>  [393] 1.0795969 1.0795969 1.0795969 0.5835711 1.5079823 1.5079823 1.5079823 #>  [400] 1.5079823 1.5079823 1.5079823 1.5079823 0.4819329 1.4280805 0.7625637 #>  [407] 0.8150774 0.8150774 0.8150774 0.8150774 0.8150774 0.3884925 1.4206057 #>  [414] 1.4206057 1.4206057 1.4206057 0.7803511 0.7803511 0.7803511 0.8629213 #>  [421] 0.8629213 0.8629213 0.6602635 1.1040868 1.1040868 1.1040868 1.1040868 #>  [428] 1.1040868 1.1040868 0.7888112 0.7888112 0.6477841 0.9329621 1.1784632 #>  [435] 1.1784632 1.1784632 1.1784632 0.8849297 0.8849297 0.8849297 0.8849297 #>  [442] 0.8849297 1.3724967 0.6320591 1.2074997 0.7258968 0.7258968 0.7258968 #>  [449] 0.9891235 0.9891235 0.9891235 1.3136623 1.3136623 1.3136623 1.3136623 #>  [456] 1.3661598 0.6364336 0.6714796 1.8858242 0.6896244 0.6281266 0.7374371 #>  [463] 0.7374371 0.7374371 1.2345295 1.2345295 2.3687018 0.6990882 1.4952606 #>  [470] 1.4952606 1.4952606 1.5662291 1.1428137 1.1428137 1.1428137 1.1428137 #>  [477] 1.9924877 0.5737497 1.0152928 1.0152928 0.4712430 0.5000790 0.5000790 #>  [484] 0.5000790 0.5000790 0.9247604 0.7348456 0.7348456 0.5489408 0.5489408 #>  [491] 0.4711904 0.5287475 0.7741206 1.2557451 1.2557451 0.6632799 1.7736468 #>  [498] 1.7322564 1.7322564 1.7322564 1.7322564 1.7322564 1.0754133 1.0754133 #>  [505] 1.0754133 1.0754133 1.0754133 1.0754133 1.0754133 0.5080695 2.8148490 #>  [512] 2.8148490 2.8148490 2.8148490 2.8148490 1.1914050 1.1914050 1.4108071 #>  [519] 1.4108071 1.6341434 1.6341434 3.1559382 2.6014409 2.6014409 2.6014409 #>  [526] 0.2858469 0.2858469 0.2727087 2.0748041 2.0748041 1.0832833 1.2134113 #>  [533] 1.2134113 1.5453507 1.5453507 1.5453507 0.5296421 0.7755178 0.7755178 #>  [540] 0.8089188 1.8875035 1.8875035 1.8875035 1.8875035 1.8875035 1.8875035 #>  [547] 1.8875035 1.8875035 0.4328694 3.0418659 2.1087199 1.6492171 1.8331914 #>  [554] 1.8331914 1.8331914 1.8331914 1.2342112 1.2342112 1.0740871 1.0740871 #>  [561] 1.1812891 1.1812891 1.1812891 1.1812891 1.0334107 1.0334107 1.0334107 #>  [568] 1.0334107 1.0334107 0.4892227 1.5222723 2.2774720 2.2774720 0.8623723 #>  [575] 1.5483564 1.5483564 1.5483564 0.5501503 0.6177295 0.5685809 0.5685809 #>  [582] 0.8172062 2.4223761 2.4223761 1.4100927 1.4100927 1.4100927 1.0269567 #>  [589] 1.0269567 1.0269567 0.9355385 0.9355385 0.9355385 0.5465650 0.5465650 #>  [596] 0.9130028 0.9130028 1.3351245 1.3351245 1.3351245 0.5198307 1.6789681 #>  [603] 1.7345254 1.1532577 0.4459692 1.3603065 1.3603065 1.3603065 1.3603065 #>  [610] 1.3603065 1.3603065 0.7163267 0.6175180 0.2932535 0.2932535 0.3037709 #>  [617] 0.3037709 0.2983613 1.3912223 0.5452670 0.5452670 0.5452670 0.6910975 #>  [624] 0.6910975 1.0626971 1.6162195 1.6162195 1.6162195 1.9855313 1.9855313 #>  [631] 1.9855313 1.9855313 1.8017250 0.6513403 0.6513403 1.1252943 0.9129100 #>  [638] 0.9129100 0.9129100 0.9129100 0.9129100 0.3591831 0.3591831 0.6039996 #>  [645] 0.7223657 0.7223657 0.8038286 0.8038286 0.2213821 1.7968906 1.5923980 #>  [652] 1.5923980 1.7463042 1.7463042 1.7463042 1.7463042 1.7463042 1.7463042 #>  [659] 1.7463042 1.7463042 1.7463042 0.6281647 0.8331490 0.8331490 0.8331490 #>  [666] 0.8331490 2.4484253 2.4484253 2.4484253 1.1889505 1.1619785 1.1619785 #>  [673] 0.6566490 2.2723854 1.6189701 0.6635506 0.6635506 1.0905395 1.0905395 #>  [680] 1.0905395 1.5676408 1.5676408 1.5676408 1.5676408 1.5676408 0.8045295 #>  [687] 1.2779426 1.2779426 1.2779426 1.4453135 1.4453135 1.4453135 1.4453135 #>  [694] 2.3854387 2.3854387 0.8908079 0.8908079 1.4916128 1.4916128 1.4916128 #>  [701] 1.4389899 0.5190430 1.3399784 0.4187883 0.4187883 1.3465067 0.7477522 #>  [708] 1.5145003 1.5145003 1.1504555 1.1504555 2.1445271 0.7960128 0.7960128 #>  [715] 1.2439550 1.2439550 1.2439550 1.2439550 1.2439550 1.0009075 1.0009075 #>  [722] 1.0009075 1.0009075 1.0009075 1.0009075 1.0009075 1.0009075 1.0009075 #>  [729] 1.0009075 1.0009075 0.8207563 2.5822745 2.5822745 0.8458541 0.5682096 #>  [736] 1.2043978 1.2043978 1.5222236 1.3666351 1.3666351 1.3666351 1.3666351 #>  [743] 1.6066805 1.0526106 1.0526106 1.0526106 1.0526106 1.0526106 1.0526106 #>  [750] 1.0526106 1.0526106 1.0526106 0.8732315 0.8732315 0.8732315 0.8732315 #>  [757] 0.5108545 0.7627500 0.7627500 1.0595323 1.0595323 1.0595323 1.9479591 #>  [764] 1.9479591 2.4051177 2.4051177 3.0066242 3.0066242 3.0066242 3.0066242 #>  [771] 2.3989735 2.3989735 2.1673093 2.1673093 3.0326696 1.1709891 2.1204546 #>  [778] 2.1204546 2.1204546 0.5529165 0.5529165 1.2010300 1.2010300 1.2010300 #>  [785] 1.7111282 1.0281996 1.0281996 1.5500978 1.5500978 1.5500978 1.3149977 #>  [792] 1.3149977 1.3149977 1.0291939 1.0291939 1.0291939 0.9853294 0.9853294 #>  [799] 0.9853294 1.0337713 1.0337713 1.0337713 1.0337713 0.9404352 1.2132273 #>  [806] 1.4826332 1.4826332 1.4826332 2.3903693 2.3903693 2.3903693 2.3903693 #>  [813] 2.9776350 0.3870106 0.2312759 0.2312759 0.2312759 1.0315783 0.9253358 #>  [820] 0.2693198 0.4363913 0.8251591 1.3081993 1.3081993 1.3081993 1.3081993 #>  [827] 1.3081993 0.8457450 0.8457450 0.8457450 1.8084437 1.8084437 1.2493278 #>  [834] 1.6431478 1.6431478 2.1600473 2.1600473 2.1600473 0.4318899 0.4318899 #>  [841] 1.1846733 0.6538220 0.6538220 0.6538220 0.6538220 0.3542846 0.9957896 #>  [848] 0.9957896 0.9957896 0.9957896 1.5167514 1.1315561 0.8971829 0.8971829 #>  [855] 0.9482217 0.9482217 0.9482217 1.1207341 1.1207341 1.2255133 1.2255133 #>  [862] 1.0145959 1.0145959 0.8966413 0.4109961 1.5594127 1.5594127 1.5594127 #>  [869] 0.7061740 0.7061740 0.7061740 0.5841524 0.5841524 0.6089815 1.2721409 #>  [876] 1.2721409 1.2721409 1.2721409 1.2721409 1.2721409 1.2721409 1.2721409 #>  [883] 0.5608437 0.4778590 0.4925547 0.4925547 0.9773523 0.9773523 0.7523428 #>  [890] 0.4127845 0.2398397 0.3901209 0.3901209 1.0570443 1.0570443 1.0570443 #>  [897] 1.0486051 1.0486051 1.0486051 1.0486051 1.0486051 1.1506029 1.1506029 #>  [904] 1.9979335 2.8852495 2.8852495 3.3823034 2.2037239 2.2037239 2.2037239 #>  [911] 0.6296909 0.6467014 0.6467014 0.7358542 0.7358542 0.7358542 1.0433384 #>  [918] 1.0433384 1.0433384 1.0433384 1.0446136 1.0446136 1.1271987 1.2174281 #>  [925] 0.7775681 0.7775681 0.7775681 1.2353658 1.4507543 1.4507543 1.2217790 #>  [932] 1.2217790 1.2217790 1.1713856 0.5792831 0.8020144 0.8020144 2.7994602 #>  [939] 2.7994602 2.7994602 2.7994602 2.4818367 2.9854294 2.3539955 2.3539955 #>  [946] 2.3539955 1.6314216 1.6314216 1.6756129 1.6756129 0.4525715 0.4525715 #>  [953] 0.8779989 0.8779989 0.2391549 0.2391549 0.9504787 0.9504787 0.9504787 #>  [960] 1.0690490 1.4341287 3.5407049 2.0246305 1.6064878 1.5166508 1.5166508 #>  [967] 1.5166508 1.5166508 1.5166508 1.5166508 0.6662146 0.8701030 0.8701030 #>  [974] 0.8701030 0.8701030 0.8701030 2.4548779 2.4548779 0.7023930 0.6086359 #>  [981] 0.6086359 0.6086359 1.9490721 1.9490721 0.9208709 1.6502395 1.6502395 #>  [988] 1.9498711 1.9498711 0.5925531 0.5925531 0.5925531 0.5925531 0.5925531 #>  [995] 2.0482449 2.0482449 2.0482449 0.9042000 1.7349965 0.9334747 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 2100 #>  #> Slot \"burnin\": #> [1] 100 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] NA #>  #> Slot \"rng_seed\": #> [1] NA #>  #>  # Create some data from the class `DataDual`. plcb <- 0.001 my_data <- DataDual(   w = c(13, 77, 86, 26, 27, 36, 37, 97, 21, 49, 87, 48),   x = c(plcb, 25, 25, 25, plcb, 50, 50, 50, plcb, 100, 100, 100),   y = c(0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L),   doseGrid = c(plcb, seq(25, 300, 25)),   placebo = TRUE,   ID = 1:12,   cohort = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L) )  # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   sigma2betaW = 0.01,   rw1 = TRUE )  # Sample from the posterior distribution. my_options <- McmcOptions(   burnin = 50,   step = 2,   samples = 4,   rng_kind = \"Mersenne-Twister\",   rng_seed = 1 )  samples <- mcmc(data = my_data, model = my_model, options = my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $betaW #>          [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]     [,8] #> [1,] 43.97979 44.41466 44.43972 44.11392 44.62213 45.16043 45.16812 45.21349 #> [2,] 43.15657 42.91989 43.51310 44.68803 44.56862 44.87953 44.94821 45.51928 #> [3,] 63.68104 63.29789 63.85898 64.05148 63.52357 64.10696 64.75609 65.32082 #> [4,] 50.45590 49.98192 49.94248 50.23495 50.54648 50.68016 51.02047 50.21193 #>          [,9]    [,10]    [,11]    [,12]    [,13] #> [1,] 45.17819 44.50411 44.97736 44.98087 45.22721 #> [2,] 45.87216 45.26223 45.42696 45.75288 45.95267 #> [3,] 65.62907 65.52253 66.59065 66.42558 66.77227 #> [4,] 50.02701 49.17010 49.01135 49.45278 49.73688 #>  #> $betaZ #>           [,1]       [,2] #> [1,] -2.507907 0.03496807 #> [2,] -2.507907 0.03496807 #> [3,] -2.507907 0.03496807 #> [4,] -2.507907 0.03496807 #>  #> $delta #>            [,1]        [,2]       [,3]       [,4]      [,5]        [,6] #> [1,]  0.4348687  0.02505645 -0.3258029  0.5082169 0.5382963 0.007687938 #> [2,] -0.2366798  0.59321185  1.1749236 -0.1194105 0.3109172 0.068670722 #> [3,] -0.3831418  0.56109098  0.1924961 -0.5279107 0.5833939 0.649129673 #> [4,] -0.4739807 -0.03943816  0.2924624  0.3115307 0.1336790 0.340314130 #>             [,7]        [,8]       [,9]      [,10]        [,11]     [,12] #> [1,]  0.04537578 -0.03529845 -0.6740836  0.4732525  0.003504127 0.2463430 #> [2,]  0.57107036  0.35288467 -0.6099253  0.1647277  0.325915901 0.1997869 #> [3,]  0.56472919  0.30824406 -0.1065357  1.0681196 -0.165072414 0.3466892 #> [4,] -0.80854374 -0.18491804 -0.8569132 -0.1587477  0.441429357 0.2841035 #>  #> $precW #> [1] 0.0007380298 0.0009402290 0.0006374998 0.0006963610 #>  #> $rho #> [1] 0.1193680 0.1129187 0.2440825 0.1499421 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 58 #>  #> Slot \"burnin\": #> [1] 50 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] \"base::Mersenne-Twister\" #>  #> Slot \"rng_seed\": #> [1] 1 #>  #>  # Create some data from the class `DataDual`. plcb <- 0.001 my_data <- DataDual(   w = c(13, 77, 86, 26, 27, 36, 37, 97, 21, 49, 87, 48),   x = c(plcb, 25, 25, 25, plcb, 50, 50, 50, plcb, 100, 100, 100),   y = c(0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 0L),   doseGrid = c(plcb, seq(25, 300, 25)),   placebo = TRUE,   ID = 1:12,   cohort = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L) )  # Initialize the CRM model. my_model <- DualEndpointBeta(   mean = c(0, 1),   cov = diag(2),   ref_dose = 2,   use_log_dose = FALSE,   sigma2W = c(a = 1, b = 2),   rho = c(a = 1.5, b = 2.5),   E0 = 2,   Emax = 50,   delta1 = 6,   mode = 9,   ref_dose_beta = my_data@doseGrid[my_data@nGrid] + 10 )  # Sample from the posterior distribution. my_options <- McmcOptions(   burnin = 50,   step = 2,   samples = 4,   rng_kind = \"Mersenne-Twister\",   rng_seed = 1 )  samples <- mcmc(data = my_data, model = my_model, options = my_options) samples #> An object of class \"Samples\" #> Slot \"data\": #> $betaW #>      [,1]     [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #> [1,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #> [2,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #> [3,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #> [4,]    2 2.383076    2    2    2    2    2    2    2     2     2     2     2 #>  #> $betaZ #>           [,1]       [,2] #> [1,] -4.354759 0.09035452 #> [2,] -4.354759 0.09035452 #> [3,] -4.354759 0.09035452 #> [4,] -3.273111 0.08172139 #>  #> $precW #> [1] 0.0004229406 0.0004149886 0.0004264222 0.0003413195 #>  #> $rho #> [1] -0.5116824 -0.5902350 -0.5709147 -0.5230612 #>  #>  #> Slot \"options\": #> An object of class \"McmcOptions\" #> Slot \"iterations\": #> [1] 58 #>  #> Slot \"burnin\": #> [1] 50 #>  #> Slot \"step\": #> [1] 2 #>  #> Slot \"rng_kind\": #> [1] \"base::Mersenne-Twister\" #>  #> Slot \"rng_seed\": #> [1] 1 #>  #>  ##obtain mcmc DLE samples given the data, LogisticIndepBeta (DLE model) and mcmc simulations options ## data must be of 'Data' class data <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = seq(25, 300, 25) ) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be of 'LogisticIndepBeta' class model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## options must be ''McmcOptions' class options <- McmcOptions(burnin = 100, step = 2, samples = 200) set.seed(94) samples <- mcmc(data = data, model = model, options = options) # nolint start ##obtain mcmc efficacy samples given the data, 'Effloglog' model (efficacy model) and ## mcmc simulations options data must be of 'DataDual' class data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be of 'Effloglog' class Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data )  ## options must be ''McmcOptions' class options <- McmcOptions(burnin = 100, step = 2, samples = 200) set.seed(94) samples <- mcmc(data = data, model = Effmodel, options = options) # nolint end ## obtain mcmc efficacy samples given the data, 'EffFlexi' model (efficacy model) and ## mcmc simulations options ## data must be of 'DataDual' class data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25) ) #> Used default patient IDs! #> Used best guess cohort indices! ## model must be of 'EffFlexi' class  effmodel <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = data )  ## options must be ''McmcOptions' class options <- McmcOptions(burnin = 100, step = 2, samples = 200) set.seed(94) samples <- mcmc(data = data, model = effmodel, options = options) ordinal_data <- .DefaultDataOrdinal() ordinal_model <- .DefaultLogisticLogNormalOrdinal() mcmc_options <- .DefaultMcmcOptions()  samples <- mcmc(ordinal_data, ordinal_model, mcmc_options) #> Warning: Unused variable \"y\" in data"},{"path":"https://openpharma.github.io/crmPack/reference/minSize.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"function combines cohort size rules taking minimum sizes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/minSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"minSize(...)  # S4 method for class 'CohortSize' minSize(...)"},{"path":"https://openpharma.github.io/crmPack/reference/minSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"... Objects class CohortSize","code":""},{"path":"https://openpharma.github.io/crmPack/reference/minSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"combination object class CohortSizeMin","code":""},{"path":"https://openpharma.github.io/crmPack/reference/minSize.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"","text":"minSize(CohortSize): method combining cohort size rules taking minimum","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/minSize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"# Here is the rule for: #   having cohort of size 1 for doses <30 #   and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(intervals = c(0, 30), cohort_size = c(1, 3))  # Here is the rule for: #   having cohort of size 1 until no DLT were observed #   and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(intervals = c(0, 1), cohort_size = c(1, 3))  # This is combining the two rules above by taking the minimum of the sample sizes of # the single rules mySize <- minSize(mySize1, mySize2)"},{"path":"https://openpharma.github.io/crmPack/reference/myBayesLogit.html","id":null,"dir":"Reference","previous_headings":"","what":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"MCMC sampling Bayesian logistic regression model","code":""},{"path":"https://openpharma.github.io/crmPack/reference/myBayesLogit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"","code":"myBayesLogit(y, X, m0, P0, options)"},{"path":"https://openpharma.github.io/crmPack/reference/myBayesLogit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"y 0/1 vector responses X design matrix m0 prior mean vector P0 precision matrix options McmcOptions object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/myBayesLogit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do MCMC sampling for Bayesian logistic regression model — myBayesLogit","text":"matrix samples (samples x parameters)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/names-Samples-method.html","id":null,"dir":"Reference","previous_headings":"","what":"The Names of the Sampled Parameters — names,Samples-method","title":"The Names of the Sampled Parameters — names,Samples-method","text":"method returns names parameters sampled.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/names-Samples-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Names of the Sampled Parameters — names,Samples-method","text":"","code":"# S4 method for class 'Samples' names(x)"},{"path":"https://openpharma.github.io/crmPack/reference/names-Samples-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Names of the Sampled Parameters — names,Samples-method","text":"x (Samples) object samples.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/names-Samples-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Names of the Sampled Parameters — names,Samples-method","text":"","code":"my_samples <- Samples(   data = list(alpha = 1:5, beta = 15:19),   options = McmcOptions(burnin = 2, step = 2, samples = 5) )  names(my_samples) #> [1] \"alpha\" \"beta\""},{"path":"https://openpharma.github.io/crmPack/reference/nextBest.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding the Next Best Dose — nextBest","title":"Finding the Next Best Dose — nextBest","text":"function computes recommended next best dose based corresponding rule nextBest, posterior samples model underlying data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/nextBest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding the Next Best Dose — nextBest","text":"","code":"nextBest(nextBest, doselimit, samples, model, data, ...)  # S4 method for class 'NextBestMTD,numeric,Samples,GeneralModel,Data' nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for class 'NextBestNCRM,numeric,Samples,GeneralModel,Data' nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for class 'NextBestNCRM,numeric,Samples,GeneralModel,DataParts' nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for class 'NextBestNCRMLoss,numeric,Samples,GeneralModel,Data' nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for class 'NextBestThreePlusThree,missing,missing,missing,Data' nextBest(nextBest, doselimit, samples, model, data, ...)  # S4 method for class 'NextBestDualEndpoint,numeric,Samples,DualEndpoint,Data' nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for class 'NextBestMinDist,numeric,Samples,GeneralModel,Data' nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for class 'NextBestInfTheory,numeric,Samples,GeneralModel,Data' nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for class 'NextBestTD,numeric,missing,LogisticIndepBeta,Data' nextBest(nextBest, doselimit = Inf, model, data, in_sim = FALSE, ...)  # S4 method for class 'NextBestTDsamples,numeric,Samples,LogisticIndepBeta,Data' nextBest(nextBest, doselimit = Inf, samples, model, data, in_sim, ...)  # S4 method for class 'NextBestMaxGain,numeric,missing,ModelTox,DataDual' nextBest(   nextBest,   doselimit = Inf,   model,   data,   model_eff,   in_sim = FALSE,   ... )  # S4 method for class 'NextBestMaxGainSamples,numeric,Samples,ModelTox,DataDual' nextBest(   nextBest,   doselimit = Inf,   samples,   model,   data,   model_eff,   samples_eff,   in_sim = FALSE,   ... )  # S4 method for class 'NextBestProbMTDLTE,numeric,Samples,GeneralModel,Data' nextBest(nextBest, doselimit, samples, model, data, ...)  # S4 method for class 'NextBestProbMTDMinDist,numeric,Samples,GeneralModel,Data' nextBest(nextBest, doselimit, samples, model, data, ...)  # S4 method for class 'NextBestOrdinal,numeric,Samples,GeneralModel,Data' nextBest(nextBest, doselimit = Inf, samples, model, data, ...)  # S4 method for class 'NextBestOrdinal,numeric,Samples,LogisticLogNormalOrdinal,DataOrdinal' nextBest(nextBest, doselimit = Inf, samples, model, data, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/nextBest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding the Next Best Dose — nextBest","text":"nextBest (NextBest) rule next best dose. doselimit (number) maximum allowed next dose. infinity (default), essentially dose limit applied course dose recommendation calculation. samples (Samples) posterior samples model parameters given data. model (ModelTox) DLT model. data (Data) data used generate samples. ... additional arguments without method dispatch. in_sim (flag) method used simulations? Default FALSE. flag TRUE target dose estimates (trial end--trial) outside dose grid range, information message printed method. model_eff (Effloglog EffFlexi) efficacy model. samples_eff (Samples) posterior samples model_eff parameters given data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/nextBest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding the Next Best Dose — nextBest","text":"list next best dose recommendation  (element named value) grid defined data, plot depicting recommendation (element named plot). case multiple plots also element named singlePlots included. singlePlots list single plots. additional list elements describing outcome rule can contained .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/nextBest.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Finding the Next Best Dose — nextBest","text":"nextBest(   nextBest = NextBestMTD,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based MTD rule. nextBest(   nextBest = NextBestNCRM,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based NCRM method. additional element probs output's list contains target overdosing probabilities (across doses dose grid) used derivation next best dose. nextBest(   nextBest = NextBestNCRM,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = DataParts ): find next best dose based NCRM method two parts trial used. nextBest(   nextBest = NextBestNCRMLoss,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based NCRM method loss function. nextBest(   nextBest = NextBestThreePlusThree,   doselimit = missing,   samples = missing,   model = missing,   data = Data ): find next best dose based 3+3 method. nextBest(   nextBest = NextBestDualEndpoint,   doselimit = numeric,   samples = Samples,   model = DualEndpoint,   data = Data ): find next best dose based dual endpoint model. additional list element probs contains target overdosing probabilities (across doses dose grid) used derivation next best dose. nextBest(   nextBest = NextBestMinDist,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): gives dose dose limit estimated DLT probability closest target dose. nextBest(   nextBest = NextBestInfTheory,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): gives appropriate dose within information theoretic framework. nextBest(   nextBest = NextBestTD,   doselimit = numeric,   samples = missing,   model = LogisticIndepBeta,   data = Data ): find next best dose based DLT responses LogisticIndepBeta model class object without DLT samples. nextBest(   nextBest = NextBestTDsamples,   doselimit = numeric,   samples = Samples,   model = LogisticIndepBeta,   data = Data ): find next best dose based DLT responses LogisticIndepBeta model class object involving DLT samples. nextBest(   nextBest = NextBestMaxGain,   doselimit = numeric,   samples = missing,   model = ModelTox,   data = DataDual ): find next best dose based pseudo DLT model ModelTox Effloglog efficacy model without samples. nextBest(   nextBest = NextBestMaxGainSamples,   doselimit = numeric,   samples = Samples,   model = ModelTox,   data = DataDual ): find next best dose based DLT efficacy responses DLT efficacy samples. nextBest(   nextBest = NextBestProbMTDLTE,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based highest probability toxicity rate less equal target toxicity level. nextBest(   nextBest = NextBestProbMTDMinDist,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose based highest probability toxicity rate minimum distance target toxicity level. nextBest(   nextBest = NextBestOrdinal,   doselimit = numeric,   samples = Samples,   model = GeneralModel,   data = Data ): find next best dose ordinal CRM models. nextBest(   nextBest = NextBestOrdinal,   doselimit = numeric,   samples = Samples,   model = LogisticLogNormalOrdinal,   data = DataOrdinal ): find next best dose ordinal CRM models.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/nextBest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding the Next Best Dose — nextBest","text":"","code":"# Example of usage for `NextBestMTD` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestMTD' class. mtd_next_best <- NextBestMTD(   target = 0.33,   derive = function(mtd_samples) {     quantile(mtd_samples, probs = 0.25)   } )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = mtd_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data ) #> Warning: Arguments in `...` must be used. #> ✖ Problematic arguments: #> • fill = \"grey50\" #> • colour = \"grey50\" #> ℹ Did you misspell an argument name? # Example of usage for `NextBestNCRM` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestNCRM' class. nrcm_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nrcm_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # See the probabilities. dose_recommendation$probs #>       dose target overdose #>  [1,]  0.1  0.000    0.000 #>  [2,]  0.5  0.004    0.000 #>  [3,]  1.5  0.018    0.000 #>  [4,]  3.0  0.038    0.008 #>  [5,]  6.0  0.110    0.024 #>  [6,] 10.0  0.242    0.044 #>  [7,] 12.0  0.212    0.108 #>  [8,] 14.0  0.264    0.136 #>  [9,] 16.0  0.264    0.168 #> [10,] 18.0  0.288    0.198 #> [11,] 20.0  0.304    0.222 #> [12,] 22.0  0.300    0.284 #> [13,] 24.0  0.324    0.310 #> [14,] 26.0  0.330    0.352 #> [15,] 28.0  0.344    0.386 #> [16,] 30.0  0.346    0.414 #> [17,] 32.0  0.328    0.458 #> [18,] 34.0  0.342    0.484 #> [19,] 36.0  0.312    0.538 #> [20,] 38.0  0.302    0.552 #> [21,] 40.0  0.320    0.570 #> [22,] 42.0  0.302    0.590 #> [23,] 44.0  0.292    0.608 #> [24,] 46.0  0.278    0.628 #> [25,] 48.0  0.244    0.672 #> [26,] 50.0  0.234    0.686 #> [27,] 52.0  0.206    0.720 #> [28,] 54.0  0.190    0.738 #> [29,] 56.0  0.186    0.748 #> [30,] 58.0  0.188    0.748 #> [31,] 60.0  0.178    0.758 #> [32,] 62.0  0.166    0.774 #> [33,] 64.0  0.166    0.786 #> [34,] 66.0  0.164    0.790 #> [35,] 68.0  0.132    0.824 #> [36,] 70.0  0.122    0.844 #> [37,] 72.0  0.108    0.858 #> [38,] 74.0  0.106    0.868 #> [39,] 76.0  0.088    0.888 #> [40,] 78.0  0.080    0.896 #> [41,] 80.0  0.078    0.898 # Example of usage for `NextBestNCRM-DataParts` NextBest class.  # Create the data. my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   ID = 1:3,   cohort = 1:3,   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelativeParts(   dlt_start = 0,   clean_start = 1 ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestNCRM' class. nrcm_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nrcm_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  dose_recommendation #> $value #> [1] 3 #>  #> $plot #> NULL #>  # Example of usage for `NextBestNCRMLoss` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the class `NextBestNCRMLoss`. nrcm_loss_next_best <- NextBestNCRMLoss(   target = c(0.2, 0.35),   overdose = c(0.35, 0.6),   unacceptable = c(0.6, 1),   max_overdose_prob = 0.999,   losses = c(1, 0, 1, 2) )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nrcm_loss_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Next best dose. dose_recommendation$value #> [1] 20  # Look at the probabilities. dose_recommendation$probs #>     dose underdosing target excessive unacceptable        mean    std_dev #> 0.1  0.1       0.998  0.002     0.000        0.000 0.007949619 0.02395591 #> 0.5  0.5       0.988  0.012     0.000        0.000 0.018506360 0.03847254 #> 1.5  1.5       0.970  0.024     0.006        0.000 0.036195664 0.05524255 #> 3    3.0       0.956  0.036     0.008        0.000 0.057648759 0.07065623 #> 6    6.0       0.896  0.078     0.026        0.000 0.094719678 0.09115928 #> 10  10.0       0.762  0.184     0.054        0.000 0.138684220 0.10995273 #> 12  12.0       0.668  0.264     0.066        0.002 0.159147984 0.11736413 #> 14  14.0       0.632  0.254     0.110        0.004 0.178785501 0.12382810 #> 16  16.0       0.618  0.248     0.124        0.010 0.197675063 0.12949120 #> 18  18.0       0.552  0.306     0.132        0.010 0.215874298 0.13445573 #> 20  20.0       0.462  0.342     0.184        0.012 0.233428923 0.13880100 #> 22  22.0       0.416  0.344     0.228        0.012 0.250377051 0.14259377 #> 24  24.0       0.374  0.362     0.248        0.016 0.266751447 0.14589358 #> 26  26.0       0.310  0.404     0.258        0.028 0.282580775 0.14875537 #> 28  28.0       0.288  0.400     0.274        0.038 0.297890356 0.15123083 #> 30  30.0       0.238  0.408     0.294        0.060 0.312702673 0.15336886 #> 32  32.0       0.208  0.390     0.336        0.066 0.327037758 0.15521560 #> 34  34.0       0.184  0.398     0.342        0.076 0.340913537 0.15681417 #> 36  36.0       0.160  0.370     0.392        0.078 0.354346148 0.15820419 #> 38  38.0       0.154  0.344     0.412        0.090 0.367350259 0.15942132 #> 40  40.0       0.124  0.348     0.416        0.112 0.379939369 0.16049684 #> 42  42.0       0.116  0.346     0.414        0.124 0.392126090 0.16145744 #> 44  44.0       0.088  0.294     0.488        0.130 0.403922397 0.16232529 #> 46  46.0       0.080  0.298     0.492        0.130 0.415339829 0.16311822 #> 48  48.0       0.080  0.272     0.514        0.134 0.426389651 0.16385020 #> 50  50.0       0.070  0.238     0.518        0.174 0.437082955 0.16453188 #> 52  52.0       0.066  0.228     0.522        0.184 0.447430734 0.16517120 #> 54  54.0       0.062  0.228     0.500        0.210 0.457443907 0.16577399 #> 56  56.0       0.060  0.214     0.492        0.234 0.467133320 0.16634445 #> 58  58.0       0.054  0.188     0.500        0.258 0.476509733 0.16688565 #> 60  60.0       0.054  0.164     0.476        0.306 0.485583792 0.16739987 #> 62  62.0       0.044  0.156     0.488        0.312 0.494365995 0.16788881 #> 64  64.0       0.042  0.152     0.478        0.328 0.502866662 0.16835387 #> 66  66.0       0.038  0.142     0.480        0.340 0.511095900 0.16879619 #> 68  68.0       0.038  0.140     0.474        0.348 0.519063581 0.16921680 #> 70  70.0       0.026  0.144     0.470        0.360 0.526779322 0.16961661 #> 72  72.0       0.026  0.130     0.472        0.372 0.534252460 0.16999647 #> 74  74.0       0.026  0.122     0.446        0.406 0.541492050 0.17035719 #> 76  76.0       0.026  0.114     0.450        0.410 0.548506853 0.17069951 #> 78  78.0       0.018  0.118     0.452        0.412 0.555305333 0.17102412 #> 80  80.0       0.016  0.114     0.440        0.430 0.561895655 0.17133165 #>     posterior_loss #> 0.1          0.998 #> 0.5          0.988 #> 1.5          0.976 #> 3            0.964 #> 6            0.922 #> 10           0.816 #> 12           0.738 #> 14           0.750 #> 16           0.762 #> 18           0.704 #> 20           0.670 #> 22           0.668 #> 24           0.654 #> 26           0.624 #> 28           0.638 #> 30           0.652 #> 32           0.676 #> 34           0.678 #> 36           0.708 #> 38           0.746 #> 40           0.764 #> 42           0.778 #> 44           0.836 #> 46           0.832 #> 48           0.862 #> 50           0.936 #> 52           0.956 #> 54           0.982 #> 56           1.020 #> 58           1.070 #> 60           1.142 #> 62           1.156 #> 64           1.176 #> 66           1.198 #> 68           1.208 #> 70           1.216 #> 72           1.242 #> 74           1.284 #> 76           1.296 #> 78           1.294 #> 80           1.316  # Define another rule (loss function of 3 elements). nrcm_loss_next_best_losses_3 <- NextBestNCRMLoss(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.30,   losses = c(1, 0, 2) )  # Calculate the next best dose. dose_recommendation_losses_3 <- nextBest(   nextBest = nrcm_loss_next_best_losses_3,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Next best dose. dose_recommendation_losses_3$value #> [1] 12  # Look at the probabilities. dose_recommendation_losses_3$probs #>     dose underdosing target overdose        mean    std_dev posterior_loss #> 0.1  0.1       0.998  0.002    0.000 0.007949619 0.02395591          0.998 #> 0.5  0.5       0.988  0.012    0.000 0.018506360 0.03847254          0.988 #> 1.5  1.5       0.970  0.024    0.006 0.036195664 0.05524255          0.982 #> 3    3.0       0.956  0.036    0.008 0.057648759 0.07065623          0.972 #> 6    6.0       0.896  0.078    0.026 0.094719678 0.09115928          0.948 #> 10  10.0       0.762  0.184    0.054 0.138684220 0.10995273          0.870 #> 12  12.0       0.668  0.264    0.068 0.159147984 0.11736413          0.804 #> 14  14.0       0.632  0.254    0.114 0.178785501 0.12382810          0.860 #> 16  16.0       0.618  0.248    0.134 0.197675063 0.12949120          0.886 #> 18  18.0       0.552  0.306    0.142 0.215874298 0.13445573          0.836 #> 20  20.0       0.462  0.342    0.196 0.233428923 0.13880100          0.854 #> 22  22.0       0.416  0.344    0.240 0.250377051 0.14259377          0.896 #> 24  24.0       0.374  0.362    0.264 0.266751447 0.14589358          0.902 #> 26  26.0       0.310  0.404    0.286 0.282580775 0.14875537          0.882 #> 28  28.0       0.288  0.400    0.312 0.297890356 0.15123083          0.912 #> 30  30.0       0.238  0.408    0.354 0.312702673 0.15336886          0.946 #> 32  32.0       0.208  0.390    0.402 0.327037758 0.15521560          1.012 #> 34  34.0       0.184  0.398    0.418 0.340913537 0.15681417          1.020 #> 36  36.0       0.160  0.370    0.470 0.354346148 0.15820419          1.100 #> 38  38.0       0.154  0.344    0.502 0.367350259 0.15942132          1.158 #> 40  40.0       0.124  0.348    0.528 0.379939369 0.16049684          1.180 #> 42  42.0       0.116  0.346    0.538 0.392126090 0.16145744          1.192 #> 44  44.0       0.088  0.294    0.618 0.403922397 0.16232529          1.324 #> 46  46.0       0.080  0.298    0.622 0.415339829 0.16311822          1.324 #> 48  48.0       0.080  0.272    0.648 0.426389651 0.16385020          1.376 #> 50  50.0       0.070  0.238    0.692 0.437082955 0.16453188          1.454 #> 52  52.0       0.066  0.228    0.706 0.447430734 0.16517120          1.478 #> 54  54.0       0.062  0.228    0.710 0.457443907 0.16577399          1.482 #> 56  56.0       0.060  0.214    0.726 0.467133320 0.16634445          1.512 #> 58  58.0       0.054  0.188    0.758 0.476509733 0.16688565          1.570 #> 60  60.0       0.054  0.164    0.782 0.485583792 0.16739987          1.618 #> 62  62.0       0.044  0.156    0.800 0.494365995 0.16788881          1.644 #> 64  64.0       0.042  0.152    0.806 0.502866662 0.16835387          1.654 #> 66  66.0       0.038  0.142    0.820 0.511095900 0.16879619          1.678 #> 68  68.0       0.038  0.140    0.822 0.519063581 0.16921680          1.682 #> 70  70.0       0.026  0.144    0.830 0.526779322 0.16961661          1.686 #> 72  72.0       0.026  0.130    0.844 0.534252460 0.16999647          1.714 #> 74  74.0       0.026  0.122    0.852 0.541492050 0.17035719          1.730 #> 76  76.0       0.026  0.114    0.860 0.548506853 0.17069951          1.746 #> 78  78.0       0.018  0.118    0.864 0.555305333 0.17102412          1.746 #> 80  80.0       0.016  0.114    0.870 0.561895655 0.17133165          1.756 # Example of usage for `NextBestThreePlusThree` NextBest class.  # Create the data. my_data <- Data(   x = c(5, 5, 5, 10, 10, 10),   y = c(0, 0, 0, 0, 1, 0),   ID = 1:6,   cohort = c(0, 0, 0, 1, 1, 1),   doseGrid = c(0.1, 0.5, 1.5, 3, 5, seq(from = 10, to = 80, by = 2)) )  # The rule to select the next best dose will be based on the 3+3 method. my_next_best <- NextBestThreePlusThree()  # Calculate the next best dose. dose_recommendation <- nextBest(my_next_best, data = my_data) # Example of usage for `NextBestDualEndpoint` NextBest class.  # Create the data. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 50, 50, 50),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1),   ID = 1:17,   cohort = c(     1L,     2L,     3L,     4L,     5L,     6L,     6L,     6L,     7L,     7L,     7L,     8L,     8L,     8L,     9L,     9L,     9L   ),   w = c(     0.31,     0.42,     0.59,     0.45,     0.6,     0.7,     0.55,     0.6,     0.52,     0.54,     0.56,     0.43,     0.41,     0.39,     0.34,     0.38,     0.21   ),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the Dual-Endpoint model (in this case RW1). my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose. In this case, # target a dose achieving at least 0.9 of maximum biomarker level (efficacy) # and with a probability below 0.25 that prob(DLT)>0.35 (safety). de_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = de_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # See the probabilities. dose_recommendation$probs #>       dose target overdose #>  [1,]  0.1  0.014    0.012 #>  [2,]  0.5  0.004    0.012 #>  [3,]  1.5  0.040    0.012 #>  [4,]  3.0  0.024    0.012 #>  [5,]  6.0  0.104    0.012 #>  [6,] 10.0  0.106    0.028 #>  [7,] 12.0  0.122    0.040 #>  [8,] 14.0  0.064    0.102 #>  [9,] 16.0  0.028    0.234 #> [10,] 18.0  0.034    0.322 #> [11,] 20.0  0.010    0.440 #> [12,] 22.0  0.028    0.596 #> [13,] 24.0  0.040    0.740 #> [14,] 26.0  0.036    0.820 #> [15,] 28.0  0.032    0.854 #> [16,] 30.0  0.014    0.900 #> [17,] 32.0  0.018    0.960 #> [18,] 34.0  0.012    0.972 #> [19,] 36.0  0.000    0.982 #> [20,] 38.0  0.000    0.986 #> [21,] 40.0  0.000    1.000 #> [22,] 42.0  0.002    1.000 #> [23,] 44.0  0.006    1.000 #> [24,] 46.0  0.004    1.000 #> [25,] 48.0  0.000    1.000 #> [26,] 50.0  0.000    1.000 #> [27,] 52.0  0.002    1.000 #> [28,] 54.0  0.008    1.000 #> [29,] 56.0  0.002    1.000 #> [30,] 58.0  0.010    1.000 #> [31,] 60.0  0.016    1.000 #> [32,] 62.0  0.014    1.000 #> [33,] 64.0  0.008    1.000 #> [34,] 66.0  0.016    1.000 #> [35,] 68.0  0.020    1.000 #> [36,] 70.0  0.028    1.000 #> [37,] 72.0  0.020    1.000 #> [38,] 74.0  0.026    1.000 #> [39,] 76.0  0.024    1.000 #> [40,] 78.0  0.040    1.000 #> [41,] 80.0  0.024    1.000  # Joint plot. print(dose_recommendation$plot)   # Show customization of single plot. variant1 <- dose_recommendation$singlePlots$plot1 + xlim(0, 20) print(variant1) #> Warning: Removed 31 rows containing missing values or values outside the scale range #> (`geom_bar()`). #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_vline()`).  # Example of usage for `NextBestTD` NextBest class. my_data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 5L, 6L, 7L),   doseGrid = seq(from = 25, to = 300, by = 25) )  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # Target probabilities of the occurrence of a DLT during trial and # at the end of the trial are defined as 0.35 and 0.3, respectively. td_next_best <- NextBestTD(prob_target_drt = 0.35, prob_target_eot = 0.3)  # doselimit is the maximum allowable dose level to be given to subjects. dose_recommendation <- nextBest(   nextBest = td_next_best,   doselimit = max(my_data@doseGrid),   model = my_model,   data = my_data )  dose_recommendation$next_dose_drt #> [1] 50 dose_recommendation$plot  # Example of usage for `NextBestTDsamples` NextBest class. my_data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 5L, 6L, 7L),   doseGrid = seq(from = 25, to = 300, by = 25) )  my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # Set-up some MCMC parameters and generate samples. my_options <- McmcOptions(burnin = 100, step = 2, samples = 800) my_samples <- mcmc(my_data, my_model, my_options)  # Target probabilities of the occurrence of a DLT during trial and # at the end of the trial are defined as 0.35 and 0.3, respectively. # 'derive' is specified such that the 30% posterior quantile of the TD35 and # TD30 samples will be used as TD35 and TD30 estimates. tds_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  # doselimit is the maximum allowable dose level to be given to subjects. dose_recommendation <- nextBest(   nextBest = tds_next_best,   doselimit = max(my_data@doseGrid),   samples = my_samples,   model = my_model,   data = my_data )  dose_recommendation$next_dose_drt #> [1] 50 dose_recommendation$plot #> Warning: Some data points are outside of `bounds`. Removing them. #> Warning: Some data points are outside of `bounds`. Removing them.  # Example of usage for `NextBestMaxGain` NextBest class.  # Create the data. my_data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   ID = 1:8,   cohort = 1:8,   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE )  # 'ModelTox' DLT model, e.g 'LogisticIndepBeta'. my_model_dlt <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # 'ModelEff' efficacy model, e.g. 'Effloglog'. my_model_eff <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data )  # Target probabilities of the occurrence of a DLT during trial and at the # end of trial are defined as 0.35 and 0.3, respectively. mg_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # doselimit is the maximum allowable dose level to be given to subjects. dose_recommendation <- nextBest(   nextBest = mg_next_best,   doselimit = 300,   model = my_model_dlt,   model_eff = my_model_eff,   data = my_data )  dose_recommendation$next_dose #> [1] 75 dose_recommendation$plot  # Example of usage for `NextBestMaxGainSamples` NextBest class.  # Create the data. my_data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   ID = 1:8,   cohort = 1:8,   doseGrid = seq(25, 300, 25),   placebo = FALSE )  # 'ModelTox' DLT model, e.g 'LogisticIndepBeta'. my_model_dlt <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = my_data )  # 'ModelEff' efficacy model, e.g 'Effloglog'. my_model_effll <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = my_data )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples_dlt <- mcmc(my_data, my_model_dlt, my_options) my_samples_effll <- mcmc(my_data, my_model_effll, my_options)  # Target probabilities of the occurrence of a DLT during trial and at the end of # trial are defined as 0.35 and 0.3, respectively. # Use 30% posterior quantile of the TD35 and TD30 samples as estimates of TD35 # and TD30. # Use 50% posterior quantile of the Gstar (the dose which gives the maxim gain value) # samples as Gstar estimate. mgs_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  dose_recommendation <- nextBest(   nextBest = mgs_next_best,   doselimit = max(my_data@doseGrid),   samples = my_samples_dlt,   model = my_model_dlt,   data = my_data,   model_eff = my_model_effll,   samples_eff = my_samples_effll )  dose_recommendation$next_dose #> [1] 75 dose_recommendation$plot   # Now using the 'EffFlexi' class efficacy model:  my_model_effflexi <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = my_data )  my_samples_effflexi <- mcmc(my_data, my_model_effflexi, my_options)  dose_recommendation <- nextBest(   nextBest = mgs_next_best,   doselimit = max(my_data@doseGrid),   samples = my_samples_dlt,   model = my_model_dlt,   data = my_data,   model_eff = my_model_effflexi,   samples_eff = my_samples_effflexi )  dose_recommendation$next_dose #> [1] 75 dose_recommendation$plot # Example of usage for `NextBestProbMTDLTE` NextBest class.  # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestProbMTDLTE' class. nb_mtd_lte <- NextBestProbMTDLTE(target = 0.33)  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nb_mtd_lte,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data ) #> Warning: Arguments in `...` must be used. #> ✖ Problematic arguments: #> • fill = \"grey50\" #> • colour = \"grey50\" #> ℹ Did you misspell an argument name? # Example of usage for `NextBestProbMTDMinDist` NextBest class.  # Create the data. my_data <- Data(   x = c(1.5, 1.5, 1.5, 2.5, 2.5, 2.5, 3.5, 3.5, 3.5),   y = c(0, 0, 0, 0, 0, 0, 1, 1, 0),   ID = 1:9,   cohort = c(1, 1, 1, 2, 2, 2, 3, 3, 3),   doseGrid = c(1.5, 2.5, 3.5, 4.5, 6, 7) )  # Initialize the CRM model used to model the data. my_model <- my_model <- LogisticKadaneBetaGamma(   theta = 0.3,   xmin = 1.5,   xmax = 7,   alpha = 1,   beta = 19,   shape = 0.5625,   rate = 0.125 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsDoseLevels(levels = 1)  next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the 'NextBestProbMTDMinDist' class. nb_mtd_min_dist <- NextBestProbMTDMinDist(target = 0.3)  # Calculate the next best dose. dose_recommendation <- nextBest(   nextBest = nb_mtd_min_dist,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data ) #> Warning: Arguments in `...` must be used. #> ✖ Problematic arguments: #> • fill = \"grey50\" #> • colour = \"grey50\" #> ℹ Did you misspell an argument name? ordinal_data <- .DefaultDataOrdinal() ordinal_model <- .DefaultLogisticLogNormalOrdinal() options <- .DefaultMcmcOptions() ordinal_samples <- mcmc(ordinal_data, ordinal_model, options) #> Warning: Unused variable \"y\" in data  nextBest(   nextBest = NextBestOrdinal(2L, .DefaultNextBestNCRM()),   samples = ordinal_samples,   doselimit = Inf,   model = ordinal_model,   data = ordinal_data )  #> $value #> [1] 60 #>  #> $plot #>  #> $singlePlots #> $singlePlots$plot1  #>  #> $singlePlots$plot2 #>  #>  #> $probs #>       dose target overdose #>  [1,]   10  0.000    0.000 #>  [2,]   20  0.000    0.000 #>  [3,]   30  0.000    0.000 #>  [4,]   40  0.002    0.000 #>  [5,]   50  0.028    0.002 #>  [6,]   60  0.212    0.131 #>  [7,]   70  0.188    0.469 #>  [8,]   80  0.138    0.649 #>  [9,]   90  0.113    0.731 #> [10,]  100  0.086    0.791 #>  ordinal_data <- .DefaultDataOrdinal() ordinal_model <- .DefaultLogisticLogNormalOrdinal() options <- .DefaultMcmcOptions() ordinal_samples <- mcmc(ordinal_data, ordinal_model, options) #> Warning: Unused variable \"y\" in data  nextBest(   nextBest = NextBestOrdinal(2L, .DefaultNextBestNCRM()),   samples = ordinal_samples,   doselimit = Inf,   model = ordinal_model,   data = ordinal_data )  #> $value #> [1] 60 #>  #> $plot #>  #> $singlePlots #> $singlePlots$plot1  #>  #> $singlePlots$plot2  #>  #>  #> $probs #>       dose target overdose #>  [1,]   10  0.000    0.000 #>  [2,]   20  0.000    0.000 #>  [3,]   30  0.001    0.000 #>  [4,]   40  0.002    0.000 #>  [5,]   50  0.017    0.000 #>  [6,]   60  0.219    0.123 #>  [7,]   70  0.185    0.479 #>  [8,]   80  0.113    0.655 #>  [9,]   90  0.093    0.732 #> [10,]  100  0.081    0.779 #>"},{"path":"https://openpharma.github.io/crmPack/reference/ngrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of Doses in Grid — ngrid","title":"Number of Doses in Grid — ngrid","text":"function gets number doses grid. User can choose whether placebo dose () counted .","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ngrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of Doses in Grid — ngrid","text":"","code":"ngrid(object, ignore_placebo = TRUE, ...)  # S4 method for class 'Data' ngrid(object, ignore_placebo = TRUE, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/ngrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of Doses in Grid — ngrid","text":"object (Data) object dose grid. ignore_placebo (flag) placebo dose () counted? ... arguments passed class-specific methods.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ngrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of Doses in Grid — ngrid","text":"integer number doses grid.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/ngrid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of Doses in Grid — ngrid","text":"","code":"my_data <- Data(   x = c(10, 50, 90, 100, 0.001, 20, 30, 30),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(1L, 2L, 3L, 4L, 5L, 5L, 6L, 6L),   doseGrid = c(0.001, seq(from = 10, to = 100, by = 10)),   placebo = TRUE ) ngrid(my_data) #> [1] 10 ngrid(my_data, ignore_placebo = FALSE) #> [1] 11"},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-Stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining two atomic stopping rules — or-Stopping-Stopping","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"method combining two atomic stopping rules","code":""},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-Stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"","code":"# S4 method for class 'Stopping,Stopping' e1 | e2"},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-Stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"e1 First Stopping object e2 Second Stopping object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-Stopping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"StoppingAny object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-Stopping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining two atomic stopping rules — or-Stopping-Stopping","text":"","code":"## Example of combining two atomic stopping rules with an OR ('|') operator  myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)  myStopping <- myStopping1 | myStopping2"},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"method combining stopping list atomic","code":""},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"","code":"# S4 method for class 'StoppingAny,Stopping' e1 | e2"},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"e1 StoppingAny object e2 Stopping object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"modified StoppingAny object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/or-Stopping-StoppingAny.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining a stopping list and an atomic — or-Stopping-StoppingAny","text":"","code":"## Example of combining a list of stopping rules with an atomic stopping rule ## with an OR ('|') operator  myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)  myStopping3 <- StoppingMinPatients(nPatients = 20)  myStopping <- (myStopping1 & myStopping2) | myStopping3"},{"path":"https://openpharma.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"method combining atomic stopping list","code":""},{"path":"https://openpharma.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"","code":"# S4 method for class 'Stopping,StoppingAny' e1 | e2"},{"path":"https://openpharma.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"e1 Stopping object e2 StoppingAny object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"modified StoppingAny object","code":""},{"path":"https://openpharma.github.io/crmPack/reference/or-StoppingAny-Stopping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The method combining an atomic and a stopping list — or-StoppingAny-Stopping","text":"","code":"## Example of combining an atomic stopping rule with a list of stopping rules ## with an OR ('|') operator  myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)  myStopping3 <- StoppingMinPatients(nPatients = 20)  myStopping <- myStopping3 | (myStopping1 & myStopping2)"},{"path":"https://openpharma.github.io/crmPack/reference/pinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the distribution function of Inverse gamma distribution — pinvGamma","title":"Compute the distribution function of Inverse gamma distribution — pinvGamma","text":"Compute distribution function Inverse gamma distribution","code":""},{"path":"https://openpharma.github.io/crmPack/reference/pinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the distribution function of Inverse gamma distribution — pinvGamma","text":"","code":"pinvGamma(q, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://openpharma.github.io/crmPack/reference/pinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the distribution function of Inverse gamma distribution — pinvGamma","text":"q vector quantiles shape parameter inverse gamma distribution b scale parameter inverse gamma distribution lower.tail logical; TRUE (default), probabilities P(X  > x), otherwise, P(X <= x). log.p TRUE, probabilities/densities p returned log(p)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://openpharma.github.io/crmPack/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"Plot fitted dose-tox based given pseudo DLE model data without samples","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"","code":"# S4 method for class 'Data,ModelTox' plot(   x,   y,   xlab = \"Dose level\",   ylab = \"Probability of DLE\",   showLegend = TRUE,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"x data Data class object y model ModelTox class object xlab x axis label ylab y axis label showLegend legend shown? (default) ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"returns ggplot object dose-DLE model plot","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data-ModelTox-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of the fitted dose-tox based with a given pseudo DLE model and data without samples — plot,Data,ModelTox-method","text":"","code":"## plot the dose-DLE curve given a pseudo DLE model using data without samples ## data must be of 'Data' class ## define the data data <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1L:8L,   cohort = as.integer(c(1, 2, 2, 3, 4, 4, 5, 6)),   doseGrid = seq(25, 300, 25) ) ## model must be from 'ModelTox' class e.g 'LogisticIndepBeta' class model ## define the model (see LogisticIndepBeta example) model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## plot the dose-DLE curve ## 'x' is the data and 'y' is the model in plot plot(x = data, y = model)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"method creates plot Data  DataOrdinal objects.  method creates plot Data object.  method creates plot DataOrdinal object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"","code":"h_plot_data_dataordinal(   x,   blind = FALSE,   legend = TRUE,   tox_labels = c(Yes = \"red\", No = \"black\"),   tox_shapes = c(Yes = 17L, No = 16L),   ... )  # S4 method for class 'Data,missing' plot(x, y, blind = FALSE, legend = TRUE, ...)  # S4 method for class 'DataOrdinal,missing' plot(   x,   y,   blind = FALSE,   legend = TRUE,   tox_labels = NULL,   tox_shapes = NULL,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"x (DataOrdinal) object want plot. blind (flag) indicates whether blind data. TRUE, placebo subjects reported level active dose level corresponding cohort, DLTs always assigned first subjects cohort. legend (flag) whether legend added. tox_labels (named list character) labels toxicity categories. tox_shapes (names list integers) symbols used identify toxicity categories. ... used. y (missing) missing object, compatibility generic function.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"ggplot2::ggplot2 object. ggplot2::ggplot2 object. ggplot2::ggplot2 object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"default values tox_shapes tox_labels result DLTs displayed red triangles responses black circles. 9 toxicity categories, toxicity symbols must specified manually. 5 toxicity categories, toxicity labels must specified manually.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper Function for the Plot Method of the Data and DataOrdinal Classes — h_plot_data_dataordinal","text":"","code":"# Create some data of class 'Data'. my_data <- Data(   x = c(0.001, 0.1, 0.1, 0.5, 0.001, 3, 3, 0.001, 10, 10, 10),   y = c(0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0),   cohort = c(1, 1, 1, 2, 3, 3, 3, 4, 4, 4, 4),   doseGrid = c(0.001, 0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   placeb = TRUE ) #> Used default patient IDs!  # Plot the data. plot(my_data)  data <- DataOrdinal(   x = c(10, 20, 30, 40, 50, 50, 50, 60, 60, 60),   y = as.integer(c(0, 0, 0, 0, 0, 1, 0, 0, 1, 2)),   ID = 1L:10L,   cohort = as.integer(c(1:4, 5, 5, 5, 6, 6, 6)),   doseGrid = c(seq(from = 10, to = 100, by = 10)),   yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L),   placebo = FALSE )  plot(data)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for the DataDA Class — plot,DataDA,missing-method","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"method creates plot DataDA object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"","code":"# S4 method for class 'DataDA,missing' plot(x, y, blind = FALSE, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"x (DataDA) object want plot. y (missing) missing object, compatibility generic function. blind (flag) indicates whether blind data. TRUE, placebo subjects reported level active dose level corresponding cohort, DLTs always assigned first subjects cohort. ... passed first inherited method plot current method.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"ggplot2::ggplot2 object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDA-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Method for the DataDA Class — plot,DataDA,missing-method","text":"","code":"# Create some data of class 'DataDA'. my_data <- DataDA(   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60,   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Plot the data. plot(my_data)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"Plot fitted dose-efficacy based given pseudo efficacy model data without samples","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"","code":"# S4 method for class 'DataDual,ModelEff' plot(   x,   y,   ...,   xlab = \"Dose level\",   ylab = \"Expected Efficacy\",   showLegend = TRUE )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"x data DataDual class object y model ModelEff class object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"returns ggplot object dose-efficacy model plot","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-ModelEff-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of the fitted dose-efficacy based with a given pseudo efficacy model and data without samples — plot,DataDual,ModelEff-method","text":"","code":"# nolint start  ##plot the dose-efficacy curve given a pseudo efficacy model using data without samples ##data must be of 'DataDual' class ##define the data data <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ##model must be from 'ModelEff' class e.g 'Effloglog' class model ##define the model (see Effloglog example) Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data ) ## plot the dose-efficacy curve ## 'x' is the data and 'y' is the model in plot plot(x = data, y = Effmodel) #> Warning: Arguments in `...` must be used. #> ✖ Problematic argument: #> • group = group #> ℹ Did you misspell an argument name?   # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for the DataDual Class — plot,DataDual,missing-method","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"method creates plot DataDual object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"","code":"# S4 method for class 'DataDual,missing' plot(x, y, blind = FALSE, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"x (DataDual) object want plot. y (missing) missing object, compatibility generic function. blind (flag) indicates whether blind data. TRUE, placebo subjects reported level active dose level corresponding cohort, DLTs always assigned first subjects cohort. ... passed first inherited method plot current method.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"ggplot2::ggplot2 object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DataDual-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Method for the DataDual Class — plot,DataDual,missing-method","text":"","code":"# Create some data of class 'DataDual'. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   w = rnorm(8),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Plot the data. plot(my_data)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"plot method can applied DualSimulations objects order summarize graphically. addition standard plot types, sigma2W Plot boxplot final biomarker variance estimates simulated trials rho Plot boxplot final correlation estimates simulated trials","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"","code":"# S4 method for class 'DualSimulations,missing' plot(x, y, type = c(\"trajectory\", \"dosesTried\", \"sigma2W\", \"rho\"), ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"x DualSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gtable object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot dual-endpoint simulations — plot,DualSimulations,missing-method","text":"","code":"# Define the dose-grid. emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Create some data. my_data <- DataDual(   x = c(     0.1,     0.5,     1.5,     3,     6,     10,     10,     10,     20,     20,     20,     40,     40,     40,     50,     50,     50   ),   y = c(     0,     0,     0,     0,     0,     0,     1,     0,     0,     1,     1,     0,     0,     1,     0,     1,     1   ),   ID = 1:17,   cohort = c(     1L,     2L,     3L,     4L,     5L,     6L,     6L,     6L,     7L,     7L,     7L,     8L,     8L,     8L,     9L,     9L,     9L   ),   w = c(     0.31,     0.42,     0.59,     0.45,     0.6,     0.7,     0.55,     0.6,     0.52,     0.54,     0.56,     0.43,     0.41,     0.39,     0.34,     0.38,     0.21   ),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ) )  # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) myStopping <- myStopping4 | StoppingMinPatients(40)  my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping my_stopping4 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) my_stopping <- my_stopping4 | StoppingMinPatients(40) | StoppingMissingDose()  # Choose the rule for dose increments my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design  my_design <- DualDesign(   model = my_model,   data = emptydata,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = CohortSizeConst(3),   startingDose = 3 )  # Define scenarios for the TRUE toxicity and efficacy profiles. beta_mod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) *     (delta2^delta2) /     ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }  true_biomarker <- function(dose) {   beta_mod(     dose,     e0 = 0.2,     eMax = 0.6,     delta1 = 5,     delta2 = 5 * 0.5 / 0.5,     scal = 100   ) }  true_tox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles par(mfrow = c(1, 2)) curve(true_tox(x), from = 0, to = 80) curve(true_biomarker(x), from = 0, to = 80)  # Run the simulation on the desired design. # We only generate 1 trial outcome here for illustration, for the actual study. # Also for illustration purpose, we will use 5 burn-ins to generate 20 samples, # this should be increased of course. my_sims <- simulate(   object = my_design,   trueTox = true_tox,   trueBiomarker = true_biomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 9,   startingDose = 6,   mcmcOptions = McmcOptions(     burnin = 1,     step = 1,     samples = 2   ) )  # Plot the results of the simulation. print(plot(my_sims)) #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. #> ℹ The deprecated feature was likely used in the crmPack package. #>   Please report the issue at <https://github.com/openpharma/crmPack/issues>. #> Warning: `qplot()` was deprecated in ggplot2 3.4.0. #> ℹ The deprecated feature was likely used in the crmPack package. #>   Please report the issue at <https://github.com/openpharma/crmPack/issues>."},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"plot method can applied DualSimulationsSummary objects order summarize graphically. Possible type plots moment listed plot,SimulationsSummary,missing-method plus: meanBiomarkerFit Plot showing average fitted dose-biomarker curve across trials, together 95% credible intervals, comparison assumed truth (specified trueBiomarker argument summary,DualSimulations-method) can specify subset type argument.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"","code":"# S4 method for class 'DualSimulationsSummary,missing' plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLTs\", \"nAboveTarget\", \"meanFit\",     \"meanBiomarkerFit\"),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"x DualSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gtable object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-DualSimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot summaries of the dual-endpoint design simulations — plot,DualSimulationsSummary,missing-method","text":"","code":"# Define the dose-grid. emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))   # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )   # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping4 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) # Only 10 patients here for illustration! my_stopping <- my_stopping4 | StoppingMinPatients(10) | StoppingMissingDose()  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. my_design <- DualDesign(   model = my_model,   data = emptydata,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = CohortSizeConst(3),   startingDose = 3 )  # Define scenarios for the TRUE toxicity and efficacy profiles. beta_mod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) *     (delta2^delta2) /     ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }   true_biomarker <- function(dose) {   beta_mod(     dose,     e0 = 0.2,     eMax = 0.6,     delta1 = 5,     delta2 = 5 * 0.5 / 0.5,     scal = 100   ) }  true_tox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles. par(mfrow = c(1, 2)) curve(true_tox(x), from = 0, to = 80) curve(true_biomarker(x), from = 0, to = 80)  # Run the simulation on the desired design. # We only generate 1 trial outcome here for illustration, for the actual study. # For illustration purpose we will use 5 burn-ins to generate 20 samples, # this should be increased of course. my_sims <- simulate(   object = my_design,   trueTox = true_tox,   trueBiomarker = true_biomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions = McmcOptions(     burnin = 5,     step = 1,     samples = 20   ) )  # Plot the summary of the Simulations. plot(summary(my_sims, trueTox = true_tox, trueBiomarker = true_biomarker))"},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot simulations — plot,GeneralSimulations,missing-method","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"Summarize simulations plots","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"","code":"# S4 method for class 'GeneralSimulations,missing' plot(x, y, type = c(\"trajectory\", \"dosesTried\"), ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"x GeneralSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gtable object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"plot method can applied GeneralSimulations objects order summarize graphically. Possible types plots moment : trajectory Summary trajectory simulated trials dosesTried Average proportions doses tested patients can specify one type argument.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot simulations — plot,GeneralSimulations,missing-method","text":"","code":"# nolint start  ## obtain the plot for the simulation results ## If only DLE responses are considered in the simulations  ## Specified your simulations when no DLE samples are used ## Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid = seq(25, 300, 25))  ## Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## Then the escalation rule tdNextBest <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  ## The cohort size, size of 3 subjects mySize <- CohortSizeConst(size = 3) ## Deifne the increments for the dose-escalation process ## The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ## The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ## This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements <- IncrementsRelative(   intervals = c(min(data@doseGrid), max(data@doseGrid)),   increments = c(2, 2) ) ## Specified the stopping rule e.g stop when the maximum sample size of 12 patients has been reached myStopping <- StoppingMinPatients(nPatients = 12) ## Now specified the design with all the above information and starting with a dose of 25 design <- TDDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data,   startingDose = 25 )  ## Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## Then specified the simulations and generate the trial ## For illustration purpose only 1 simulation is produced (nsim=1). ## The simulations mySim <- simulate(   design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   parallel = FALSE )   ## plot the simulations print(plot(mySim))    ## If DLE samples are involved ## The escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) ## specify the design design <- TDsamplesDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data,   startingDose = 25 ) ## options for MCMC ## The simulations ## For illustration purpose only 1 simulation is produced (nsim=1). # mySim <- simulate(design, #                   args=NULL, #                   truth=myTruth, #                   nsim=1, #                   seed=819, #                   mcmcOptions=options, #                   parallel=FALSE) # # ##plot the simulations # print(plot(mySim)) #  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"plot method can applied GeneralSimulationsSummary objects order summarize graphically. Possible types plots moment :","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"","code":"# S4 method for class 'GeneralSimulationsSummary,missing' plot(x, y, type = c(\"nObs\", \"doseSelected\", \"propDLTs\", \"nAboveTarget\"), ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"x GeneralSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gtable object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-GeneralSimulationsSummary-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Graphical display of the general simulation summary — plot,GeneralSimulationsSummary,missing-method","text":"nObs Distribution number patients simulated trials doseSelected Distribution final selected doses trials. Note can include zero entries, meaning trial stopped doses dose grid appeared toxic. propDLTs Distribution proportion patients DLTs trials nAboveTarget Distribution number patients treated doses target toxicity interval (specified truth target arguments summary,GeneralSimulations-method) can specify subset type argument.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This plot method can be applied to PseudoDualFlexiSimulations objects in order to summarize them graphically. Possible types of plots at the moment are:  trajectory Summary of the trajectory of the simulated trials dosesTried Average proportions of the doses tested in patients sigma2 The variance of the efficacy responses sigma2betaW The variance of the random walk model  You can specify one or both of these in the type argument. — plot,PseudoDualFlexiSimulations,missing-method","title":"This plot method can be applied to PseudoDualFlexiSimulations objects in order to summarize them graphically. Possible types of plots at the moment are:  trajectory Summary of the trajectory of the simulated trials dosesTried Average proportions of the doses tested in patients sigma2 The variance of the efficacy responses sigma2betaW The variance of the random walk model  You can specify one or both of these in the type argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"plot method can applied PseudoDualFlexiSimulations objects order summarize graphically. Possible types plots moment : trajectory Summary trajectory simulated trials dosesTried Average proportions doses tested patients sigma2 variance efficacy responses sigma2betaW variance random walk model can specify one type argument.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This plot method can be applied to PseudoDualFlexiSimulations objects in order to summarize them graphically. Possible types of plots at the moment are:  trajectory Summary of the trajectory of the simulated trials dosesTried Average proportions of the doses tested in patients sigma2 The variance of the efficacy responses sigma2betaW The variance of the random walk model  You can specify one or both of these in the type argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"","code":"# S4 method for class 'PseudoDualFlexiSimulations,missing' plot(x, y, type = c(\"trajectory\", \"dosesTried\", \"sigma2\", \"sigma2betaW\"), ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This plot method can be applied to PseudoDualFlexiSimulations objects in order to summarize them graphically. Possible types of plots at the moment are:  trajectory Summary of the trajectory of the simulated trials dosesTried Average proportions of the doses tested in patients sigma2 The variance of the efficacy responses sigma2betaW The variance of the random walk model  You can specify one or both of these in the type argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"x PseudoDualFlexiSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This plot method can be applied to PseudoDualFlexiSimulations objects in order to summarize them graphically. Possible types of plots at the moment are:  trajectory Summary of the trajectory of the simulated trials dosesTried Average proportions of the doses tested in patients sigma2 The variance of the efficacy responses sigma2betaW The variance of the random walk model  You can specify one or both of these in the type argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gtable object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualFlexiSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This plot method can be applied to PseudoDualFlexiSimulations objects in order to summarize them graphically. Possible types of plots at the moment are:  trajectory Summary of the trajectory of the simulated trials dosesTried Average proportions of the doses tested in patients sigma2 The variance of the efficacy responses sigma2betaW The variance of the random walk model  You can specify one or both of these in the type argument. — plot,PseudoDualFlexiSimulations,missing-method","text":"","code":"# Obtain the plot for the simulation results if DLE and efficacy responses # are considered in the simulations. emptydata <- DataDual(doseGrid = seq(25, 300, 25))  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model must be of 'EffFlexi' class. eff_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  # The escalation rule using the 'NextBestMaxGainSamples' class. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # The cohort size, size of 3 subjects. my_size <- CohortSizeConst(size = 3)  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Define the stopping rule. Stop when the maximum sample size of 36 patients has # been reached or when the next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments ) # Specify the true DLE curve and the true expected efficacy values # at all dose levels. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499)  my_truth_eff <- c(   -0.5478867,   0.1645417,   0.5248031,   0.7604467,   0.9333009,   1.0687031,   1.1793942,   1.2726408,   1.3529598,   1.4233411,   1.4858613,   1.5420182 )  # The true gain curve. my_truth_gain <- function(dose) {   return((myTruthEff(dose)) / (1 + (myTruthDLE(dose) / (1 - myTruthDLE(dose))))) }  # MCMC options. my_options <- McmcOptions(burnin = 10, step = 1, samples = 20)  # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   mcmcOptions = my_options,   nsim = 1,   seed = 819,   parallel = FALSE )  # Plot the simulated results. print(plot(my_sim))"},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot simulations — plot,PseudoDualSimulations,missing-method","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"Summarize simulations plots","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"","code":"# S4 method for class 'PseudoDualSimulations,missing' plot(x, y, type = c(\"trajectory\", \"dosesTried\", \"sigma2\"), ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"x PseudoDualSimulations object want plot y missing type type plots want obtain. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"single ggplot object single plot asked , otherwise gtable object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"plot method can applied PseudoDualSimulations objects order summarize graphically. Possible types plots moment : trajectory Summary trajectory simulated trials dosesTried Average proportions doses tested patients sigma2 variance efficacy responses can specify one type argument.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulations-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot simulations — plot,PseudoDualSimulations,missing-method","text":"","code":"# Obtain the plot for the simulation results if DLE and efficacy responses # are considered in the simulations.  # Example to run simulations when no samples are used. The data object # must be defined with doses >= 1: emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model must be of 'ModelEff' (e.g 'Effloglog') class. eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # The escalation rule using the 'NextBestMaxGain' class. my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Cohort size of 3. my_size <- CohortSizeConst(size = 3)  # Stop only when 36 subjects are treated or next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Now specify the design with all the above information and starting with a # dose of 25 (for details please refer to the 'DualResponsesDesign' example). my_design <- DualResponsesDesign(   nextBest = my_next_best,   model = dle_model,   eff_model = eff_model,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the true DLE and efficacy curves. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499) my_truth_eff <- efficacyFunction(   eff_model,   theta1 = -4.818429,   theta2 = 3.653058 )  # Run simulations (for illustration purpose only 1 simulation is produced). my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 1,   seed = 819,   parallel = FALSE )  # Plot the simulation results. print(plot(my_sim))  # Example if DLE and efficacy samples are involved. # The escalation rule using the 'NextBestMaxGainSamples' class. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # The design of 'DualResponsesSamplesDesign' class. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # Options for MCMC. my_options <- McmcOptions(burnin = 10, step = 1, samples = 20)  # For illustration purpose only 1 simulation is produced (nsim = 1). my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 1,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )  # Plot the simulation results. print(plot(my_sim))"},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"plot method can applied PseudoDualSimulationsSummary objects order summarize graphically. Possible type plots moment listed plot,PseudoSimulationsSummary,missing-method plus: can specify subset type argument.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"","code":"# S4 method for class 'PseudoDualSimulationsSummary,missing' plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLE\", \"nAboveTargetEndOfTrial\", \"meanFit\",     \"meanEffFit\"),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"x PseudoDualSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gtable object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoDualSimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the summary of Pseudo Dual Simulations summary — plot,PseudoDualSimulationsSummary,missing-method","text":"","code":"# Obtain the summary plot for the simulation results if DLE and efficacy # responses are considered in the simulations.  # In the example when no samples are used a data object with doses >= 1 # needs to be defined. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model of 'ModelEff' (e.g 'Effloglog') class. eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # The escalation rule using the 'NextBestMaxGain' class. my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Cohort size of 3. my_size <- CohortSizeConst(size = 3)  # Stop when 10 subjects are treated (for illustration only). my_stopping <- StoppingMinPatients(nPatients = 10)  ## Now specified the design with all the above information and starting with a dose of 25  # Specify the design. (For details please refer to the 'DualResponsesDesign' example.) my_design <- DualResponsesDesign(   nextBest = my_next_best,   model = dle_model,   eff_model = eff_model,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the true DLE and efficacy curves. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499) my_truth_eff <- efficacyFunction(eff_model, theta1 = -4.818429, theta2 = 3.653058)  # \\donttest{ # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 1,   mcmcOptions = McmcOptions(burnin = 10, step = 1, samples = 50),   seed = 819,   parallel = FALSE )  # Summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Plot the summary of the simulations. print(plot(my_sum)) # }  # Example where DLE and efficacy samples are involved. # Please refer to design-method 'simulate DualResponsesSamplesDesign' examples # for details. # Specify the next best method. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # Specify the design. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # MCMC options. my_options <- McmcOptions(burnin = 10, step = 2, samples = 50)  # \\donttest{ # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 1,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )   # Generate a summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Plot the summary of the simulations. print(plot(my_sum)) # }  # Example where the 'EffFlexi' class is used for the efficacy model. eff_model <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = emptydata )  # Specify the design. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # Specify the true DLE curve and the true expected efficacy values at all dose levels. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499)  my_truth_eff <- c(   -0.5478867, 0.1645417, 0.5248031, 0.7604467,   0.9333009, 1.0687031, 1.1793942, 1.2726408,   1.3529598, 1.4233411, 1.4858613, 1.5420182 )  # Define the true gain curve. my_truth_gain <- function(dose) {   return((my_truth_eff(dose)) / (1 + (my_truth_dle(dose) / (1 - my_truth_dle(dose))))) }  # \\donttest{ ## The simulations ## For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   nsim = 1,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )  # Produce a summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Plot the summary of the simulations. print(plot(my_sim))  # }"},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"Graphical display simulation summary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"","code":"# S4 method for class 'PseudoSimulationsSummary,missing' plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLE\", \"nAboveTargetEndOfTrial\", \"meanFit\"),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"x PseudoSimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gtable object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"plot method can applied PseudoSimulationsSummary objects order summarize graphically. can used DLE responses involved simulations. also applied results without samples generated simulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-PseudoSimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot summaries of the pseudo simulations — plot,PseudoSimulationsSummary,missing-method","text":"","code":"# nolint start  ## obtain the plot for the simulation results ## If only DLE responses are considered in the simulations ## Specified your simulations when no DLE samples are used ## Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid = seq(25, 300, 25))  ## Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## Then the escalation rule tdNextBest <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  ## The cohort size, size of 3 subjects mySize <- CohortSizeConst(size = 3) ## Deifne the increments for the dose-escalation process ## The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ## The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ## This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements <- IncrementsRelative(   intervals = c(min(data@doseGrid), max(data@doseGrid)),   increments = c(2, 2) ) ## Specified the stopping rule e.g stop when the maximum sample size of 12 patients has been reached myStopping <- StoppingMinPatients(nPatients = 12) ## Now specified the design with all the above information and starting with a dose of 25 design <- TDDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data,   startingDose = 25 )  ## Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## Then specified the simulations and generate the trial ## For illustration purpose only 1 simulation is produced (nsim=1). ## The simulations mySim <- simulate(   design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   parallel = FALSE )  ## Then produce a summary of your simulations MYSUM <- summary(mySim, truth = myTruth) ## plot the summary of the simulations print(plot(MYSUM))   ## If DLE samples are involved ## The escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } ) ## specify the design design <- TDsamplesDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data,   startingDose = 25 ) ## options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 200) ## The simulations ## For illustration purpose only 1 simulation is produced (nsim=1). # mySim <- simulate(design, #                   args=NULL, #                   truth=myTruth, #                   nsim=1, #                   seed=819, #                   mcmcOptions=options, #                   parallel=FALSE) # ##Then produce a summary of your simulations # MYSUM <- summary(mySim, #                  truth=myTruth) # ##plot the summary of the simulations # print(plot(MYSUM))  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-DALogisticLogNormal-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"Plotting dose-toxicity model fits","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-DALogisticLogNormal-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"","code":"# S4 method for class 'Samples,DALogisticLogNormal' plot(x, y, data, hazard = FALSE, ..., showLegend = TRUE)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-DALogisticLogNormal-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"x Samples object y DALogisticLogNormal object data DataDA object hazard see fitPEM explanation ... used showLegend legend shown? (default)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-DALogisticLogNormal-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting dose-toxicity model fits — plot,Samples,DALogisticLogNormal-method","text":"returns ggplot object dose-toxicity model fit","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"dual endpoint model, also dose-biomarker fit shown plot","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"","code":"# S4 method for class 'Samples,DualEndpoint' plot(x, y, data, extrapolate = TRUE, showLegend = FALSE, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"x Samples object y DualEndpoint object data DataDual object extrapolate biomarker fit extrapolated whole dose grid? (default) showLegend legend shown? (default) ... additional arguments parent method plot,Samples,GeneralModel-method","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"returns ggplot object dose-toxicity dose-biomarker model fits","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-DualEndpoint-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting dose-toxicity and dose-biomarker model fits — plot,Samples,DualEndpoint-method","text":"","code":"# nolint start  # Create some data data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 50, 50, 50),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1),   w = c(     0.31,     0.42,     0.59,     0.45,     0.6,     0.7,     0.55,     0.6,     0.52,     0.54,     0.56,     0.43,     0.41,     0.39,     0.34,     0.38,     0.21   ),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the Dual-Endpoint model (in this case RW1) model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 500) set.seed(94) samples <- mcmc(data, model, options)  # Plot the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses and the Biomarker by doses #grid.arrange(plot(x = samples, y = model, data = data))  plot(x = samples, y = model, data = data)   # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"Plotting dose-toxicity model fits","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"","code":"# S4 method for class 'Samples,GeneralModel' plot(   x,   y,   data,   ...,   xlab = \"Dose level\",   ylab = \"Probability of DLT [%]\",   showLegend = TRUE )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"x Samples object y GeneralModel object data Data object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"returns ggplot object dose-toxicity model fit","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-GeneralModel-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting dose-toxicity model fits — plot,Samples,GeneralModel-method","text":"","code":"# nolint start  # Create some data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize a model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get posterior for all model parameters options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Plot the posterior mean  (and empirical 2.5 and 97.5 percentile) # for the prob(DLT) by doses plot(x = samples, y = model, data = data)   # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the fitted dose-efficacy curve using a model from ModelEff class with samples — plot,Samples,ModelEff-method","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class with samples — plot,Samples,ModelEff-method","text":"Plot fitted dose-efficacy curve using model ModelEff class samples","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class with samples — plot,Samples,ModelEff-method","text":"","code":"# S4 method for class 'Samples,ModelEff' plot(   x,   y,   data,   ...,   xlab = \"Dose level\",   ylab = \"Expected Efficacy\",   showLegend = TRUE )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class with samples — plot,Samples,ModelEff-method","text":"x Samples object y ModelEff model class object data Data object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class with samples — plot,Samples,ModelEff-method","text":"returns ggplot object dose-efficacy model fit","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelEff-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the fitted dose-efficacy curve using a model from ModelEff class with samples — plot,Samples,ModelEff-method","text":"","code":"# nolint start  ## we need a data object with doses >= 1: data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-efficacy curve with samples using the model from 'ModelEff' ##class e.g. 'Effloglog' class model ##define the model (see Effloglog example) Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data ) ## define the samples obtained using the 'Effloglog' model (see details in 'Samples' example) ##options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 200) ## samples must be of 'Samples' class samples <- mcmc(data = data, model = Effmodel, options = options) ## plot the fitted dose-efficacy curve including the 95% credibility interval of the samples ## 'x' should be of 'Samples' class and 'y' of 'ModelEff' class plot(x = samples, y = Effmodel, data = data)  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"Plot fitted dose-DLE curve using ModelTox class model samples","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"","code":"# S4 method for class 'Samples,ModelTox' plot(   x,   y,   data,   ...,   xlab = \"Dose level\",   ylab = \"Probability of DLT [%]\",   showLegend = TRUE )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"x Samples object y ModelTox model class object data Data object ... used xlab x axis label ylab y axis label showLegend legend shown? (default)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"returns ggplot object dose-DLE model fit","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-Samples-ModelTox-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the fitted dose-DLE curve using a ModelTox class model with samples — plot,Samples,ModelTox-method","text":"","code":"## we need a data object with doses >= 1: data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices! ## plot the dose-DLE curve with samples using the model from 'ModelTox' ## class e.g. 'LogisticIndepBeta' class model ## define the model (see LogisticIndepBeta example) model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## define the samples obtained using the 'LogisticIndepGBeta' model  ## Define options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 200) ## (see details in 'Samples' example) samples must be of 'Samples' class samples <- mcmc(data = data, model = model, options = options) ## plot the fitted dose-DLE curve including the 95% credibility interval of the samples ## 'x' should be of 'Samples' class and 'y' of 'ModelTox' class plot(x = samples, y = model, data = data)"},{"path":"https://openpharma.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"Graphical display simulation summary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"","code":"# S4 method for class 'SimulationsSummary,missing' plot(   x,   y,   type = c(\"nObs\", \"doseSelected\", \"propDLTs\", \"nAboveTarget\", \"meanFit\"),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"x SimulationsSummary object want plot y missing type types plots want obtain. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"single ggplot object single plot asked , otherwise gtable object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"plot method can applied SimulationsSummary objects order summarize graphically. Possible type plots moment listed plot,GeneralSimulationsSummary,missing-method plus: meanFit Plot showing average fitted dose-toxicity curve across trials, together 95% credible intervals, comparison assumed truth (specified truth argument summary,Simulations-method) can specify subset type argument.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot-SimulationsSummary-missing-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot summaries of the model-based design simulations — plot,SimulationsSummary,missing-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcomes here for illustration, for the actual study # this should be increased of course options <- McmcOptions(   burnin = 10,   step = 1,   samples = 100 ) time <- system.time(   mySims <- simulate(     design,     args = NULL,     truth = myTruth,     nsim = 1,     seed = 819,     mcmcOptions = options,     parallel = FALSE   ) )[3]  # Plot the Summary of the Simulations plot(summary(mySims, truth = myTruth))   # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/plot.gtable.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot gtable Objects — plot.gtable","title":"Plot gtable Objects — plot.gtable","text":"needed crmPack uses gridExtra::arrangeGrob() combine ggplot2 plots, resulting gtable object plotted otherwise implicitly printing console, e.g.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plot.gtable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot gtable Objects — plot.gtable","text":"","code":"# S3 method for class 'gtable' plot(x, ...)  # S3 method for class 'gtable' print(x, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plot.gtable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot gtable Objects — plot.gtable","text":"x (gtable) object plot. ... additional parameters grid::grid.draw().","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plotDualResponses.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model, a DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model, a DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"Plot DLE efficacy curve side side given DLE pseudo model, DLE sample, efficacy pseudo model given efficacy sample Plot dose-DLE dose-efficacy curve side side given DLE pseudo model given pseudo efficacy model without DLE efficacy samples","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plotDualResponses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model, a DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"","code":"plotDualResponses(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for class 'ModelTox,Samples,ModelEff,Samples' plotDualResponses(   DLEmodel,   DLEsamples,   Effmodel,   Effsamples,   data,   extrapolate = TRUE,   showLegend = FALSE,   ... )  # S4 method for class 'ModelTox,missing,ModelEff,missing' plotDualResponses(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plotDualResponses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model, a DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"DLEmodel pseudo DLE model ModelTox class object DLEsamples DLE samples Samples class object Effmodel pseudo efficacy model ModelEff class object Effsamples Efficacy samples Samples class object data data input DataDual class object ... additional arguments parent method plot,Samples,GeneralModel-method extrapolate biomarker fit extrapolated whole dose grid? (default) showLegend legend shown? (default)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plotDualResponses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model, a DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"returns ggplot object dose-toxicity dose-efficacy model fits","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plotDualResponses.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model, a DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"plotDualResponses(   DLEmodel = ModelTox,   DLEsamples = Samples,   Effmodel = ModelEff,   Effsamples = Samples ): function still documented plotDualResponses(   DLEmodel = ModelTox,   DLEsamples = missing,   Effmodel = ModelEff,   Effsamples = missing ): Plot DLE efficacy curve side side given DLE model efficacy model without samples","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plotDualResponses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of the DLE and efficacy curve side by side given a DLE pseudo model, a DLE sample, an efficacy pseudo model and a given efficacy sample — plotDualResponses","text":"","code":"# nolint start  ## we need a data object with doses >= 1: data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE and dose-efficacy curves in two plots with DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data ) ##define the DLE sample of 'Samples' class ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x = data@x, y = data@y, doseGrid = data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices! ##Specify the options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 1000)   DLEsamples <- mcmc(data = data1, model = DLEmodel, options = options) ##define the efficacy sample of 'Samples' class Effsamples <- mcmc(data = data, model = Effmodel, options = options) ##plot the dose-DLE and dose-efficacy curves with two plot side by side. ##For each curve the 95% credibility interval of the two samples are alos given plotDualResponses(   DLEmodel = DLEmodel,   DLEsamples = DLEsamples,   Effmodel = Effmodel,   Effsamples = Effsamples,   data = data )  # nolint end # nolint start  ## we need a data object with doses >= 1: data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE and dose-efficacy curves in two plots without DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data ) ##plot the dose-DLE and dose-efficacy curves with two plot side by side. plotDualResponses(DLEmodel = DLEmodel, Effmodel = Effmodel, data = data) #> Warning: Arguments in `...` must be used. #> ✖ Problematic argument: #> • group = group #> ℹ Did you misspell an argument name? #> Warning: Arguments in `...` must be used. #> ✖ Problematic argument: #> • group = group #> ℹ Did you misspell an argument name?   # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/plotGain.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model, a DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model, a DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"Plot gain curve addition dose-DLE dose-efficacy curve using given DLE pseudo model, DLE sample, given efficacy pseudo model efficacy sample Plot gain curve addition dose-DLE dose-efficacy curve using given DLE pseudo model, given efficacy pseudo model","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plotGain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model, a DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"","code":"plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for class 'ModelTox,Samples,ModelEff,Samples' plotGain(DLEmodel, DLEsamples, Effmodel, Effsamples, data, ...)  # S4 method for class 'ModelTox,missing,ModelEff,missing' plotGain(DLEmodel, Effmodel, data, size = c(8L, 8L), shape = c(16L, 17L), ...)"},{"path":"https://openpharma.github.io/crmPack/reference/plotGain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model, a DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"DLEmodel dose-DLE model ModelTox class object DLEsamples DLE sample Samples class object Effmodel dose-efficacy model ModelEff class object Effsamples efficacy sample Samples class object data data input DataDual class object ... used size (integer) vector length two defining sizes shapes used identify doses , respectively, p(DLE = 0.3) maximum gain shape (integer) vector length two defining shapes used identify doses , respectively, p(DLE = 0.3) maximum gain","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plotGain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model, a DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"returns ggplot object plot","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plotGain.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model, a DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"plotGain(   DLEmodel = ModelTox,   DLEsamples = Samples,   Effmodel = ModelEff,   Effsamples = Samples ): Standard method plotGain(   DLEmodel = ModelTox,   DLEsamples = missing,   Effmodel = ModelEff,   Effsamples = missing ): Standard method","code":""},{"path":"https://openpharma.github.io/crmPack/reference/plotGain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the gain curve in addition with the dose-DLE and dose-efficacy curve using a given DLE pseudo model, a DLE sample, a given efficacy pseudo model and an efficacy sample — plotGain","text":"","code":"# nolint start  ## we need a data object with doses >= 1: data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE , dose-efficacy and gain curve in the same plot with DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data,   const = 0 ) ##define the DLE sample of 'Samples' class ##set up the same data set in class 'Data' for MCMC sampling for DLE data1 <- Data(x = data@x, y = data@y, doseGrid = data@doseGrid) #> Used default patient IDs! #> Used best guess cohort indices!  ##Define the options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 1000)   DLEsamples <- mcmc(data = data1, model = DLEmodel, options = options) ##define the efficacy sample of 'Samples' class Effsamples <- mcmc(data = data, model = Effmodel, options = options) ##plot the three curves of mean values of the DLEsamples, Effsamples and ##gain value samples (obtained within this plotGain function) at all dose levels plotGain(   DLEmodel = DLEmodel,   DLEsamples = DLEsamples,   Effmodel = Effmodel,   Effsamples = Effsamples,   data = data )  # nolint end # nolint start ## we need a data object with doses >= 1: data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices! ##plot the dose-DLE , dose-efficacy and gain curve in the same plot with DLE and efficacy samples ##define the DLE model which must be of 'ModelTox' class ##(e.g 'LogisticIndepBeta' class model) DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## define the efficacy model which must be of 'ModelEff' class ## (e.g 'Effloglog' class) Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data ) ##plot the three curves of using modal estimates of model parameters at all dose levels plotGain(DLEmodel = DLEmodel, Effmodel = Effmodel, data = data)  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/positive_number.html","id":null,"dir":"Reference","previous_headings":"","what":"positive_number — positive_number","title":"positive_number — positive_number","text":"positive_number class class store NULL, non NA, finite strictly positive numerical value. mainly used store reference dose value model classes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/printVignette.html","id":null,"dir":"Reference","previous_headings":"","what":"Taken from utils package (print.vignette) — printVignette","title":"Taken from utils package (print.vignette) — printVignette","text":"Taken utils package (print.vignette)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/printVignette.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Taken from utils package (print.vignette) — printVignette","text":"","code":"printVignette(x, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"function computes probability occurrence DLE specified dose level, based model parameters (samples).","code":""},{"path":"https://openpharma.github.io/crmPack/reference/prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"","code":"prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticNormal,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticLogNormal,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticLogNormalSub,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,ProbitLogNormal,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,ProbitLogNormalRel,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticLogNormalGrouped,Samples' prob(dose, model, samples, group, ...)  # S4 method for class 'numeric,LogisticKadane,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticKadaneBetaGamma,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticNormalMixture,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticNormalFixedMixture,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticLogNormalMixture,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,DualEndpoint,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticIndepBeta,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticIndepBeta,missing' prob(dose, model, samples, ...)  # S4 method for class 'numeric,OneParLogNormalPrior,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,OneParExpPrior,Samples' prob(dose, model, samples, ...)  # S4 method for class 'numeric,LogisticLogNormalOrdinal,Samples' prob(dose, model, samples, grade, cumulative = TRUE, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"dose (number numeric) dose targeted. following recycling rule applies samples missing: vectors size 1 recycled size sample (.e. size(samples)). Otherwise, dose must size sample. model (GeneralModel ModelTox) model single agent dose escalation pseudo DLE (dose-limiting events)/toxicity model. samples (Samples) samples model's parameters used compute toxicity probabilities. Can also missing models. ... model specific parameters samples used. group (character factor) LogisticLogNormalGrouped, indicating whether calculate probability mono combo arm. grade (integer integer_vector) toxicity grade probabilities required cumulative (flag) returned probability cumulative (default) grade-specific?","code":""},{"path":"https://openpharma.github.io/crmPack/reference/prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"proportion numeric vector toxicity probabilities. non-scalar samples used, every element returned vector corresponds one element sample. Hence, case, output vector length sample vector. scalar samples used samples used, e.g. pseudo DLE/toxicity model, output length length dose.  case LogisticLogNormalOrdinal, probabilities relate toxicities  grade given grade.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/prob.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"prob() function computes probability toxicity given doses, using samples model parameter(s). work multivariate model parameters, assume model specific prob() method receives samples matrix rows correspond sampling index, .e. layout nSamples x dimParameter.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/prob.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"prob(dose = numeric, model = LogisticNormal, samples = Samples): prob(dose = numeric, model = LogisticLogNormal, samples = Samples): prob(dose = numeric, model = LogisticLogNormalSub, samples = Samples): prob(dose = numeric, model = ProbitLogNormal, samples = Samples): prob(dose = numeric, model = ProbitLogNormalRel, samples = Samples): prob(dose = numeric, model = LogisticLogNormalGrouped, samples = Samples): method LogisticLogNormalGrouped needs group argument addition. prob(dose = numeric, model = LogisticKadane, samples = Samples): prob(dose = numeric, model = LogisticKadaneBetaGamma, samples = Samples): prob(dose = numeric, model = LogisticNormalMixture, samples = Samples): prob(dose = numeric, model = LogisticNormalFixedMixture, samples = Samples): prob(dose = numeric, model = LogisticLogNormalMixture, samples = Samples): prob(dose = numeric, model = DualEndpoint, samples = Samples): prob(dose = numeric, model = LogisticIndepBeta, samples = Samples): compute toxicity probabilities occurrence DLE specified dose level, based samples LogisticIndepBeta model parameters. prob(dose = numeric, model = LogisticIndepBeta, samples = missing): compute toxicity probabilities occurrence DLE specified dose level, based LogisticIndepBeta model parameters. model parameters (except dose) present model object. prob(dose = numeric, model = OneParLogNormalPrior, samples = Samples): prob(dose = numeric, model = OneParExpPrior, samples = Samples): prob(dose = numeric, model = LogisticLogNormalOrdinal, samples = Samples):","code":""},{"path":"https://openpharma.github.io/crmPack/reference/prob.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"prob() dose() functions inverse , dose() methods first argument, .e. given independent variable dose depends , represents toxicity probability.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing Toxicity Probabilities for a Given Dose, Model and Samples — prob","text":"","code":"# Create some data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize a model, e.g. 'LogisticLogNormal'. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Get samples from posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 20) my_samples <- mcmc(data = my_data, model = my_model, options = my_options)  # Posterior for Prob(DLT | dose = 50). prob(dose = 50, model = my_model, samples = my_samples) #>  [1] 0.6511227 0.4314904 0.6270853 0.6270853 0.6552626 0.5131389 0.3964611 #>  [8] 0.5774948 0.5774948 0.5774948 0.5774948 0.5591314 0.5591314 0.4289819 #> [15] 0.4289819 0.4624784 0.3908832 0.2534483 0.5203804 0.5203804  # Create data from the 'DataDual' class. data_dual <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize a toxicity model using 'LogisticIndepBeta' model. dlt_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data_dual )  # Get samples from posterior. dlt_sample <- mcmc(data = data_dual, model = dlt_model, options = my_options)  # Posterior for Prob(DLT | dose = 100). prob(dose = 100, model = dlt_model, samples = dlt_sample) #>  [1] 0.1723670 0.1723670 0.4748224 0.4748224 0.4748224 0.2628373 0.2628373 #>  [8] 0.4670407 0.4670407 0.4670407 0.4670407 0.4670407 0.4670407 0.4670407 #> [15] 0.4670407 0.4670407 0.4670407 0.4670407 0.4670407 0.4670407 prob(dose = c(50, 150), model = dlt_model) #> [1] 0.1981823 0.4601234"},{"path":"https://openpharma.github.io/crmPack/reference/probFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting the Prob Function for a Given Model Type — probFunction","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"function returns prob() function computes toxicity probabilities given dose level, based model specific parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/probFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"","code":"probFunction(model, ...)  # S4 method for class 'GeneralModel' probFunction(model, ...)  # S4 method for class 'ModelTox' probFunction(model, ...)  # S4 method for class 'LogisticLogNormalOrdinal' probFunction(model, grade, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/probFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"model (GeneralModel ModelTox) model. ... model specific parameters. grade (integer) toxicity grade dose function required","code":""},{"path":"https://openpharma.github.io/crmPack/reference/probFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"prob() function computes toxicity probabilities.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/probFunction.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"probFunction(GeneralModel): probFunction(ModelTox): probFunction(LogisticLogNormalOrdinal):","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/reference/probFunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Getting the Prob Function for a Given Model Type — probFunction","text":"","code":"my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  prob_fun <- probFunction(my_model, alpha0 = 2, alpha1 = 3) prob_fun(30) #> [1] 0.6147973 ordinal_data <- .DefaultDataOrdinal() ordinal_model <- .DefaultLogisticLogNormalOrdinal() opts <- .DefaultMcmcOptions() samples <- mcmc(ordinal_data, ordinal_model, opts) #> Warning: Unused variable \"y\" in data  probFunction(   ordinal_model,   grade = 2L,   alpha2 = samples@data$alpha1,   beta = samples@data$beta )(50) #>    [1] 0.27058373 0.32434817 0.31497672 0.21802347 0.40159105 0.16025185 #>    [7] 0.27055099 0.08091834 0.16155832 0.25529619 0.20680673 0.34124571 #>   [13] 0.35813657 0.18293253 0.26987705 0.26042513 0.03800969 0.20978124 #>   [19] 0.29032217 0.46494578 0.20428265 0.21491625 0.36834895 0.10922410 #>   [25] 0.16948701 0.29483955 0.04192513 0.32172561 0.53343050 0.15754177 #>   [31] 0.27447698 0.30486477 0.22736051 0.29622780 0.23280782 0.09801033 #>   [37] 0.26969919 0.32090052 0.45983265 0.33445975 0.05000601 0.07517190 #>   [43] 0.14885637 0.11898709 0.05257355 0.15765024 0.17966599 0.09475537 #>   [49] 0.29983403 0.32630448 0.24537809 0.31550804 0.11714387 0.06297396 #>   [55] 0.18225977 0.12542917 0.13140370 0.12367058 0.12477664 0.14523920 #>   [61] 0.11409207 0.50568276 0.17006817 0.29610497 0.25532871 0.13765976 #>   [67] 0.29619458 0.05979511 0.06873651 0.05376868 0.07046679 0.03563524 #>   [73] 0.35587225 0.12686781 0.14562645 0.07574515 0.10993842 0.04533543 #>   [79] 0.05937641 0.10029461 0.05683216 0.07306804 0.15269784 0.11410236 #>   [85] 0.61739446 0.14587931 0.56199604 0.66164029 0.26309678 0.20321087 #>   [91] 0.15268826 0.26557384 0.34202854 0.29002949 0.39707832 0.16784968 #>   [97] 0.44068692 0.25028776 0.19386187 0.04724961 0.11892944 0.48501326 #>  [103] 0.18540695 0.30172456 0.14933913 0.08161831 0.21892779 0.10569296 #>  [109] 0.20266317 0.20637899 0.15003265 0.10704292 0.39818096 0.11555481 #>  [115] 0.13205765 0.12190652 0.46170501 0.08235521 0.33379759 0.09420564 #>  [121] 0.21388499 0.53422604 0.25924662 0.33970563 0.09215292 0.16774775 #>  [127] 0.31901627 0.33480819 0.39426950 0.20970650 0.37197915 0.14665310 #>  [133] 0.06863423 0.16445756 0.15048902 0.25986345 0.28234140 0.11773652 #>  [139] 0.25509801 0.35833119 0.23525652 0.33401486 0.18999233 0.31977625 #>  [145] 0.27460617 0.33712089 0.20682807 0.36989209 0.10580327 0.49507400 #>  [151] 0.18947312 0.29947290 0.23377092 0.46635494 0.33243572 0.18268995 #>  [157] 0.23565100 0.28800694 0.01924515 0.02034244 0.24143140 0.44454542 #>  [163] 0.45845804 0.22604854 0.21585846 0.29912724 0.24936570 0.11805065 #>  [169] 0.18832172 0.18080895 0.39710528 0.11319092 0.28302720 0.24023173 #>  [175] 0.20406992 0.73693723 0.28863980 0.39259027 0.56270992 0.49041633 #>  [181] 0.20692462 0.19030354 0.24969540 0.23544787 0.25395346 0.21137651 #>  [187] 0.19983150 0.11803682 0.16588299 0.17981406 0.30929896 0.51355496 #>  [193] 0.57251916 0.37390322 0.10614649 0.56294327 0.16860770 0.38114674 #>  [199] 0.44043697 0.20416825 0.29777502 0.20834724 0.21472172 0.31198202 #>  [205] 0.22868210 0.15926850 0.10599416 0.05996524 0.09046143 0.31274766 #>  [211] 0.22204957 0.35745138 0.41602868 0.42648284 0.43135065 0.13076243 #>  [217] 0.19609202 0.26817428 0.28958551 0.16726822 0.47769007 0.51403905 #>  [223] 0.28095209 0.44722644 0.29985950 0.31365329 0.21342340 0.05402982 #>  [229] 0.05270360 0.15145166 0.40707025 0.31201287 0.28194576 0.60265300 #>  [235] 0.33450150 0.35578942 0.50273707 0.24009034 0.21537449 0.22926052 #>  [241] 0.24818941 0.08262851 0.05754694 0.11705926 0.36340875 0.36430184 #>  [247] 0.18371832 0.09950320 0.04156613 0.13224740 0.30307389 0.13542526 #>  [253] 0.06594348 0.40224008 0.19548139 0.14622437 0.37314274 0.38552891 #>  [259] 0.15241477 0.14970622 0.31269019 0.53562999 0.27304142 0.35144936 #>  [265] 0.30419847 0.31486414 0.31235115 0.23379812 0.23572320 0.11486997 #>  [271] 0.12127257 0.13375616 0.23000832 0.54651592 0.09650982 0.36877867 #>  [277] 0.29561124 0.81955827 0.45642677 0.22237065 0.25743264 0.22362949 #>  [283] 0.26169938 0.07439305 0.15016304 0.04404441 0.18455655 0.06381937 #>  [289] 0.10647281 0.21923725 0.24993594 0.16043617 0.30508814 0.27464049 #>  [295] 0.15546372 0.33538746 0.36306926 0.21178638 0.03903080 0.11983217 #>  [301] 0.11795582 0.04555975 0.04579457 0.09285283 0.19409325 0.18883132 #>  [307] 0.05801827 0.04939549 0.30401796 0.25650123 0.19628854 0.25388476 #>  [313] 0.07585223 0.06931791 0.08953972 0.19261911 0.03895694 0.18058162 #>  [319] 0.22912194 0.15368463 0.25077937 0.17174461 0.28336228 0.34974452 #>  [325] 0.66349767 0.50045504 0.36604538 0.17631583 0.03970659 0.24225599 #>  [331] 0.06481490 0.45114046 0.27342812 0.30690899 0.16436599 0.18743229 #>  [337] 0.35289126 0.60213278 0.38822003 0.10863985 0.33182066 0.08972558 #>  [343] 0.55221076 0.17995793 0.11810615 0.10446270 0.24211149 0.21517250 #>  [349] 0.42116848 0.33006808 0.36675890 0.22569622 0.47909495 0.50785691 #>  [355] 0.44315755 0.20852439 0.22921805 0.37871215 0.11561482 0.48487622 #>  [361] 0.10257650 0.30385848 0.38511929 0.18810920 0.23940881 0.56523909 #>  [367] 0.48771792 0.23234279 0.20526945 0.28564562 0.30036811 0.11838371 #>  [373] 0.26152937 0.39497232 0.20507449 0.06360229 0.25152247 0.23274451 #>  [379] 0.25604919 0.43866115 0.22058768 0.21833796 0.33491729 0.39891683 #>  [385] 0.27535872 0.06607533 0.33365202 0.25622463 0.17352757 0.10289804 #>  [391] 0.29051313 0.22217296 0.07921963 0.23417221 0.25979997 0.13083793 #>  [397] 0.16811805 0.08090381 0.33136423 0.14153091 0.12971131 0.07572888 #>  [403] 0.10106794 0.29947215 0.32372839 0.21883134 0.39663321 0.19490005 #>  [409] 0.15349172 0.09182805 0.13603627 0.32262827 0.31506559 0.20414084 #>  [415] 0.15674738 0.18535676 0.22032833 0.17491822 0.14222183 0.13973121 #>  [421] 0.47430671 0.07429000 0.07775370 0.33761110 0.23625948 0.12063132 #>  [427] 0.35401711 0.20268737 0.22772332 0.34810179 0.16179920 0.44882407 #>  [433] 0.07441506 0.16790869 0.23793786 0.10501854 0.08753597 0.45430016 #>  [439] 0.03024640 0.03392741 0.20711970 0.37899513 0.29984648 0.25026580 #>  [445] 0.04377526 0.06188089 0.07173586 0.29013991 0.49271855 0.43379937 #>  [451] 0.17561324 0.30261706 0.26128707 0.21019783 0.18961987 0.16823045 #>  [457] 0.07556193 0.05717472 0.01675072 0.26707170 0.59939202 0.24624779 #>  [463] 0.20436944 0.38761852 0.25720480 0.13081565 0.08708731 0.33129922 #>  [469] 0.23440716 0.29223821 0.10717593 0.22634609 0.05526729 0.46726043 #>  [475] 0.16056705 0.05745509 0.02025811 0.12307295 0.19268489 0.27338298 #>  [481] 0.36799257 0.30970263 0.08753543 0.12407355 0.09193999 0.17188442 #>  [487] 0.23034151 0.30172040 0.28298806 0.34667485 0.56887346 0.30687087 #>  [493] 0.07848372 0.08699910 0.33964902 0.02138935 0.24160193 0.48910508 #>  [499] 0.06270274 0.08775991 0.27813122 0.43668276 0.18805977 0.10223202 #>  [505] 0.24838547 0.18995736 0.26586561 0.19101040 0.38902429 0.22002420 #>  [511] 0.05792986 0.08594695 0.53659251 0.32174499 0.43352063 0.07861060 #>  [517] 0.20900167 0.09969755 0.34442574 0.26479929 0.13240906 0.27630083 #>  [523] 0.15171813 0.09358086 0.61204868 0.58853591 0.17044415 0.12968431 #>  [529] 0.11041625 0.45778747 0.22327954 0.30184316 0.05311246 0.24145832 #>  [535] 0.05274243 0.53946493 0.48866053 0.10963960 0.26740993 0.37395715 #>  [541] 0.36495081 0.44048553 0.33299795 0.37131501 0.37426897 0.20041774 #>  [547] 0.26962527 0.21996230 0.18969660 0.28398303 0.09300730 0.09429456 #>  [553] 0.18317927 0.45422123 0.13807682 0.09490598 0.26576300 0.31113619 #>  [559] 0.06671233 0.11353036 0.49830157 0.18426042 0.08004362 0.07717360 #>  [565] 0.16648534 0.23424880 0.36100254 0.31841422 0.27906307 0.45777587 #>  [571] 0.08865479 0.20608364 0.11895236 0.29362982 0.19798106 0.40914112 #>  [577] 0.23691579 0.27140544 0.28666174 0.09839876 0.25989111 0.06274051 #>  [583] 0.10428838 0.15726863 0.15269218 0.41446190 0.11298405 0.05234333 #>  [589] 0.09692101 0.30979761 0.26610749 0.29293562 0.27657302 0.17666791 #>  [595] 0.28648427 0.21657924 0.31644674 0.19870375 0.27870741 0.40292009 #>  [601] 0.18769208 0.37155687 0.49908892 0.18664455 0.22481312 0.26097444 #>  [607] 0.11367082 0.14155803 0.27186191 0.56489604 0.18180702 0.27647012 #>  [613] 0.36198204 0.52491643 0.34637583 0.03347759 0.05553944 0.02953565 #>  [619] 0.04336552 0.07396350 0.15338125 0.34106209 0.23505544 0.15717903 #>  [625] 0.13370817 0.18851070 0.30435252 0.30728704 0.08127769 0.12020263 #>  [631] 0.43670777 0.28879654 0.46121784 0.40966914 0.12183694 0.30512313 #>  [637] 0.07119134 0.31294968 0.24432795 0.10375583 0.36330915 0.19027100 #>  [643] 0.28294055 0.19438952 0.39532613 0.34168252 0.12011997 0.05867600 #>  [649] 0.20437097 0.25532640 0.07204896 0.06455587 0.44186523 0.19518813 #>  [655] 0.13231464 0.27527404 0.21294044 0.28632307 0.08734586 0.57874235 #>  [661] 0.55820457 0.08487644 0.19690880 0.18220195 0.14179570 0.37263587 #>  [667] 0.23360304 0.13701718 0.34577212 0.37125923 0.17747734 0.43435286 #>  [673] 0.10097132 0.17507362 0.19687681 0.35732510 0.37090665 0.19130658 #>  [679] 0.13172840 0.16887611 0.24504036 0.33133655 0.36469953 0.21377992 #>  [685] 0.27128568 0.06822273 0.10388874 0.12283298 0.43741801 0.31852100 #>  [691] 0.22481080 0.24025888 0.12006255 0.06098473 0.15705136 0.25876418 #>  [697] 0.08486514 0.29342653 0.42453518 0.30515900 0.30691107 0.31768730 #>  [703] 0.06232570 0.22259563 0.26942464 0.12144303 0.13723054 0.34805457 #>  [709] 0.40351965 0.09405889 0.18640516 0.16550318 0.12941643 0.17081933 #>  [715] 0.21716134 0.31355314 0.25819344 0.05647431 0.15742454 0.10167270 #>  [721] 0.44358058 0.09605734 0.19507795 0.22099151 0.39744923 0.09961922 #>  [727] 0.21037641 0.24847538 0.19284217 0.11417786 0.05900216 0.08229874 #>  [733] 0.04626959 0.08993225 0.10849852 0.02889433 0.22286900 0.14642547 #>  [739] 0.52186003 0.34457731 0.26226799 0.29836651 0.45000988 0.10733675 #>  [745] 0.09611886 0.22424825 0.12363118 0.49776900 0.13212010 0.12671692 #>  [751] 0.03243758 0.08329472 0.44860288 0.09698337 0.01950023 0.37406331 #>  [757] 0.14864049 0.38032760 0.53789063 0.22041809 0.10177655 0.21963677 #>  [763] 0.11268974 0.15279272 0.44098899 0.21228788 0.13883821 0.24294925 #>  [769] 0.26731290 0.16830298 0.07345218 0.51557144 0.07803338 0.09656264 #>  [775] 0.10040908 0.03715565 0.13546183 0.18465177 0.19263149 0.32485968 #>  [781] 0.20807117 0.07544393 0.06791571 0.20913231 0.32952555 0.56728790 #>  [787] 0.27525942 0.22071549 0.29883564 0.30487994 0.18795730 0.36311515 #>  [793] 0.29300226 0.07160273 0.12867505 0.15130865 0.28914020 0.49776032 #>  [799] 0.23137191 0.31455617 0.24546170 0.22223180 0.28644755 0.35512891 #>  [805] 0.24518191 0.26010303 0.29165728 0.21583877 0.11737088 0.19296101 #>  [811] 0.32361687 0.12533737 0.42264415 0.26962274 0.19258665 0.07902935 #>  [817] 0.50658733 0.09531035 0.12471989 0.16534553 0.21333809 0.19824551 #>  [823] 0.32131631 0.21110132 0.45397099 0.17040715 0.11082232 0.39740554 #>  [829] 0.11784766 0.21048415 0.23815511 0.21627352 0.22230786 0.19496773 #>  [835] 0.09234444 0.25397670 0.14515013 0.22547279 0.36915724 0.13959526 #>  [841] 0.11825508 0.31733642 0.18541356 0.63303750 0.70584781 0.12120239 #>  [847] 0.18511423 0.26184193 0.25421497 0.16656696 0.16257396 0.12880906 #>  [853] 0.08000546 0.47265867 0.12890452 0.11895614 0.11635615 0.30663777 #>  [859] 0.18440747 0.46793364 0.24404690 0.33633906 0.22284799 0.09914830 #>  [865] 0.42430117 0.17279115 0.11379425 0.12299929 0.34294395 0.31395045 #>  [871] 0.08584262 0.12761247 0.12853748 0.30833687 0.05384830 0.18217656 #>  [877] 0.31348283 0.14740224 0.15121549 0.09766127 0.40497297 0.15681058 #>  [883] 0.09296469 0.19755405 0.36922182 0.29169185 0.26016053 0.10019692 #>  [889] 0.10235989 0.44997188 0.19878320 0.11053996 0.25542313 0.22243698 #>  [895] 0.30689126 0.35585926 0.13733446 0.12634331 0.13735139 0.36504658 #>  [901] 0.19609107 0.20201499 0.11009225 0.25628012 0.18267886 0.18135775 #>  [907] 0.13959232 0.21037845 0.14173742 0.33859378 0.14155402 0.17409396 #>  [913] 0.21180985 0.27547283 0.32880058 0.19306976 0.22451530 0.10856020 #>  [919] 0.31392762 0.17080020 0.15454443 0.51375106 0.17969547 0.43599815 #>  [925] 0.58459563 0.57449212 0.45263429 0.06282968 0.18349232 0.18815497 #>  [931] 0.17800245 0.36389661 0.20601421 0.13080416 0.27865734 0.47193796 #>  [937] 0.31026898 0.12187590 0.10552073 0.21982337 0.18594470 0.08081865 #>  [943] 0.05156206 0.23035887 0.37224798 0.29190857 0.21447298 0.07689465 #>  [949] 0.34640730 0.08604439 0.19212265 0.35205071 0.20725529 0.18700593 #>  [955] 0.23224856 0.03853262 0.36163301 0.18903977 0.09796734 0.39490662 #>  [961] 0.06737091 0.16060962 0.35425735 0.08855987 0.04537517 0.09533386 #>  [967] 0.12205576 0.26038541 0.10214401 0.20821442 0.12862762 0.28447119 #>  [973] 0.14392392 0.56988891 0.16724492 0.23197569 0.06071524 0.39157353 #>  [979] 0.46813951 0.38923059 0.56211734 0.39904709 0.39898901 0.13149482 #>  [985] 0.04647151 0.12620639 0.24298140 0.36656467 0.38892737 0.27262348 #>  [991] 0.64769578 0.25335730 0.25600037 0.25711690 0.26879095 0.53386659 #>  [997] 0.17217344 0.55571301 0.12213239 0.11895501"},{"path":"https://openpharma.github.io/crmPack/reference/probit.html","id":null,"dir":"Reference","previous_headings":"","what":"Shorthand for probit function — probit","title":"Shorthand for probit function — probit","text":"Shorthand probit function","code":""},{"path":"https://openpharma.github.io/crmPack/reference/probit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shorthand for probit function — probit","text":"","code":"probit(x)"},{"path":"https://openpharma.github.io/crmPack/reference/probit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shorthand for probit function — probit","text":"x function argument","code":""},{"path":"https://openpharma.github.io/crmPack/reference/probit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shorthand for probit function — probit","text":"probit(x)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/qinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the quantile function of Inverse gamma distribution — qinvGamma","title":"Compute the quantile function of Inverse gamma distribution — qinvGamma","text":"Compute quantile function Inverse gamma distribution","code":""},{"path":"https://openpharma.github.io/crmPack/reference/qinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the quantile function of Inverse gamma distribution — qinvGamma","text":"","code":"qinvGamma(p, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://openpharma.github.io/crmPack/reference/qinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the quantile function of Inverse gamma distribution — qinvGamma","text":"p vector probabilities shape parameter inverse gamma distribution b scale parameter inverse gamma distribution lower.tail logical; TRUE (default), probabilities P(X  > x), otherwise, P(X <= x). log.p FALSE TRUE, probabilities/densities p returned log(p)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/rinvGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"The random generation of the Inverse gamma distribution — rinvGamma","title":"The random generation of the Inverse gamma distribution — rinvGamma","text":"random generation Inverse gamma distribution","code":""},{"path":"https://openpharma.github.io/crmPack/reference/rinvGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The random generation of the Inverse gamma distribution — rinvGamma","text":"","code":"rinvGamma(n, a, b)"},{"path":"https://openpharma.github.io/crmPack/reference/rinvGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The random generation of the Inverse gamma distribution — rinvGamma","text":"n number observations shape parameter inverse gamma distribution b scale parameter inverse gamma distribution","code":""},{"path":"https://openpharma.github.io/crmPack/reference/safeInteger.html","id":null,"dir":"Reference","previous_headings":"","what":"Safe conversion to integer vector — safeInteger","title":"Safe conversion to integer vector — safeInteger","text":"Safe conversion integer vector","code":""},{"path":"https://openpharma.github.io/crmPack/reference/safeInteger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safe conversion to integer vector — safeInteger","text":"","code":"safeInteger(x)"},{"path":"https://openpharma.github.io/crmPack/reference/safeInteger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safe conversion to integer vector — safeInteger","text":"x numeric vector","code":""},{"path":"https://openpharma.github.io/crmPack/reference/safeInteger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safe conversion to integer vector — safeInteger","text":"integer vector","code":""},{"path":"https://openpharma.github.io/crmPack/reference/saveSample.html","id":null,"dir":"Reference","previous_headings":"","what":"Determining if this Sample Should be Saved — saveSample","title":"Determining if this Sample Should be Saved — saveSample","text":"method determines sample given iteration saved. sample saved : burn-period matches step.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/saveSample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determining if this Sample Should be Saved — saveSample","text":"","code":"saveSample(object, iteration, ...)  # S4 method for class 'McmcOptions' saveSample(object, iteration, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/saveSample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determining if this Sample Should be Saved — saveSample","text":"object (McmcOptions) object based answer determined. iteration (count) current iteration index. ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/saveSample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determining if this Sample Should be Saved — saveSample","text":"TRUE sample saved.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/saveSample.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Determining if this Sample Should be Saved — saveSample","text":"saveSample(McmcOptions): determine sample saved.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/saveSample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determining if this Sample Should be Saved — saveSample","text":"","code":"# Set up the MCMC option in order to have a burn-in of 10000 iterations and # then take every other iteration up to a collection of 10000 samples. my_options <- McmcOptions(burnin = 10000, step = 2, samples = 10000)  size(my_options) #> [1] 10000 saveSample(my_options, iteration = 5) #> [1] FALSE"},{"path":"https://openpharma.github.io/crmPack/reference/set_seed.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to Set and Save the RNG Seed — set_seed","title":"Helper Function to Set and Save the RNG Seed — set_seed","text":"code basically copied stats:::simulate.lm.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/set_seed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to Set and Save the RNG Seed — set_seed","text":"","code":"set_seed(seed = NULL)"},{"path":"https://openpharma.github.io/crmPack/reference/set_seed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to Set and Save the RNG Seed — set_seed","text":"seed object specifying random number generator initialized (\"seeded\"). Either NULL (default) integer used call set.seed() simulating response vectors. set, value saved seed slot returned object. default, NULL change random generator state.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/set_seed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to Set and Save the RNG Seed — set_seed","text":"integer vector containing random number generate state returned, order call function input reproduce obtained simulation results.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"Show summary dual-endpoint simulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"","code":"# S4 method for class 'DualSimulationsSummary' show(object)"},{"path":"https://openpharma.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"object DualSimulationsSummary object want print","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-DualSimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of the dual-endpoint simulations — show,DualSimulationsSummary-method","text":"","code":"# Define the dose-grid. emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 30))  # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size. my_size1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) my_size2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) my_size <- maxSize(my_size1, my_size2)  # Choose the rule for stopping. my_stopping1 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 )  # Stop with a small number of patients for illustration. my_stopping <- my_stopping1 | StoppingMinPatients(10) | StoppingMissingDose()  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. my_design <- DualDesign(   model = my_model,   data = emptydata,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = CohortSizeConst(3),   startingDose = 3 )  # Define scenarios for the TRUE toxicity and efficacy profiles. beta_mod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) *     (delta2^delta2) /     ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }  true_biomarker <- function(dose) {   beta_mod(     dose,     e0 = 0.2,     eMax = 0.6,     delta1 = 5,     delta2 = 5 * 0.5 / 0.5,     scal = 100   ) }  true_tox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles. par(mfrow = c(1, 2)) curve(true_tox(x), from = 0, to = 80) curve(true_biomarker(x), from = 0, to = 80)   # Run the simulation on the desired design. # For illustration purposes only 1 trial outcome is generated and 5 burn-ins # to generate 20 samples are used here. my_sims <- simulate(   object = my_design,   trueTox = true_tox,   trueBiomarker = true_biomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions = McmcOptions(     burnin = 5,     step = 1,     samples = 20   ) )  # Show the summary of the simulations. show(summary(   my_sims,   trueTox = true_tox,   trueBiomarker = true_biomarker )) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was NA, NA  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 3 (3, 3)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients on active : mean 0 % (0 %, 0 %)  #> Doses selected as MTD : mean 0 (0, 0)  #> True toxicity at doses selected : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean NA % (NA %, NA %)  #> Stop reason triggered: #>  P(0.9 ≤ Biomarker ≤ 1) ≥ 0.5 (relative) :  0 % #>  ≥ 10 patients dosed :  0 % #>  Stopped because of missing dose :  100 % #> Fitted biomarker level at dose most often selected : mean NA (NA, NA)"},{"path":"https://openpharma.github.io/crmPack/reference/show-GeneralSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"Show summary simulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-GeneralSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"","code":"# S4 method for class 'GeneralSimulationsSummary' show(object)"},{"path":"https://openpharma.github.io/crmPack/reference/show-GeneralSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"object GeneralSimulationsSummary object want print","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-GeneralSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the simulations — show,GeneralSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"Show summary Pseudo Dual simulations summary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"","code":"# S4 method for class 'PseudoDualSimulationsSummary' show(object)"},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"object PseudoDualSimulationsSummary object want print","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoDualSimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of Pseudo Dual simulations summary — show,PseudoDualSimulationsSummary-method","text":"","code":"# Example where DLE and efficacy responses are considered in the simulations. # In simulations where no samples are used a data object with doses >= 1 needs # to be generated. emptydata <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model of 'ModelEff' (e.g 'Effloglog') class. eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # The escalation rule using the 'NextBestMaxGain' class. my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Cohort size of 3. my_size <- CohortSizeConst(size = 3)  # Stop when 36 subjects are treated or next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. (For details please refer to the 'DualResponsesDesign' example.) my_design <- DualResponsesDesign(   nextBest = my_next_best,   model = dle_model,   eff_model = eff_model,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the true DLE and efficacy curves. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499) my_truth_eff <- efficacyFunction(eff_model, theta1 = -4.818429, theta2 = 3.653058)  # \\donttest{ # For illustration purpose only 2 simulations are produced. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 2,   seed = 819,   parallel = FALSE )  # Summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Show the summary of the simulations in a data frame. show(my_sum) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (6, 6)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (6, 6)  #> Proportions of observed DLT in the trials : mean 22 % (20 %, 24 %)  #> Mean toxicity risks for the patients : mean 21 % (20 %, 22 %)  #> Doses selected as TDEOT : mean 125 (125, 125)  #> True toxicity at TDEOT : mean 5 % (5 %, 5 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 125  #> Observed toxicity rate at dose most often selected: 7 % #> Fitted probabilities of DLE at dose most often selected : mean 23 % (21 %, 26 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   143.9   150.2   150.2   156.5   162.8   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.209   2.212   2.212   2.215   2.218   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.6   162.5   169.3   169.3   176.2   183.1   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #>  #> Stop reason triggered: #>  ≥ 36 patients dosed :  100 % #>  Stopped because of missing dose :  0 % #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    146.2   147.0   147.8   147.8   148.6   149.4   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    3.799   3.801   3.802   3.802   3.804   3.806   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #> Fitted expected efficacy level at dose most often selected : mean 1 (1, 1)  #> Stop reason triggered: #>  ≥ 36 patients dosed :  100 % #>  Stopped because of missing dose :  0 % # }  # Example when DLE and efficacy samples are involved.  # The escalation rule using the 'NextBestMaxGainSamples' class. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # The design of 'DualResponsesSamplesDesign' class. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # MCMC options. # For illustration purpose 50 burn-ins to generate 200 samples are used. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  # \\donttest{ # For illustration purpose 2 trials are simulated. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 2,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )  # Produce a summary of the simulations. my_sum <- summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff )  # Show the summary in data frame for the simulations. show(my_sum) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 24 (14, 34)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (1, 5)  #> Number of patients treated above the target p(DLE) used during a trial : mean 3 (1, 5)  #> Proportions of observed DLT in the trials : mean 7 % (1 %, 12 %)  #> Mean toxicity risks for the patients : mean 10 % (2 %, 18 %)  #> Doses selected as TDEOT : mean 100 (20, 180)  #> True toxicity at TDEOT : mean 44 % (9 %, 79 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> The summary table of the final TDDT across all simulations #>      Min.  1st Qu.   Median     Mean  3rd Qu.     Max.   #>    0.1401  75.4949 150.8497 150.8497 226.2044 301.5592   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #>  #> Stop reason triggered: #>  ≥ 36 patients dosed :  50 % #>  Stopped because of missing dose :  50 % #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>      300     300     300     300     300     300   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>     1.00    1.35    1.70    1.70    2.05    2.40   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> Fitted expected efficacy level at dose most often selected : mean NA (NA, NA)  #> Stop reason triggered: #>  ≥ 36 patients dosed :  50 % #>  Stopped because of missing dose :  50 % # }"},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"Show summary simulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"","code":"# S4 method for class 'PseudoSimulationsSummary' show(object)"},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"object PseudoSimulationsSummary object want print","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-PseudoSimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of the simulations — show,PseudoSimulationsSummary-method","text":"","code":"# Obtain the plot for the simulation results if only DLE responses are # considered in the simulations.  # Specified simulations when no DLE samples are used. emptydata <- Data(doseGrid = seq(25, 300, 25))  # The design only incorporate DLE responses and DLE samples are involved. # Specify the model of 'ModelTox' class eg 'LogisticIndepBeta' class model. my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The escalation rule. td_next_best <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # The cohort size is 3 subjects. my_size <- CohortSizeConst(size = 3)  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Specify the stopping rule with maximum sample size of 36 patients or when the # next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. (For details please refer to the 'TDDesign' example.) my_design <- TDDesign(   model = my_model,   nextBest = td_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the truth of the DLE responses. my_truth <- probFunction(my_model, phi1 = -53.66584, phi2 = 10.50499)  # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = my_design,   args = NULL,   truth = my_truth,   nsim = 1,   seed = 819,   parallel = FALSE )  # Summary of the simulations. my_sum <- summary(   my_sim,   truth = my_truth )  # Show the summary of the simulated results in a data frame. show(my_sum) #> Summary of 1 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 9 (9, 9)  #> Number of patients treated above the target p(DLE) used during a trial : mean 9 (9, 9)  #> Proportions of observed DLT in the trials : mean 22 % (22 %, 22 %)  #> Mean toxicity risks for the patients : mean 27 % (27 %, 27 %)  #> Doses selected as TDEOT : mean 150 (150, 150)  #> True toxicity at TDEOT : mean 26 % (26 %, 26 %)  #> Proportion of trials selecting the TDEOT: 100 % #> Proportion of trials selecting the TDDT: 100 % #> Dose most often selected as TDEOT: 150  #> Observed toxicity rate at dose most often selected: 33 % #> Fitted probabilities of DLE at dose most often selected : mean 29 % (29 %, 29 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    177.8   177.8   177.8   177.8   177.8   177.8   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #>  #> Stop reason triggered: #>  ≥ 36 patients dosed :  100 % #>  Stopped because of missing dose :  0 %  # Example where DLE samples are involved.  # The escalation rule. td_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  # The design. my_design <- TDsamplesDesign(   model = my_model,   nextBest = td_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # For illustration purposes 2 trails are simulated with 50 burn-ins to generate # 200 samples. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  my_sim <- simulate(   object = my_design,   args = NULL,   truth = my_truth,   nsim = 2,   seed = 819,   mcmcOptions = my_options,   parallel = FALSE )  # Produce a summary of the simulations. my_sum <- summary(   my_sim,   truth = my_truth )  # Show the summary of the simulated results in a data frame. show(my_sum) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 20 (6, 33)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (1, 11)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (1, 11)  #> Proportions of observed DLT in the trials : mean 11 % (2 %, 20 %)  #> Mean toxicity risks for the patients : mean 16 % (3 %, 28 %)  #> Doses selected as TDEOT : mean 50 (10, 90)  #> True toxicity at TDEOT : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    24.92   56.13   87.34   87.34  118.56  149.77   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #>  #> Stop reason triggered: #>  ≥ 36 patients dosed :  50 % #>  Stopped because of missing dose :  50 %"},{"path":"https://openpharma.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Show the summary of the simulations — show,SimulationsSummary-method","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"Show summary simulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"","code":"# S4 method for class 'SimulationsSummary' show(object)"},{"path":"https://openpharma.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"object SimulationsSummary object want print","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"invisibly returns data frame results one row appropriate column names","code":""},{"path":"https://openpharma.github.io/crmPack/reference/show-SimulationsSummary-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show the summary of the simulations — show,SimulationsSummary-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course options <- McmcOptions(   burnin = 100,   step = 2,   samples = 1000 ) time <- system.time(   mySims <- simulate(     design,     args = NULL,     truth = myTruth,     nsim = 1,     seed = 819,     mcmcOptions = options,     parallel = FALSE   ) )[3]  # Show the Summary of the Simulations show(summary(mySims, truth = myTruth)) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 19.6, 21.6  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 16 (16, 16)  #> Number of patients treated above target tox interval : mean 9 (9, 9)  #> Proportions of DLTs in the trials : mean 38 % (38 %, 38 %)  #> Mean toxicity risks for the patients on active : mean 41 % (41 %, 41 %)  #> Doses selected as MTD : mean 15 (15, 15)  #> True toxicity at doses selected : mean 3 % (3 %, 3 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 15  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean 27 % (27 %, 27 %)  #> Stop reason triggered: #>  ≥ 3 cohorts dosed :  100 % #>  P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5 :  100 % #>  ≥ 20 patients dosed :  0 %  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DADesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"Simulate outcomes time--DLT augmented CRM design (DADesign)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DADesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"","code":"# S4 method for class 'DADesign' simulate(   object,   nsim = 1L,   seed = NULL,   truthTox,   truthSurv,   trueTmax = NULL,   args = NULL,   firstSeparate = FALSE,   deescalate = TRUE,   mcmcOptions = McmcOptions(),   DA = TRUE,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   derive = list(),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DADesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"object DADesign object want simulate data nsim number simulations (default: 1) seed see set_seed truthTox function takes input dose (vector) returns true probability (vector) toxicity time DLT occurs. Additional arguments can supplied args. truthSurv CDF takes input time (vector) returns true cumulative probability (vector) DLT occur conditioning patient DLTs. trueTmax (number NULL) true maximum time DLTs can occur. Note must larger thank Tmax object's base data, length DLT window, .e. time DLTs officially declared used trial. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. deescalate deescalation DLT occurs cohorts lower dose level. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used. DA document rename parameter make meaningful parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine (maximum 5) derive named list functions derives statistics, based vector posterior MTD samples. list element must therefore accept one one argument, numeric vector, return number. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DADesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"object class Simulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DADesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a time-to-DLT augmented CRM design (DADesign) — simulate,DADesign-method","text":"","code":"# nolint start  # Define the dose-grid and PEM parameters emptydata <- DataDA(   doseGrid = c(0.1, 0.5, 1, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   Tmax = 60 )  # Initialize the mDA-CRM model npiece_ <- 10 Tmax_ <- 60  lambda_prior <- function(k) {   npiece_ / (Tmax_ * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(as.matrix(c(1:npiece_), 1, npiece_), 2, lambda_prior))),   c_par = 2 )  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping2 <- StoppingMinPatients(nPatients = 50)  myStopping <- (myStopping1 | myStopping2)  # Choose the safety window mysafetywindow <- SafetyWindowConst(c(6, 2), 7, 7)  # Initialize the design design <- DADesign(   model = model,   increments = myIncrements,   nextBest = myNextBest,   stopping = myStopping,   cohort_size = mySize,   data = emptydata,   safetyWindow = mysafetywindow,   startingDose = 3 )  ## set up truth curves myTruth <- probFunction(model, alpha0 = 2, alpha1 = 3) curve(myTruth(x), from = 0, to = 100, ylim = c(0, 1))   exp_cond.cdf <- function(x, onset = 15) {   a <- pexp(28, 1 / onset, lower.tail = FALSE)   1 - (pexp(x, 1 / onset, lower.tail = FALSE) - a) / (1 - a) }  # set up simulation settings options <- McmcOptions(   burnin = 10,   step = 1,   samples = 200 )  # \\donttest{ mySims <- simulate(design,   args = NULL,   truthTox = myTruth,   truthSurv = exp_cond.cdf,   trueTmax = 80,   nsim = 2,   seed = 819,   mcmcOptions = options,   firstSeparate = TRUE,   deescalate = FALSE,   parallel = FALSE ) # }  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-Design-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a CRM design — simulate,Design-method","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"Simulate outcomes CRM design","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-Design-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"","code":"# S4 method for class 'Design' simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   derive = list(),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-Design-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"object Design object want simulate data nsim number simulations (default: 1) seed see set_seed truth function takes input dose (vector) returns true probability (vector) toxicity. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. derive named list functions derives statistics, based vector posterior MTD samples. list element must therefore accept one one argument, numeric vector, return number. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-Design-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"object class Simulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-Design-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a CRM design — simulate,Design-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcomes here for illustration, for the actual study # this should be increased of course options <- McmcOptions(   burnin = 100,   step = 1,   samples = 2000 )  time <- system.time(   mySims <- simulate(     design,     args = NULL,     truth = myTruth,     nsim = 1,     seed = 819,     mcmcOptions = options,     parallel = FALSE   ) )[3]  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"simulate method DesignGrouped designs.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"","code":"# S4 method for class 'DesignGrouped' simulate(   object,   nsim = 1L,   seed = NULL,   truth,   combo_truth,   args = data.frame(),   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallelly::availableCores(), 5),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"object (DesignGrouped) design want simulate trials . nsim (number) many trials simulated. seed (RNGstate) generated set_seed(). truth (function) function takes input dose (vector) returns true probability (vector) toxicity mono arm. Additional arguments can supplied args. combo_truth (function) truth combo arm. args (data.frame) optional data.frame arguments work truth combo_truth functions. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. firstSeparate (flag) whether enroll first patient separately rest cohort close cohort case DLT occurs first patient. mcmcOptions (McmcOptions) MCMC options evaluation trial. parallel (flag) whether simulation runs parallelized across cores computer. nCores (number) many cores used parallel computing. ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"list mono combo simulation results Simulations objects.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DesignGrouped-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Method for the DesignGrouped Class — simulate,DesignGrouped-method","text":"","code":"# Assemble ingredients for our group design. my_stopping <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) |   StoppingMinPatients(10) |   StoppingMissingDose() my_increments <- IncrementsDoseLevels(levels = 3L) my_next_best <- NextBestNCRM(   target = c(0.2, 0.3),   overdose = c(0.3, 1),   max_overdose_prob = 0.3 ) my_cohort_size <- CohortSizeConst(3) empty_data <- Data(   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) my_model <- LogisticLogNormalGrouped(   mean = c(-4, -4, -4, -4),   cov = diag(rep(6, 4)),   ref_dose = 0.1 )  # Put together the design. Note that if we only specify the mono arm, # then the combo arm is having the same settings. my_design <- DesignGrouped(   model = my_model,   mono = Design(     model = my_model,     stopping = my_stopping,     increments = my_increments,     nextBest = my_next_best,     cohort_size = my_cohort_size,     data = empty_data,     startingDose = 0.1   ),   first_cohort_mono_only = TRUE,   same_dose_for_all = TRUE )  # Set up a realistic simulation scenario. my_truth <- function(x) plogis(-4 + 0.2 * log(x / 0.1)) my_combo_truth <- function(x) plogis(-4 + 0.5 * log(x / 0.1)) matplot(   x = empty_data@doseGrid,   y = cbind(     mono = my_truth(empty_data@doseGrid),     combo = my_combo_truth(empty_data@doseGrid)   ),   type = \"l\",   ylab = \"true DLT prob\",   xlab = \"dose\" ) legend(\"topright\", c(\"mono\", \"combo\"), lty = c(1, 2), col = c(1, 2))  # Start the simulations. set.seed(123) my_sims <- simulate(   my_design,   nsim = 1, # This should be at least 100 in actual applications.   seed = 123,   truth = my_truth,   combo_truth = my_combo_truth )  # Looking at the summary of the simulations: mono_sims_sum <- summary(my_sims$mono, truth = my_truth) combo_sims_sum <- summary(my_sims$combo, truth = my_combo_truth)  mono_sims_sum #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was NA, NA  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 12 (12, 12)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients on active : mean 3 % (3 %, 3 %)  #> Doses selected as MTD : mean 12 (12, 12)  #> True toxicity at doses selected : mean 5 % (5 %, 5 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 12  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean 8 % (8 %, 8 %)  #> Stop reason triggered: #>  P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5 :  0 % #>  ≥ 10 patients dosed :  100 % #>  Stopped because of missing dose :  0 % combo_sims_sum #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 18.6, NA  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 12 (12, 12)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 17 % (17 %, 17 %)  #> Mean toxicity risks for the patients on active : mean 9 % (9 %, 9 %)  #> Doses selected as MTD : mean 12 (12, 12)  #> True toxicity at doses selected : mean 17 % (17 %, 17 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 12  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean 19 % (19 %, 19 %)  #> Stop reason triggered: #>  P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5 :  0 % #>  ≥ 10 patients dosed :  100 % #>  Stopped because of missing dose :  0 %  plot(mono_sims_sum) plot(combo_sims_sum)   # Looking at specific simulated trials: trial_index <- 1 plot(my_sims$mono@data[[trial_index]])  plot(my_sims$combo@data[[trial_index]])"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"Simulate outcomes dual-endpoint design","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"","code":"# S4 method for class 'DualDesign' simulate(   object,   nsim = 1L,   seed = NULL,   trueTox,   trueBiomarker,   args = NULL,   sigma2W,   rho = 0,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5),   derive = list(),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"object DualDesign object want simulate data nsim number simulations (default: 1) seed see set_seed trueTox function takes input dose (vector) returns true probability (vector) toxicity. Additional arguments can supplied args. trueBiomarker function takes input dose (vector) returns true biomarker level (vector). Additional arguments can supplied args. args data frame arguments trueTox trueBiomarker function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. sigma2W variance biomarker measurements rho correlation toxicity biomarker measurements (default: 0) firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. derive named list functions derives statistics, based vector posterior MTD samples. list element must therefore accept one one argument, numeric vector, return number. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"object class DualSimulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a dual-endpoint design — simulate,DualDesign-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   use_log_dose = TRUE,   ref_dose = 2,   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose myNextBest <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping4 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 ) myStopping <- myStopping4 | StoppingMinPatients(10)  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- DualDesign(   model = model,   data = emptydata,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   startingDose = 3 )  # define scenarios for the TRUE toxicity and efficacy profiles betaMod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) *     (delta2^delta2) /     ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }  trueBiomarker <- function(dose) {   betaMod(     dose,     e0 = 0.2,     eMax = 0.6,     delta1 = 5,     delta2 = 5 * 0.5 / 0.5,     scal = 100   ) }  trueTox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles par(mfrow = c(1, 2)) curve(trueTox(x), from = 0, to = 80) curve(trueBiomarker(x), from = 0, to = 80)   # Run the simulation on the desired design # We only generate 1 trial outcome here for illustration, for the actual study # this should be increased of course, similarly for the McmcOptions - # they also need to be increased. mySims <- simulate(   design,   trueTox = trueTox,   trueBiomarker = trueBiomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions = McmcOptions(     burnin = 100,     step = 1,     samples = 300   ) )  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object. In addition, no DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesDesign-method","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object. In addition, no DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesDesign-method","text":"methods simulate dose escalation procedure using DLE efficacy responses. method based DualResponsesDesign DLEmodel used ModelTox class object efficacy model used ModelEff class object. addition, DLE efficacy samples involved generated simulation process","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object. In addition, no DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesDesign-method","text":"","code":"# S4 method for class 'DualResponsesDesign' simulate(   object,   nsim = 1L,   seed = NULL,   trueDLE,   trueEff,   trueNu,   args = NULL,   firstSeparate = FALSE,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object. In addition, no DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesDesign-method","text":"object DualResponsesDesign object want simulate data nsim number simulations (default :1) seed see set_seed trueDLE function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. trueEff function takes input dose (vector) returns expected efficacy responses (vector). Additional arguments can supplied args. trueNu precision, inverse variance efficacy responses args data frame arguments trueDLE trueEff function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object. In addition, no DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesDesign-method","text":"object class PseudoDualSimulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object. In addition, no DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesDesign-method","text":"","code":"# nolint start  ## Simulate dose-escalation procedure based on DLE and efficacy responses where no DLE ## and efficacy samples are used ## we need a data object with doses >= 1: data <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) ## First for the DLE model ## The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ## The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data )  ## The escalation rule using the 'NextBestMaxGain' class mynextbest <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )   ## The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) ) ## cohort size of 3 mySize <- CohortSizeConst(size = 3) ## Stop only when 36 subjects are treated myStopping <- StoppingMinPatients(nPatients = 36) ## Now specified the design with all the above information and starting with a dose of 25  ## Specified the design(for details please refer to the 'DualResponsesDesign' example) design <- DualResponsesDesign(   nextBest = mynextbest,   model = DLEmodel,   eff_model = Effmodel,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data,   startingDose = 25 ) ## Specify the true DLE and efficacy curves myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ## The true gain curve can also be seen myTruthGain <- function(dose) {   return((myTruthEff(dose)) / (1 + (myTruthDLE(dose) / (1 - myTruthDLE(dose))))) }   ## Then specified the simulations and generate the trial ## For illustration purpose only 1 simulation is produced (nsim=1). options <- McmcOptions(burnin = 100, step = 2, samples = 200) mySim <- simulate(   object = design,   args = NULL,   trueDLE = myTruthDLE,   trueEff = myTruthEff,   trueNu = 1 / 0.025,   nsim = 1,   seed = 819,   parallel = FALSE )  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesSamplesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object (special case is EffFlexi class model object). In addition, DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesSamplesDesign-method","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesSamplesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object (special case is EffFlexi class model object). In addition, DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesSamplesDesign-method","text":"methods simulate dose escalation procedure using DLE efficacy responses. method based DualResponsesSamplesDesign DLEmodel used ModelTox class object efficacy model used ModelEff class object (special case EffFlexi class model object). addition, DLE efficacy samples involved generated simulation process","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesSamplesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object (special case is EffFlexi class model object). In addition, DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesSamplesDesign-method","text":"","code":"# S4 method for class 'DualResponsesSamplesDesign' simulate(   object,   nsim = 1L,   seed = NULL,   trueDLE,   trueEff,   trueNu = NULL,   trueSigma2 = NULL,   trueSigma2betaW = NULL,   args = NULL,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesSamplesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object (special case is EffFlexi class model object). In addition, DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesSamplesDesign-method","text":"object DualResponsesSamplesDesign object want simulate data nsim number simulations (default :1) seed see set_seed trueDLE function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. trueEff function takes input dose (vector) returns expected efficacy responses (vector). Additional arguments can supplied args. trueNu (EffFlexi) precision, inverse variance efficacy responses trueSigma2 (EffFlexi) true variance efficacy responses must single positive scalar. trueSigma2betaW (EffFlexi) true variance random walk model used smoothing. must single positive scalar. args data frame arguments trueDLE trueEff function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesSamplesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object (special case is EffFlexi class model object). In addition, DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesSamplesDesign-method","text":"object class PseudoDualSimulations PseudoDualFlexiSimulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-DualResponsesSamplesDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure using both DLE and efficacy responses. This is a method based on the DualResponsesSamplesDesign where DLEmodel used are of ModelTox class object and efficacy model used are of ModelEff class object (special case is EffFlexi class model object). In addition, DLE and efficacy samples are involved or generated in the simulation process — simulate,DualResponsesSamplesDesign-method","text":"","code":"# nolint start  ## Simulate dose-escalation procedure based on DLE and efficacy responses where DLE ## and efficacy samples are used data <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE) ## First for the DLE model ## The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ## The efficacy model of 'ModelEff' (e.g 'Effloglog') class Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data )   ## The escalation rule using the 'NextBestMaxGainSamples' class mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ## The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) ) ## cohort size of 3 mySize <- CohortSizeConst(size = 3) ## Stop only when 10 subjects are treated (only for illustration such a low ## sample size) myStopping <- StoppingMinPatients(nPatients = 10) ## Now specified the design with all the above information and starting with ## a dose of 25  ## Specified the design design <- DualResponsesSamplesDesign(   nextBest = mynextbest,   cohort_size = mySize,   startingDose = 25,   model = DLEmodel,   eff_model = Effmodel,   data = data,   stopping = myStopping,   increments = myIncrements ) ## specified the true DLE and efficacy curve myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499) myTruthEff <- efficacyFunction(Effmodel, theta1 = -4.818429, theta2 = 3.653058)  ## The true gain curve can also be seen myTruthGain <- function(dose) {   return((myTruthEff(dose)) / (1 + (myTruthDLE(dose) / (1 - myTruthDLE(dose))))) }  ## simulate the trial for 10 times involving samples ## for illustration purpose we use 10 burn-ins to generate 50 samples options <- McmcOptions(burnin = 10, step = 1, samples = 50) ## For illustration purpose only 1 simulations are produced (nsim=1). mySim <- simulate(   design,   args = NULL,   trueDLE = myTruthDLE,   trueEff = myTruthEff,   trueNu = 1 / 0.025,   nsim = 1,   mcmcOptions = options,   seed = 819,   parallel = FALSE )   ## Simulate dose-escalation procedure based on DLE and efficacy responses where DLE ## and efficacy samples are used ## when the efficacy model is of 'EffFlexi' class Effmodel <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = data )   ## Specified the design design <- DualResponsesSamplesDesign(   nextBest = mynextbest,   cohort_size = mySize,   startingDose = 25,   model = DLEmodel,   eff_model = Effmodel,   data = data,   stopping = myStopping,   increments = myIncrements ) ## specified the true DLE curve and the true expected efficacy values at all dose levels myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499)  myTruthEff <- c(   -0.5478867,   0.1645417,   0.5248031,   0.7604467,   0.9333009,   1.0687031,   1.1793942,   1.2726408,   1.3529598,   1.4233411,   1.4858613,   1.5420182 ) ## The true gain curve can also be seen d1 <- data@doseGrid myTruthGain <- (myTruthEff) / (1 + (myTruthDLE(d1) / (1 - myTruthDLE(d1))))   mySim <- simulate(   object = design,   args = NULL,   trueDLE = myTruthDLE,   trueEff = myTruthEff,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   mcmcOptions = options,   nsim = 1,   seed = 819,   parallel = FALSE )  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"Simulate outcomes rule-based design","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"","code":"# S4 method for class 'RuleDesign' simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"object RuleDesign object want simulate data nsim number simulations (default: 1) seed see set_seed truth function takes input dose (vector) returns true probability (vector) toxicity. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"object class GeneralSimulations","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-RuleDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate outcomes from a rule-based design — simulate,RuleDesign-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(5, 10, 15, 25, 35, 50, 80))  # inizialing a 3+3 design with constant cohort size of 3 and # starting dose equal 5 myDesign <- RuleDesign(   nextBest = NextBestThreePlusThree(),   cohort_size = CohortSizeConst(size = 3L),   data = emptydata,   startingDose = 5 )  model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Perform the simulation ## For illustration purpose only 10 simulation is produced (nsim=10). threeSims <- simulate(   myDesign,   nsim = 10,   seed = 35,   truth = myTruth,   parallel = FALSE )  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDDesign where model used are of ModelTox class object and no samples are involved. — simulate,TDDesign-method","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDDesign where model used are of ModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"methods simulate dose escalation procedure using DLE responses. method based TDDesign model used ModelTox class object samples involved.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDDesign where model used are of ModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"","code":"# S4 method for class 'TDDesign' simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   firstSeparate = FALSE,   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDDesign where model used are of ModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"object TDDesign object want simulate data nsim number simulations (default :1) seed see set_seed truth function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDDesign where model used are of ModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"object class PseudoSimulations @export @keywords methods","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDDesign where model used are of ModelTox class object and no samples are involved. — simulate,TDDesign-method","text":"","code":"# nolint start  ## Simulate dose-escalation procedure based only on DLE responses and no DLE samples are used  ## The design comprises a model, the escalation rule, starting data, ## a cohort size and a starting dose ## Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid = seq(25, 300, 25))  ## The design only incorporate DLE responses and DLE samples are involved ## Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## Then the escalation rule tdNextBest <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 ) doseRecommendation <- nextBest(   tdNextBest,   doselimit = max(data@doseGrid),   model = model,   data = data ) #> Warning: TD 35 = 24.9999999999785 not within dose grid #> Warning: TD 30 = 14.3714101936776 not within dose grid ## Then the starting data, an empty data set emptydata <- Data(doseGrid = seq(25, 300, 25)) ## The cohort size, size of 3 subjects mySize <- CohortSizeConst(size = 3) ## Deifne the increments for the dose-escalation process ## The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ## The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ## This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements <- IncrementsRelative(   intervals = c(min(data@doseGrid), max(data@doseGrid)),   increments = c(2, 2) ) ## Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients = 36)   ## Specified the design(for details please refer to the 'TDDesign' example) design <- TDDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data,   startingDose = 25 )  ## Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## then plot the truth to see how the truth dose-DLE curve look like curve(myTruth(x), from = 0, to = 300, ylim = c(0, 1))    ## For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(   object = design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   parallel = FALSE )  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDsamplesDesign where model used are of ModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDsamplesDesign where model used are of ModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"methods simulate dose escalation procedure using DLE responses. method based TDsamplesDesign model used ModelTox class object DLE samples also used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDsamplesDesign where model used are of ModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"","code":"# S4 method for class 'TDsamplesDesign' simulate(   object,   nsim = 1L,   seed = NULL,   truth,   args = NULL,   firstSeparate = FALSE,   mcmcOptions = McmcOptions(),   parallel = FALSE,   nCores = min(parallel::detectCores(), 5L),   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDsamplesDesign where model used are of ModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"object TDsamplesDesign object want simulate data nsim number simulations (default :1) seed see set_seed truth function takes input dose (vector) returns true probability (vector) occurrence DLE. Additional arguments can supplied args. args data frame arguments truth function. column names correspond argument names, rows values arguments. rows appropriately recycled nsim simulations. order produce outcomes posterior predictive distribution, e.g, pass object contains data observed far, truth contains prob function model object, args contains posterior samples model. firstSeparate enroll first patient separately rest cohort? (default) yes, cohort closed DLT occurs patient. mcmcOptions object class McmcOptions, giving MCMC options evaluation trial. default, standard options used parallel simulation runs parallelized across clusters computer? (default) nCores many cores used parallel computing? Defaults number cores machine, maximum 5. ... used","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDsamplesDesign where model used are of ModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"object class PseudoSimulations @export @keywords methods","code":""},{"path":"https://openpharma.github.io/crmPack/reference/simulate-TDsamplesDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This is a methods to simulate dose escalation procedure only using the DLE responses. This is a method based on the TDsamplesDesign where model used are of ModelTox class object DLE samples are also used — simulate,TDsamplesDesign-method","text":"","code":"# nolint start  ## Simulate dose-escalation procedure based only on DLE responses with DLE samples involved  ## The design comprises a model, the escalation rule, starting data, ## a cohort size and a starting dose ## Define your data set first using an empty data set ## with dose levels from 25 to 300 with increments 25 data <- Data(doseGrid = seq(25, 300, 25))  ## The design only incorporate DLE responses and DLE samples are involved ## Specified the model of 'ModelTox' class eg 'LogisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ## Then the escalation rule tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  ## The cohort size, size of 3 subjects mySize <- CohortSizeConst(size = 3) ## Deifne the increments for the dose-escalation process ## The maximum increase of 200% for doses up to the maximum of the dose specified in the doseGrid ## The maximum increase of 200% for dose above the maximum of the dose specified in the doseGrid ## This is to specified a maximum of 3-fold restriction in dose-esclation myIncrements <- IncrementsRelative(   intervals = c(min(data@doseGrid), max(data@doseGrid)),   increments = c(2, 2) ) ## Specified the stopping rule e.g stop when the maximum sample size of 36 patients has been reached myStopping <- StoppingMinPatients(nPatients = 36)  ## Specified the design(for details please refer to the 'TDsamplesDesign' example) design <- TDsamplesDesign(   model = model,   nextBest = tdNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = data,   startingDose = 25 )  ## Specify the truth of the DLE responses myTruth <- probFunction(model, phi1 = -53.66584, phi2 = 10.50499)  ## then plot the truth to see how the truth dose-DLE curve look like curve(myTruth(x), from = 0, to = 300, ylim = c(0, 1))   ## Then specified the simulations and generate the trial ## options for MCMC options <- McmcOptions(burnin = 100, step = 2, samples = 200) ## The simulations ## For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(   object = design,   args = NULL,   truth = myTruth,   nsim = 1,   seed = 819,   mcmcOptions = options,   parallel = FALSE )  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/size.html","id":null,"dir":"Reference","previous_headings":"","what":"Size of an Object — size","title":"Size of an Object — size","text":"method computes size given object. can instance size MCMC sample, size cohort. See help specific method details.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Size of an Object — size","text":"","code":"size(object, ...)  # S4 method for class 'McmcOptions' size(object, ...)  # S4 method for class 'CohortSizeRange' size(object, dose, data)  # S4 method for class 'CohortSizeDLT' size(object, dose, data)  # S4 method for class 'CohortSizeMax' size(object, dose, data)  # S4 method for class 'CohortSizeMin' size(object, dose, data)  # S4 method for class 'CohortSizeConst' size(object, dose, ...)  # S4 method for class 'CohortSizeParts' size(object, dose, data)  # S4 method for class 'CohortSizeOrdinal' size(object, dose, data, ...)  # S4 method for class 'Samples' size(object, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Size of an Object — size","text":"object (McmcOptions Samples CohortSize) object size computed. ... used. dose (numeric) next dose. data data input, object class DataOrdinal.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Size of an Object — size","text":"size given object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/size.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Size of an Object — size","text":"size(McmcOptions): compute number MCMC samples based McmcOptions object. size(CohortSizeRange): Determines size next cohort based range next dose falls . size(CohortSizeDLT): Determines size next cohort based number DLTs far. size(CohortSizeMax): Determines size next cohort based maximum multiple cohort size rules. size(CohortSizeMin): Determines size next cohort based minimum multiple cohort size rules. size(CohortSizeConst): Constant cohort size. size(CohortSizeParts): Determines size next cohort based parts. size(CohortSizeOrdinal): Determines size next cohort ordinal CRM trial. size(Samples): get number MCMC samples Samples object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/size.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Size of an Object — size","text":"","code":"# Set up the MCMC option in order to have a burn-in of 10000 iterations and # then take every other iteration up to a collection of 10000 samples. my_options <- McmcOptions(burnin = 10000, step = 2, samples = 10000)  size(my_options) #> [1] 10000 # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Rule for the cohort size: #   - having cohort of size 1 for doses <10 #   - and having cohort of size 3 for doses >=10 mySize <- CohortSizeRange(intervals = c(0, 10), cohort_size = c(1, 3))  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value, data = data) #> [1] 3  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Rule for the cohort size: #   - having cohort of size 1 if no DLTs were yet observed #   - and having cohort of size 3 if at least 1 DLT was already observed mySize <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value, data = data) #> [1] 3  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Rule for having cohort of size 1 for doses <30 #      and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(   intervals = c(0, 10),   cohort_size = c(1, 3) )  # Rule for having cohort of size 1 until no DLT were observed #      and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  # Combining the two rules for cohort size by taking the maximum of the sample sizes # of the single rules mySize <- maxSize(mySize1, mySize2)  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value, data = data) #> [1] 3  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Rule for having cohort of size 1 for doses <30 #      and having cohort of size 3 for doses >=30 mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) )  # Rule for having cohort of size 1 until no DLT were observed #      and having cohort of size 3 as soon as 1 DLT is observed mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) )  # Combining the two rules for cohort size by taking the minimum of the sample sizes # of the single rules mySize <- minSize(mySize1, mySize2)  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value, data = data) #> [1] 1  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Rule for having cohorts with constant cohort size of 3 mySize <- CohortSizeConst(size = 3)  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value) #> [1] 3  # nolint end # nolint start  # create an object of class 'DataParts' data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  myIncrements <- IncrementsRelativeParts(   dlt_start = 0,   clean_start = 1 ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Rule for the cohort size: mySize <- CohortSizeParts(cohort_sizes = c(1, 3))  # Determine the cohort size for the next cohort size(mySize, dose = doseRecommendation$value, data = data) #> [1] 1  # nolint end CohortSizeOrdinal(   grade = 1L,   rule = CohortSizeRange(intervals = c(0L, 30L), cohort_size = c(1L, 3L)) ) #> An object of class \"CohortSizeOrdinal\" #> Slot \"grade\": #> [1] 1 #>  #> Slot \"rule\": #> An object of class \"CohortSizeRange\" #> Slot \"intervals\": #> [1]  0 30 #>  #> Slot \"cohort_size\": #> [1] 1 3 #>  #>  # Set up the MCMC option in order to have a burn-in of 100 iterations and # then take every other iteration up to a collection of 200 samples. my_options <- McmcOptions(burnin = 100, step = 2, samples = 200)  my_samples <- Samples(   data = list(alpha = rnorm(200), beta = rnorm(200)),   options = my_options )  size(my_samples) #> [1] 200"},{"path":"https://openpharma.github.io/crmPack/reference/stopTrial.html","id":null,"dir":"Reference","previous_headings":"","what":"Stop the trial? — stopTrial","title":"Stop the trial? — stopTrial","text":"function returns whether stop trial.  Stopping rule based precision MTD estimation. trial stopped, MTD can estimated sufficient precision. criteria based robust coefficient variation (CV) calculated posterior distribution. robust CV defined mad(MTD) / median(MTD), mad median absolute deviation. Stopping based based lowest non placebo dose. trial stopped lowest non placebo dose meets Hard Safety Rule, .e. deemed overly toxic. Stopping based observed data lowest dose level using Bin-Beta model based DLT probability.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/stopTrial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stop the trial? — stopTrial","text":"","code":"stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingMissingDose,numeric,ANY,ANY,Data' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingList,ANY,ANY,ANY,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingAll,ANY,ANY,ANY,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingAny,ANY,ANY,ANY,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingCohortsNearDose,numeric,ANY,ANY,Data' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingPatientsNearDose,numeric,ANY,ANY,Data' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingMinCohorts,ANY,ANY,ANY,Data' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingMinPatients,ANY,ANY,ANY,Data' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingTargetProb,numeric,Samples,GeneralModel,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingMTDdistribution,numeric,Samples,GeneralModel,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingMTDCV,numeric,Samples,GeneralModel,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingLowestDoseHSRBeta,numeric,Samples,ANY,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingTargetBiomarker,numeric,Samples,DualEndpoint,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingSpecificDose,numeric,ANY,ANY,Data' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingHighestDose,numeric,ANY,ANY,Data' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingOrdinal,numeric,ANY,LogisticLogNormalOrdinal,DataOrdinal' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingOrdinal,numeric,ANY,ANY,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingExternal,numeric,ANY,ANY,ANY' stopTrial(stopping, dose, samples, model, data, external, ...)  # S4 method for class 'StoppingTDCIRatio,ANY,Samples,ModelTox,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingTDCIRatio,ANY,missing,ModelTox,ANY' stopTrial(stopping, dose, samples, model, data, ...)  # S4 method for class 'StoppingMaxGainCIRatio,ANY,Samples,ModelTox,DataDual' stopTrial(   stopping,   dose,   samples,   model,   data,   TDderive,   Effmodel,   Effsamples,   Gstarderive,   ... )  # S4 method for class 'StoppingMaxGainCIRatio,ANY,missing,ModelTox,DataDual' stopTrial(stopping, dose, model, data, Effmodel, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/stopTrial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stop the trial? — stopTrial","text":"stopping (Stopping) rule stopping trial. dose recommended next best dose. samples (Samples) mcmc samples. model (GeneralModel) model. data (Data) input data. ... additional arguments without method dispatch. external (flag) whether stop based external result . TDderive function derives input, vector posterior samples called TDsamples dose probability occurrence DLE equals either targetDuringTrial targetEndOfTrial, final next best TDtargetDuringTrial (dose probability occurrence DLE equals targetDuringTrial)TDtargetEndOfTrial estimate. Effmodel efficacy model ModelEff class object Effsamples efficacy samples Samples class object Gstarderive function derives input, vector posterior Gstar (dose gives maximum gain value) samples called Gstarsamples, final next best Gstar estimate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/stopTrial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stop the trial? — stopTrial","text":"logical value: TRUE trial can stopped, FALSE otherwise. attribute message gives reason decision.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/stopTrial.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Stop the trial? — stopTrial","text":"stopTrial(   stopping = StoppingMissingDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop based value returned next best dose. stopTrial(   stopping = StoppingList,   dose = ,   samples = ,   model = ,   data = ): Stop based multiple stopping rules stopTrial(   stopping = StoppingAll,   dose = ,   samples = ,   model = ,   data = ): Stop based fulfillment multiple stopping rules stopTrial(   stopping = StoppingAny,   dose = ,   samples = ,   model = ,   data = ): Stop based fulfillment stopping rule stopTrial(   stopping = StoppingCohortsNearDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop based number cohorts near next best dose stopTrial(   stopping = StoppingPatientsNearDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop based number patients near next best dose stopTrial(   stopping = StoppingMinCohorts,   dose = ,   samples = ,   model = ,   data = Data ): Stop based minimum number cohorts stopTrial(   stopping = StoppingMinPatients,   dose = ,   samples = ,   model = ,   data = Data ): Stop based minimum number patients stopTrial(   stopping = StoppingTargetProb,   dose = numeric,   samples = Samples,   model = GeneralModel,   data = ): Stop based probability target tox interval stopTrial(   stopping = StoppingMTDdistribution,   dose = numeric,   samples = Samples,   model = GeneralModel,   data = ): Stop based MTD distribution stopTrial(   stopping = StoppingTargetBiomarker,   dose = numeric,   samples = Samples,   model = DualEndpoint,   data = ): Stop based probability targeting biomarker stopTrial(   stopping = StoppingSpecificDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stopping rule met specific dose planned dose grid just default next best dose. stopTrial(   stopping = StoppingHighestDose,   dose = numeric,   samples = ,   model = ,   data = Data ): Stop highest dose reached stopTrial(   stopping = StoppingOrdinal,   dose = numeric,   samples = ,   model = LogisticLogNormalOrdinal,   data = DataOrdinal ): Stop based value returned next best dose. stopTrial(   stopping = StoppingOrdinal,   dose = numeric,   samples = ,   model = ,   data = ): Stop based value returned next best dose. stopTrial(   stopping = StoppingExternal,   dose = numeric,   samples = ,   model = ,   data = ): Stop based external flag. stopTrial(   stopping = StoppingTDCIRatio,   dose = ,   samples = Samples,   model = ModelTox,   data = ): Stop based 'StoppingTDCIRatio' class reaching target ratio upper lower 95% credibility interval estimate (TDtargetEndOfTrial). stopping rule incorporate DLE responses DLE samples given stopTrial(   stopping = StoppingTDCIRatio,   dose = ,   samples = missing,   model = ModelTox,   data = ): Stop based 'StoppingTDCIRatio' class reaching target ratio upper lower 95% credibility interval estimate (TDtargetEndOfTrial). stopping rule incorporate DLE responses DLE samples involved stopTrial(   stopping = StoppingMaxGainCIRatio,   dose = ,   samples = Samples,   model = ModelTox,   data = DataDual ): Stop based reaching target ratio upper lower 95% credibility interval estimate (minimum Gstar TDtargetEndOfTrial). stopping rule incorporate DLE efficacy responses DLE efficacy samples also used. stopTrial(   stopping = StoppingMaxGainCIRatio,   dose = ,   samples = missing,   model = ModelTox,   data = DataDual ): Stop based reaching target ratio upper lower 95% credibility interval estimate (minimum Gstar TDtargetEndOfTrial). stopping rule incorporate DLE efficacy responses without DLE efficacy samples involved.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/stopTrial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stop the trial? — stopTrial","text":"","code":"## Example of combining stopping rules with '&' and/or '|' operators  myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) myStopping3 <- StoppingMinPatients(nPatients = 20)  myStopping <- (myStopping1 & myStopping2) | myStopping3 # Example of usage for `StoppingMissingDose` StopTrial class.  # Create the data. my_data <- Data(   x = c(0.01, 0.1, 0.5, 3, 6, 10, 10, 10),   y = c(0, 1, 1, 0, 0, 0, 0, 1),   cohort = c(1, 1, 2, 3, 4, 5, 5, 5),   ID = 1:8,   doseGrid = c(     0.01,     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ),   placebo = TRUE )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 )  my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose based # on the class 'NextBestNCRM'. my_next_best <- NextBestNCRM(   target = c(0.1, 0.25),   overdose = c(0.2, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   my_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Define the stopping rule such that the study would be stopped if there is # no safe active dose returned from dose_recommendation. my_stopping <- StoppingMissingDose() my_stopping <- StoppingAny(   stop_list = c(     StoppingMinPatients(nPatients = 16),     StoppingMissingDose()   ) )  # Evaluate if to stop the trial. stopTrial(   stopping = my_stopping,   dose = dose_recommendation$value,   data = my_data,   model = my_model ) #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 16\" #>  #> attr(,\"message\")[[2]] #> [1] \"Next dose is NA , i.e., no active dose is safe enough according to the NextBest rule.\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 16\" #> attr(,\"report_label\") #> [1] \"≥ 16 patients dosed\" #>  #> attr(,\"individual\")[[2]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Next dose is NA , i.e., no active dose is safe enough according to the NextBest rule.\" #> attr(,\"report_label\") #> [1] \"Stopped because of missing dose\" #>  #> attr(,\"report_label\") #> [1] NA # nolint start  # Create some data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rules myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) myStopping3 <- StoppingMinPatients(nPatients = 20)  # Create a list of stopping rules (of class 'StoppingList') which will then be # summarized (in this specific example) with the 'any' function, meaning that the study # would be stopped if 'any' of the single stopping rules is TRUE. mystopping <- StoppingList(   stop_list = c(myStopping1, myStopping2, myStopping3),   summary = any )  # Evaluate if to stop the Trial stopTrial(   stopping = myStopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 35 % for dose 20 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 35 % for dose 20 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] \"≥ 3 cohorts dosed\" #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 35 % for dose 20 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\" #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] \"≥ 20 patients dosed\" #>  #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create some data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rules myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) myStopping3 <- StoppingMinPatients(nPatients = 20)  # Combine the stopping rules, obtaining (in this specific example) a list of stopping # rules of class 'StoppingAll' myStopping <- (myStopping1 | myStopping2) & myStopping3  # Evaluate if to stop the Trial stopTrial(   stopping = myStopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> attr(,\"message\")[[1]][[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[1]][[2]] #> [1] \"Probability for target toxicity is 32 % for dose 20 and thus below the required 50 %\" #>  #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 32 % for dose 20 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] \"≥ 3 cohorts dosed\" #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 32 % for dose 20 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\" #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] \"≥ 20 patients dosed\" #>  #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create some data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rules myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5) myStopping3 <- StoppingMinPatients(nPatients = 20)  # Combine the stopping rules, obtaining (in this specific example) a list of stopping # rules of class 'StoppingAny' myStopping <- (myStopping1 | myStopping2) | myStopping3  # Evaluate if to stop the Trial stopTrial(   stopping = myStopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] TRUE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #>  #> attr(,\"message\")[[2]] #> [1] \"Probability for target toxicity is 32 % for dose 18 and thus below the required 50 %\" #>  #> attr(,\"message\")[[3]] #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 3\" #> attr(,\"report_label\") #> [1] \"≥ 3 cohorts dosed\" #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 32 % for dose 18 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\" #>  #> attr(,\"individual\")[[3]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] \"≥ 20 patients dosed\" #>  #> attr(,\"report_label\") #> [1] NA  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rule such that the study would be stopped if at least 3 # cohorts were already dosed within 1 +/- 0.2 of the next best dose myStopping <- StoppingCohortsNearDose(nCohorts = 3, percentage = 0.2)  # Evaluate if to stop the trial stopTrial(stopping = myStopping, dose = doseRecommendation$value, data = data) #> [1] FALSE #> attr(,\"message\") #> [1] \"0 cohorts lie within 0.2% of the next best dose 20. This is below the required 3 cohorts\" #> attr(,\"report_label\") #> [1] \"≥ 3 cohorts dosed in 0.2 % dose range around NBD\"  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rule such that the study would be stopped if at least 9 # patients were already dosed within 1 +/- 0.2 of the next best dose myStopping <- StoppingPatientsNearDose(nPatients = 9, percentage = 0.2)  # Evaluate if to stop the trial stopTrial(stopping = myStopping, dose = doseRecommendation$value, data = data) #> [1] FALSE #> attr(,\"message\") #> [1] \"0 patients lie within 0.2% of the next best dose 20. This is below the required 9 patients\" #> attr(,\"report_label\") #> [1] \"≥ 9 patients dosed in 0.2 % dose range around NBD\"  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rule such that the study would be stopped if at least 6 # cohorts were already dosed myStopping <- StoppingMinCohorts(nCohorts = 6)  # Evaluate if to stop the trial stopTrial(stopping = myStopping, dose = doseRecommendation$value, data = data) #> [1] TRUE #> attr(,\"message\") #> [1] \"Number of cohorts is 6 and thus reached the prespecified minimum number 6\" #> attr(,\"report_label\") #> [1] \"≥ 6 cohorts dosed\"  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rule such that the study would be stopped if at least 20 # patients were already dosed myStopping <- StoppingMinPatients(nPatients = 20)  # Evaluate if to stop the trial stopTrial(stopping = myStopping, dose = doseRecommendation$value, data = data) #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 8 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] \"≥ 20 patients dosed\"  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rule such that the study would be stopped if there is at least # 0.5 posterior probability that [0.2 =< Prob(DLT | next-best-dose) <= 0.35] myStopping <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)  # Evaluate if to stop the trial stopTrial(   stopping = myStopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 36 % for dose 20 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\"  # nolint end # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rule such that the study would be stopped if there is at least # 0.9 probability that MTD > 0.5*next_best_dose. Here MTD is defined as the dose for # which prob(DLE)=0.33 myStopping <- StoppingMTDdistribution(target = 0.33, thresh = 0.5, prob = 0.9)  # Evaluate if to stop the trial stopTrial(   stopping = myStopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] TRUE #> attr(,\"message\") #> [1] \"Probability of MTD above 50 % of current dose 20 is 91 % and thus greater than or equal to the required 90 %\" #> attr(,\"report_label\") #> [1] \"P(MTD > 0.5 * NBD | P(DLE) = 0.33) ≥ 0.9\"  # nolint end # Create the data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000,   rng_kind = \"Mersenne-Twister\",   rng_seed = 94 ) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) next_max_dose <- maxDose(my_increments, data = my_data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM'. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   my_next_best,   doselimit = next_max_dose,   samples = my_samples,   model = my_model,   data = my_data )  # Define the stopping rule such that the study would be stopped if the # the MTD can be estimated with sufficient precision, i.e. if robust coefficient # of variation is below 40%. my_stopping <- StoppingMTDCV(target = 0.3, thresh_cv = 40)  # Evaluate if to stop the trial. stopTrial(   stopping = my_stopping,   dose = dose_recommendation$value,   samples = my_samples,   model = my_model,   data = my_data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"CV of MTD is 70 % and thus above the required precision threshold of 40 %\" #> attr(,\"report_label\") #> [1] \"CV(MTD) > 0.3\" # Create the data. data <- Data(   x = c(0.1, 0.1, 0.1),   y = c(0, 0, 1),   cohort = c(1, 1, 1),   doseGrid = c(     0.1,     0.5,     1.5,     3,     6,     seq(from = 10, to = 80, by = 2)   ),   ID = 1:3 )  # Initialize the CRM model used to model the data. model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior. options <- McmcOptions(   burnin = 100,   step = 2,   samples = 2000 ) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  next_max_dose <- maxDose(my_increments, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM'. my_next_best <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. dose_recommendation <- nextBest(   my_next_best,   doselimit = next_max_dose,   samples = samples,   model = model,   data = data )  # Define the stopping rule such that the study would be stopped if first dose # is toxic based on a Beta posterior distribution with Beta(1,1) prior. my_stopping <- StoppingLowestDoseHSRBeta(   target = 0.3,   prob = 0.9 )  # Evaluate if the trial will be stopped. stopTrial(   stopping = my_stopping,   dose = dose_recommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability that the lowest active dose of 0.1 being toxic based on posterior Beta distribution using a Beta(1,1) prior is 65% and thus below the required 90% threshold.\" #> attr(,\"report_label\") #> [1] \"Pβ(lowest dose > P(DLE) = 0.3) > 0.9\" # nolint start  # Create the data data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 50, 50, 50),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1),   w = c(     0.31,     0.42,     0.59,     0.45,     0.6,     0.7,     0.55,     0.6,     0.52,     0.54,     0.56,     0.43,     0.41,     0.39,     0.34,     0.38,     0.21   ),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the Dual-Endpoint model (in this case RW1) model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 500) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # In this case target a dose achieving at least 0.9 of maximum biomarker level (efficacy) # and with a probability below 0.25 that prob(DLT)>0.35 (safety) myNextBest <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rule such that the study would be stopped if if there is at # least 0.5 posterior probability that the biomarker (efficacy) is within the # biomarker target range of [0.9, 1.0] (relative to the maximum for the biomarker). myStopping <- StoppingTargetBiomarker(target = c(0.9, 1), prob = 0.5)  # Evaluate if to stop the trial stopTrial(   stopping = myStopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target biomarker is 13 % for dose 12 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0.9 ≤ Biomarker ≤ 1) ≥ 0.5 (relative)\"  # nolint end # Create some data. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   ID = 1:8,   cohort = c(0, 1, 2, 3, 4, 5, 5, 5),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) )  # Initialize the CRM model used to model the data. my_model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 50 )  # Set-up some MCMC parameters and generate samples from the posterior. my_options <- McmcOptions(burnin = 100, step = 2, samples = 500) my_samples <- mcmc(my_data, my_model, my_options)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM'. my_nb_ncrm <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose. my_dose_recommendation <- nextBest(   nextBest = my_nb_ncrm,   doselimit = 100,   samples = my_samples,   model = my_model,   data = my_data )  # Define the stopping rules. highest_dose_safe <- StoppingSpecificDose(   rule = StoppingTargetProb(target = c(0, 0.3), prob = 0.8),   dose = 80 ) max_patients <- StoppingMinPatients(nPatients = 20) patients_near_dose <- StoppingPatientsNearDose(nPatients = 3, percentage = 0)  # Create a list of stopping rules (of class 'StoppingList') which will then be # summarized (in this specific example) with the 'any' function, meaning that # the study would be stopped if 'any' of the single stopping rules is TRUE. my_stopping <- highest_dose_safe | max_patients | patients_near_dose  # Evaluate if to stop the Trial stopTrial(   stopping = my_stopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Probability for target toxicity is 0 % for dose 80 and thus below the required 80 %\" #>  #> attr(,\"message\")[[2]] #> [1] \"Number of patients is 17 and thus below the prespecified minimum number 20\" #>  #> attr(,\"message\")[[3]] #> [1] \"0 patients lie within 0% of the next best dose 12. This is below the required 3 patients\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 0 % for dose 80 and thus below the required 80 %\" #> attr(,\"report_label\") #> [1] \"Dose 80 used for testing a stopping rule\" #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Number of patients is 17 and thus below the prespecified minimum number 20\" #> attr(,\"report_label\") #> [1] \"≥ 20 patients dosed\" #>  #> attr(,\"individual\")[[3]] #> [1] FALSE #> attr(,\"message\") #> [1] \"0 patients lie within 0% of the next best dose 12. This is below the required 3 patients\" #> attr(,\"report_label\") #> [1] \"≥ 3 patients dosed in 0 % dose range around NBD\" #>  #> attr(,\"report_label\") #> [1] NA # nolint start  # Create the data data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10, 20, 20, 20, 40, 40, 40, 80, 80, 80),   y = c(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),   cohort = c(0, 1, 2, 3, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs!  # Initialize the CRM model used to model the data model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 2000) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the stopping rule such that the study would be stopped if there is at least # 0.5 posterior probability that [0.2 =< Prob(DLT | next-best-dose) <= 0.35] stopTarget <- StoppingTargetProb(target = c(0.2, 0.35), prob = 0.5)  ## now use the StoppingHighestDose rule: stopHigh <-   StoppingHighestDose() &   StoppingPatientsNearDose(nPatients = 3, percentage = 0) &   StoppingTargetProb(target = c(0, 0.2), prob = 0.5)  ## and combine everything: myStopping <- stopTarget | stopHigh  # Then evaluate if to stop the trial stopTrial(   stopping = myStopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Probability for target toxicity is 49 % for dose 58 and thus below the required 50 %\" #>  #> attr(,\"message\")[[2]] #> attr(,\"message\")[[2]][[1]] #> [1] \"Next best dose is 58 and thus not the highest dose\" #>  #> attr(,\"message\")[[2]][[2]] #> [1] \"0 patients lie within 0% of the next best dose 58. This is below the required 3 patients\" #>  #> attr(,\"message\")[[2]][[3]] #> [1] \"Probability for target toxicity is 33 % for dose 58 and thus below the required 50 %\" #>  #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 49 % for dose 58 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\" #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> attr(,\"message\")[[1]] #> [1] \"Next best dose is 58 and thus not the highest dose\" #>  #> attr(,\"message\")[[2]] #> [1] \"0 patients lie within 0% of the next best dose 58. This is below the required 3 patients\" #>  #> attr(,\"message\")[[3]] #> [1] \"Probability for target toxicity is 33 % for dose 58 and thus below the required 50 %\" #>  #> attr(,\"individual\") #> attr(,\"individual\")[[1]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Next best dose is 58 and thus not the highest dose\" #> attr(,\"report_label\") #> [1] \"NBD is the highest dose\" #>  #> attr(,\"individual\")[[2]] #> [1] FALSE #> attr(,\"message\") #> [1] \"0 patients lie within 0% of the next best dose 58. This is below the required 3 patients\" #> attr(,\"report_label\") #> [1] \"≥ 3 patients dosed in 0 % dose range around NBD\" #>  #> attr(,\"individual\")[[3]] #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 33 % for dose 58 and thus below the required 50 %\" #> attr(,\"report_label\") #> [1] \"P(0 ≤ prob(DLE | NBD) ≤ 0.2) ≥ 0.5\" #>  #> attr(,\"report_label\") #> [1] NA #>  #> attr(,\"report_label\") #> [1] NA  # nolint end data <- .DefaultDataOrdinal() model <- .DefaultLogisticLogNormalOrdinal() options <- .DefaultMcmcOptions() samples <- mcmc(data, model, options) #> Warning: Unused variable \"y\" in data  myIncrements <- .DefaultIncrementsOrdinal() nextMaxDose <- maxDose(myIncrements, data = data)  myNextBest <- .DefaultNextBestOrdinal()  doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data ) #> Warning: Arguments in `...` must be used. #> ✖ Problematic arguments: #> • fill = \"grey50\" #> • colour = \"grey50\" #> ℹ Did you misspell an argument name?  myStopping <- .DefaultStoppingOrdinal()  stopTrial(   stopping = myStopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 33 % for dose 50 and thus below the required 60 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.6\" data <- .DefaultDataOrdinal() model <- .DefaultLogisticLogNormalOrdinal() options <- .DefaultMcmcOptions() samples <- mcmc(data, model, options) #> Warning: Unused variable \"y\" in data  myIncrements <- .DefaultIncrementsOrdinal() nextMaxDose <- maxDose(myIncrements, data = data)  myNextBest <- .DefaultNextBestOrdinal()  doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data ) #> Warning: Arguments in `...` must be used. #> ✖ Problematic arguments: #> • fill = \"grey50\" #> • colour = \"grey50\" #> ℹ Did you misspell an argument name?  myStopping <- .DefaultStoppingOrdinal()  stopTrial(   stopping = myStopping,   dose = doseRecommendation$value,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"Probability for target toxicity is 37 % for dose 50 and thus below the required 60 %\" #> attr(,\"report_label\") #> [1] \"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.6\" my_rule <- StoppingExternal(report_label = \"Based on combo stop\")  stopTrial(   my_rule,   5,   .DefaultSamples(),   .DefaultModelLogNormal(),   .DefaultData(),   external = TRUE ) #> [1] TRUE #> attr(,\"message\") #> [1] \"Based on external result stop\" #> attr(,\"report_label\") #> [1] \"Based on combo stop\" # nolint start  ##define the stopping rules based on the 'StoppingTDCIRatio' class ##Using only DLE responses with samples ## we need a data object with doses >= 1: data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  ##model can be specified of 'Model' or 'ModelTox' class ##For example, the 'logisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ##define MCMC options ##for illustration purpose we use 10 burn-in and generate 50 samples options <- McmcOptions(burnin = 10, step = 2, samples = 50) ##samples of 'Samples' class samples <- mcmc(data, model, options) ##define the 'StoppingTDCIRatio' class myStopping <- StoppingTDCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) tdNextBest <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  RecommendDose <- nextBest(   tdNextBest,   doselimit = max(data@doseGrid),   samples = samples,   model = model,   data = data ) ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(   stopping = myStopping,   dose = RecommendDose$next_dose_drt,   samples = samples,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"95% CI is (2.87962060593596e-11, 11670.389917859), Ratio = 405275260699345 is greater than target_ratio = 5\" #> attr(,\"report_label\") #> [1] \"TD 5 for 0.3 target prob\"  # nolint end # nolint start  ##define the stopping rules based on the 'StoppingTDCIRatio' class ##Using only DLE responses ## we need a data object with doses >= 1: data <- Data(   x = c(25, 50, 50, 75, 150, 200, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   doseGrid = seq(from = 25, to = 300, by = 25) ) #> Used default patient IDs! #> Used best guess cohort indices!  ##model must be of 'ModelTox' class ##For example, the 'logisticIndepBeta' class model model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data ) ##define the 'StoppingTDCIRatio' class myStopping <- StoppingTDCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) tdNextBest <- NextBestTD(prob_target_drt = 0.35, prob_target_eot = 0.3)   RecommendDose <- nextBest(   tdNextBest,   doselimit = max(data@doseGrid),   model = model,   data = data ) ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(   stopping = myStopping,   dose = RecommendDose$next_dose_drt,   model = model,   data = data ) #> [1] FALSE #> attr(,\"message\") #> [1] \"95% CI is ( 15.2619 , 173.8695 ), Ratio = 11.3924 is  greater than target_ratio = 5\" #> attr(,\"report_label\") #> [1] \"TD 5 for 0.3 target prob\"  # nolint end # nolint start ##define the stopping rules based on the 'StoppingMaxGainCIRatio' class ##Using both DLE and efficacy responses ## we need a data object with doses >= 1: data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices!  ##DLEmodel must be of 'ModelTox' class ##For example, the 'logisticIndepBeta' class model DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ##Effmodel must be  of 'ModelEff' class ##For example, the 'Effloglog' class model Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data ) ##for illustration purpose we use 10 burn-in and generate 50 samples options <- McmcOptions(burnin = 10, step = 2, samples = 50) ##DLE and efficacy samples must be of 'Samples' class DLEsamples <- mcmc(data, DLEmodel, options) Effsamples <- mcmc(data, Effmodel, options)  ##define the 'StoppingMaxGainCIRatio' class myStopping <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  RecommendDose <- nextBest(   mynextbest,   doselimit = max(data@doseGrid),   samples = DLEsamples,   model = DLEmodel,   data = data,   model_eff = Effmodel,   samples_eff = Effsamples ) #> [1] \"Estimated TD 35 = 14.8679719869239 not within dose grid\" #> [1] \"Estimated TD 30 = 9.60973788445752 not within dose grid\" #> [1] \"Estimated max gain dose = 300 not within dose grid\" ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(   stopping = myStopping,   dose = RecommendDose$next_dose,   samples = DLEsamples,   model = DLEmodel,   data = data,   TDderive = function(TDsamples) {     quantile(TDsamples, prob = 0.3)   },   Effmodel = Effmodel,   Effsamples = Effsamples,   Gstarderive = function(Gstarsamples) {     quantile(Gstarsamples, prob = 0.5)   } ) #> [1] FALSE #> attr(,\"message\") #> [1] \"Gstar estimate is 300 with 95% CI ( 25 , 300 ) and its ratio = 12\"                                                        #> [2] \"TDtargetEndOfTrial estimate is  9.6097 with 95% CI ( 0.0014 , 2.68928250389749e+39 ) and its ratio= 1.93690997063425e+42\" #> [3] \"TDtargetEndOfTrial estimate is smaller with ratio = 1.93690997063425e+42  which is  greater than target_ratio = 5\"        #> attr(,\"report_label\") #> [1] \"GStar 5 for 0.3 target prob\"  # nolint end # nolint start  ##define the stopping rules based on the 'StoppingMaxGainCIRatio' class ##Using both DLE and efficacy responses ## we need a data object with doses >= 1: data <- DataDual(   x = c(25, 50, 25, 50, 75, 300, 250, 150),   y = c(0, 0, 0, 0, 0, 1, 1, 0),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   doseGrid = seq(25, 300, 25),   placebo = FALSE ) #> Used default patient IDs! #> Used best guess cohort indices!  ##DLEmodel must be of 'ModelTox' class ##For example, the 'logisticIndepBeta' class model DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ##Effmodel must be  of 'ModelEff' class ##For example, the 'Effloglog' class model Effmodel <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = data )   ##define the 'StoppingMaxGainCIRatio' class myStopping <- StoppingMaxGainCIRatio(target_ratio = 5, prob_target = 0.3) ##Find the next Recommend dose using the nextBest method (plesae refer to nextbest examples) mynextbest <- NextBestMaxGain(prob_target_drt = 0.35, prob_target_eot = 0.3)  RecommendDose <- nextBest(   mynextbest,   doselimit = max(data@doseGrid),   model = DLEmodel,   model_eff = Effmodel,   data = data )  ##use 'stopTrial' to determine if the rule has been fulfilled ##use 0.3 as the target proability of DLE at the end of the trial  stopTrial(   stopping = myStopping,   dose = RecommendDose$next_dose,   model = DLEmodel,   data = data,   Effmodel = Effmodel ) #> [1] FALSE #> attr(,\"message\") #> [1] \"Gstar estimate is 94.942 with 95% CI ( 16.771 , 537.4745 ) and its ratio = 32.0479\"                  #> [2] \"TDtargetEndOfTrial estimate is  81.4924 with 95% CI ( 24.3435 , 272.804 ) and its ratio= 11.2064\"    #> [3] \"TDatrgetEndOfTrial estimate is smaller with ratio = 11.2064 which is  greater than target_ratio = 5\" #> attr(,\"report_label\") #> [1] \"GStar 5 for 0.3 target prob\"  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/summary-DualSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the dual-endpoint design simulations, relative to given true dose-toxicity and dose-biomarker curves — summary,DualSimulations-method","title":"Summarize the dual-endpoint design simulations, relative to given true dose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"Summarize dual-endpoint design simulations, relative given true dose-toxicity dose-biomarker curves","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-DualSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the dual-endpoint design simulations, relative to given true dose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"","code":"# S4 method for class 'DualSimulations' summary(object, trueTox, trueBiomarker, target = c(0.2, 0.35), ...)"},{"path":"https://openpharma.github.io/crmPack/reference/summary-DualSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the dual-endpoint design simulations, relative to given true dose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"object DualSimulations object want summarize trueTox function takes input dose (vector) returns true probability (vector) toxicity. trueBiomarker function takes input dose (vector) returns true biomarker level (vector). target target toxicity interval (default: 20-35%) used computations ... Additional arguments can supplied trueTox trueBiomarker","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-DualSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the dual-endpoint design simulations, relative to given true dose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"object class DualSimulationsSummary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-DualSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the dual-endpoint design simulations, relative to given true dose-toxicity and dose-biomarker curves — summary,DualSimulations-method","text":"","code":"# Define the dose-grid. emptydata <- DataDual(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))   # Initialize the CRM model. my_model <- DualEndpointRW(   mean = c(0, 1),   cov = matrix(c(1, 0, 0, 1), nrow = 2),   sigma2betaW = 0.01,   sigma2W = c(a = 0.1, b = 0.1),   rho = c(a = 1, b = 1),   rw1 = TRUE )  # Choose the rule for selecting the next dose. my_next_best <- NextBestDualEndpoint(   target = c(0.9, 1),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for stopping. my_stopping1 <- StoppingTargetBiomarker(   target = c(0.9, 1),   prob = 0.5 )  # For illustration stop with 6 subjects. my_stopping <- my_stopping1 | StoppingMinPatients(6) | StoppingMissingDose()  # Choose the rule for dose increments. my_increments <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design. design <- DualDesign(   model = my_model,   data = emptydata,   nextBest = my_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = CohortSizeConst(3),   startingDose = 3 )  # Define scenarios for the TRUE toxicity and efficacy profiles. beta_mod <- function(dose, e0, eMax, delta1, delta2, scal) {   maxDens <- (delta1^delta1) *     (delta2^delta2) /     ((delta1 + delta2)^(delta1 + delta2))   dose <- dose / scal   e0 + eMax / maxDens * (dose^delta1) * (1 - dose)^delta2 }  true_biomarker <- function(dose) {   beta_mod(     dose,     e0 = 0.2,     eMax = 0.6,     delta1 = 5,     delta2 = 5 * 0.5 / 0.5,     scal = 100   ) }  true_tox <- function(dose) {   pnorm((dose - 60) / 10) }  # Draw the TRUE profiles. par(mfrow = c(1, 2)) curve(true_tox(x), from = 0, to = 80) curve(true_biomarker(x), from = 0, to = 80)   # Run the simulation on the desired design. # For illustration purposes 1 trial is simulated with 5 burn-ins to generate 20 samples. my_sims <- simulate(   object = design,   trueTox = true_tox,   trueBiomarker = true_biomarker,   sigma2W = 0.01,   rho = 0,   nsim = 1,   parallel = FALSE,   seed = 3,   startingDose = 6,   mcmcOptions = McmcOptions(     burnin = 5,     step = 1,     samples = 20   ) )  # Summarize the results of the simulations. summary(   my_sims,   trueTox = true_tox,   trueBiomarker = true_biomarker ) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 51.6, 56.1  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 6 (6, 6)  #> Number of patients treated above target tox interval : mean 0 (0, 0)  #> Proportions of DLTs in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients on active : mean 0 % (0 %, 0 %)  #> Doses selected as MTD : mean 1 (1, 1)  #> True toxicity at doses selected : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 1  #> Observed toxicity rate at dose most often selected: 0 % #> Fitted toxicity rate at dose most often selected : mean 36 % (36 %, 36 %)  #> Stop reason triggered: #>  P(0.9 ≤ Biomarker ≤ 1) ≥ 0.5 (relative) :  0 % #>  ≥ 6 patients dosed :  100 % #>  Stopped because of missing dose :  0 % #> Fitted biomarker level at dose most often selected : mean 0.5 (0.5, 0.5)"},{"path":"https://openpharma.github.io/crmPack/reference/summary-GeneralSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"Summarize simulations, relative given truth","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-GeneralSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"","code":"# S4 method for class 'GeneralSimulations' summary(object, truth, target = c(0.2, 0.35), ...)"},{"path":"https://openpharma.github.io/crmPack/reference/summary-GeneralSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"object GeneralSimulations object want summarize truth function takes input dose (vector) returns true probability (vector) toxicity target target toxicity interval (default: 20-35%) used computations ... Additional arguments can supplied truth","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-GeneralSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the simulations, relative to a given truth — summary,GeneralSimulations-method","text":"object class GeneralSimulationsSummary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"Summary Pseudo Dual responses simulations given pseudo DLE model Flexible efficacy model.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"","code":"# S4 method for class 'PseudoDualFlexiSimulations' summary(   object,   trueDLE,   trueEff,   targetEndOfTrial = 0.3,   targetDuringTrial = 0.35,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"object PseudoDualFlexiSimulations object want summarize trueDLE function takes input dose (vector) returns true probability DLE (vector) trueEff vector takes input true mean efficacy values dose levels (order) targetEndOfTrial target probability DLE used end trial. Default 0.3. targetDuringTrial target probability DLE used trial. Default 0.35. ... Additional arguments can supplied trueDLE trueEff","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"object class PseudoDualSimulationsSummary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualFlexiSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for Pseudo Dual responses simulations given a pseudo DLE model and the Flexible efficacy model. — summary,PseudoDualFlexiSimulations-method","text":"","code":"# nolint start  ## If DLE and efficacy responses are considered in the simulations and the 'EffFlexi' class is used ## we need a data object with doses >= 1: data <- DataDual(doseGrid = seq(25, 300, 25)) ## First for the DLE model ## The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class DLEmodel <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = data )  ## for the efficacy model Effmodel <- EffFlexi(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   sigma2W = c(a = 0.1, b = 0.1),   sigma2betaW = c(a = 20, b = 50),   rw1 = FALSE,   data = data )   ## specified the next best mynextbest <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  ## The increments (see Increments class examples) ## 200% allowable increase for dose below 300 and 200% increase for dose above 300 myIncrements <- IncrementsRelative(   intervals = c(25, 300),   increments = c(2, 2) ) ## cohort size of 3 mySize <- CohortSizeConst(size = 3) ## Stop only when 10 subjects are treated: ## very low sample size is just for illustration here myStopping <- StoppingMinPatients(nPatients = 10)  ## Specified the design design <- DualResponsesSamplesDesign(   nextBest = mynextbest,   cohort_size = mySize,   startingDose = 25,   model = DLEmodel,   eff_model = Effmodel,   data = data,   stopping = myStopping,   increments = myIncrements ) ## specified the true DLE curve and the true expected efficacy values at all dose levels myTruthDLE <- probFunction(DLEmodel, phi1 = -53.66584, phi2 = 10.50499)  myTruthEff <- c(   -0.5478867,   0.1645417,   0.5248031,   0.7604467,   0.9333009,   1.0687031,   1.1793942,   1.2726408,   1.3529598,   1.4233411,   1.4858613,   1.5420182 )   ## specify the options for MCMC # For illustration purpose, we use 10 burn-in and generate 100 samples options <- McmcOptions(burnin = 10, step = 1, samples = 100) ## The simulation ## For illustration purpose only 1 simulation is produced (nsim=1). mySim <- simulate(   object = design,   args = NULL,   trueDLE = myTruthDLE,   trueEff = myTruthEff,   trueSigma2 = 0.025,   trueSigma2betaW = 1,   nsim = 1,   seed = 819,   parallel = FALSE,   mcmcOptions = options ) ## summarize the simulation results summary(mySim, trueDLE = myTruthDLE, trueEff = myTruthEff) #> Summary of 1 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 12 (12, 12)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 0 (0, 0)  #> Number of patients treated above the target p(DLE) used during a trial : mean 0 (0, 0)  #> Proportions of observed DLT in the trials : mean 0 % (0 %, 0 %)  #> Mean toxicity risks for the patients : mean 0 % (0 %, 0 %)  #> Doses selected as TDEOT : mean 0 (0, 0)  #> True toxicity at TDEOT : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    10.12   10.12   10.12   10.12   10.12   10.12   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    6.222   6.222   6.222   6.222   6.222   6.222   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    10.12   10.12   10.12   10.12   10.12   10.12   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #>  #> Stop reason triggered: #>  ≥ 10 patients dosed :  100 % #> Target Gstar, the dose which gives the maximum gain value was 125  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>      250     250     250     250     250     250   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.192   2.192   2.192   2.192   2.192   2.192   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    10.12   10.12   10.12   10.12   10.12   10.12   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> Fitted expected efficacy level at dose most often selected : mean NA (NA, NA)  #> Stop reason triggered: #>  ≥ 10 patients dosed :  100 %  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model (except the EffFlexi class model) — summary,PseudoDualSimulations-method","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model (except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"Summary Pseudo Dual responses simulations, relative given pseudo DLE efficacy model (except EffFlexi class model)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model (except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"","code":"# S4 method for class 'PseudoDualSimulations' summary(   object,   trueDLE,   trueEff,   targetEndOfTrial = 0.3,   targetDuringTrial = 0.35,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model (except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"object PseudoDualSimulations object want summarize trueDLE function takes input dose (vector) returns true probability (vector) DLE trueEff function takes input dose (vector) returns mean efficacy value(s) (vector). targetEndOfTrial target probability DLE used end trial. Default 0.3. targetDuringTrial target probability DLE used trial. Default 0.35. ... Additional arguments can supplied trueDLE trueEff","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model (except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"object class PseudoDualSimulationsSummary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoDualSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for Pseudo Dual responses simulations, relative to a given pseudo DLE and efficacy model (except the EffFlexi class model) — summary,PseudoDualSimulations-method","text":"","code":"# Obtain the plot for the simulation results if DLE and efficacy responses # are considered in the simulations.  # Specified simulations when no samples are used. emptydata <- DataDual(doseGrid = seq(25, 300, 25))  # The DLE model must be of 'ModelTox' (e.g 'LogisticIndepBeta') class. dle_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The efficacy model of 'ModelEff' (e.g 'Effloglog') class. eff_model <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = emptydata )  # The escalation rule using the 'NextBestMaxGain' class. my_next_best <- NextBestMaxGain(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Cohort size of 3. my_size <- CohortSizeConst(size = 3)  # Stop when 36 subjects are treated or next dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. (For details please refer to the 'DualResponsesDesign' example.) my_design <- DualResponsesDesign(   nextBest = my_next_best,   model = dle_model,   eff_model = eff_model,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the true DLE and efficacy curves. my_truth_dle <- probFunction(dle_model, phi1 = -53.66584, phi2 = 10.50499) my_truth_eff <- efficacyFunction(eff_model, theta1 = -4.818429, theta2 = 3.653058)  # \\donttest{ # Specify the simulations and generate the 2 trials. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 2,   seed = 819,   parallel = FALSE )  # Produce a summary of the simulations. summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff ) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (6, 6)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (6, 6)  #> Proportions of observed DLT in the trials : mean 22 % (20 %, 24 %)  #> Mean toxicity risks for the patients : mean 21 % (20 %, 22 %)  #> Doses selected as TDEOT : mean 125 (125, 125)  #> True toxicity at TDEOT : mean 5 % (5 %, 5 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 125  #> Observed toxicity rate at dose most often selected: 7 % #> Fitted probabilities of DLE at dose most often selected : mean 23 % (21 %, 26 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   143.9   150.2   150.2   156.5   162.8   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.209   2.212   2.212   2.215   2.218   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.6   162.5   169.3   169.3   176.2   183.1   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #>  #> Stop reason triggered: #>  ≥ 36 patients dosed :  100 % #>  Stopped because of missing dose :  0 % #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    146.2   147.0   147.8   147.8   148.6   149.4   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    3.799   3.801   3.802   3.802   3.804   3.806   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    137.6   140.5   143.5   143.5   146.4   149.4   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.206   2.606   3.006   3.006   3.406   3.806   #> Fitted expected efficacy level at dose most often selected : mean 1 (1, 1)  #> Stop reason triggered: #>  ≥ 36 patients dosed :  100 % #>  Stopped because of missing dose :  0 % # }  # Example where DLE and efficacy samples are involved. # Please refer to design-method 'simulate DualResponsesSamplesDesign' examples for details.  # Specify the next best rule. my_next_best <- NextBestMaxGainSamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, prob = 0.3))   },   mg_derive = function(mg_samples) {     as.numeric(quantile(mg_samples, prob = 0.5))   } )  # Specify the design. my_design <- DualResponsesSamplesDesign(   nextBest = my_next_best,   cohort_size = my_size,   startingDose = 25,   model = dle_model,   eff_model = eff_model,   data = emptydata,   stopping = my_stopping,   increments = my_increments )  # For illustration purpose 50 burn-ins to generate 200 samples are used. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  # fmt: skip # \\donttest{ # For illustration purpose 2 simulation are created. my_sim <- simulate(   object = my_design,   args = NULL,   trueDLE = my_truth_dle,   trueEff = my_truth_eff,   trueNu = 1 / 0.025,   nsim = 2,   mcmcOptions = my_options,   seed = 819,   parallel = FALSE )  # Produce a summary of the simulations. summary(   my_sim,   trueDLE = my_truth_dle,   trueEff = my_truth_eff ) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 24 (14, 34)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 3 (1, 5)  #> Number of patients treated above the target p(DLE) used during a trial : mean 3 (1, 5)  #> Proportions of observed DLT in the trials : mean 7 % (1 %, 12 %)  #> Mean toxicity risks for the patients : mean 10 % (2 %, 18 %)  #> Doses selected as TDEOT : mean 100 (20, 180)  #> True toxicity at TDEOT : mean 44 % (9 %, 79 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> The summary table of the final TDDT across all simulations #>      Min.  1st Qu.   Median     Mean  3rd Qu.     Max.   #>    0.1401  75.4949 150.8497 150.8497 226.2044 301.5592   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #>  #> Stop reason triggered: #>  ≥ 36 patients dosed :  50 % #>  Stopped because of missing dose :  50 % #> Target Gstar, the dose which gives the maximum gain value was 130.0097  #> Target Gstar at dose Grid was 125  #> The summary table of the final Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>      300     300     300     300     300     300   #> The summary table of the final ratios of the Gstar across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>     1.00    1.35    1.70    1.70    2.05    2.40   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    1.736  55.402 109.068 109.068 162.734 216.400   #> The summary table of the final ratios of the optimal dose for stopping across #>         all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>        1       1       1       1       1       1   #> Fitted expected efficacy level at dose most often selected : mean NA (NA, NA)  #> Stop reason triggered: #>  ≥ 36 patients dosed :  50 % #>  Stopped because of missing dose :  50 % # }"},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"Summarize simulations, relative given truth","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"","code":"# S4 method for class 'PseudoSimulations' summary(object, truth, targetEndOfTrial = 0.3, targetDuringTrial = 0.35, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"object PseudoSimulations object want summarize truth function takes input dose (vector) returns true probability (vector) toxicity targetEndOfTrial target probability DLE wanted achieve end trial targetDuringTrial target probability DLE wanted achieve trial ... Additional arguments can supplied truth","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"object class PseudoSimulationsSummary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-PseudoSimulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the simulations, relative to a given truth — summary,PseudoSimulations-method","text":"","code":"emptydata <- Data(doseGrid = seq(25, 300, 25))  # The design incorporate DLE responses and DLE samples. # Specify the model of 'ModelTox' class eg 'LogisticIndepBeta' class model. my_model <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = emptydata )  # The escalation rule. td_next_best <- NextBestTD(   prob_target_drt = 0.35,   prob_target_eot = 0.3 )  # Cohort size is 3 subjects. my_size <- CohortSizeConst(size = 3)  # Allow increase of 200%. my_increments <- IncrementsRelative(intervals = 0, increments = 2)  # Stopp when the maximum sample size of 36 patients has been reached or the next # dose is NA. my_stopping <- StoppingMinPatients(nPatients = 36) | StoppingMissingDose()  # Specify the design. (For details please refer to the 'TDDesign' example.) my_design <- TDDesign(   model = my_model,   nextBest = td_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # Specify the truth of the DLE responses. my_truth <- probFunction(my_model, phi1 = -53.66584, phi2 = 10.50499)  # For illustration purpose 50 burn-ins to generate 200 samples are used. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  # Refer to design-method 'simulate TDDesign' examples for details. # For illustration purpose only 1 simulation is produced. my_sim <- simulate(   object = my_design,   args = NULL,   truth = my_truth,   nsim = 1,   seed = 819,   parallel = FALSE,   mcmcOptions = my_options )  # Produce a summary of the simulations. summary(   my_sim,   truth = my_truth ) #> Summary of 1 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 36 (36, 36)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 9 (9, 9)  #> Number of patients treated above the target p(DLE) used during a trial : mean 9 (9, 9)  #> Proportions of observed DLT in the trials : mean 22 % (22 %, 22 %)  #> Mean toxicity risks for the patients : mean 27 % (27 %, 27 %)  #> Doses selected as TDEOT : mean 150 (150, 150)  #> True toxicity at TDEOT : mean 26 % (26 %, 26 %)  #> Proportion of trials selecting the TDEOT: 100 % #> Proportion of trials selecting the TDDT: 100 % #> Dose most often selected as TDEOT: 150  #> Observed toxicity rate at dose most often selected: 33 % #> Fitted probabilities of DLE at dose most often selected : mean 29 % (29 %, 29 %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    177.8   177.8   177.8   177.8   177.8   177.8   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    155.1   155.1   155.1   155.1   155.1   155.1   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    2.405   2.405   2.405   2.405   2.405   2.405   #>  #> Stop reason triggered: #>  ≥ 36 patients dosed :  100 % #>  Stopped because of missing dose :  0 %  # Example where DLE samples are involved.  # Specify the next best rule. td_next_best <- NextBestTDsamples(   prob_target_drt = 0.35,   prob_target_eot = 0.3,   derive = function(samples) {     as.numeric(quantile(samples, probs = 0.3))   } )  # The design. my_design <- TDsamplesDesign(   model = my_model,   nextBest = td_next_best,   stopping = my_stopping,   increments = my_increments,   cohort_size = my_size,   data = emptydata,   startingDose = 25 )  # For illustration purpose 50 burn-ins to generate 200 samples are used. my_options <- McmcOptions(burnin = 50, step = 2, samples = 200)  # For illustration purpose 2 trials are simulated. my_sim <- simulate(   object = my_design,   args = NULL,   truth = my_truth,   nsim = 2,   seed = 819,   mcmcOptions = my_options,   parallel = FALSE )  # Produce a summary of the simulations. summary(   my_sim,   truth = my_truth ) #> Summary of 2 simulations #>  #> Target probability of DLE p(DLE) used at the end of a trial was 30 % #> The dose level corresponds to the target p(DLE) used at the end of a trial, TDEOT, was 152.6195  #> TDEOT at dose Grid was 150  #> Target p(DLE) used during a trial was 35 % #> The dose level corresponds to the target p(DLE) used during a trial, TDDT, was 155.972  #> TDDT at dose Grid was 150  #> Number of patients overall : mean 20 (6, 33)  #> Number of patients treated above the target p(DLE) used at the end of a trial : mean 6 (1, 11)  #> Number of patients treated above the target p(DLE) used during a trial : mean 6 (1, 11)  #> Proportions of observed DLT in the trials : mean 11 % (2 %, 20 %)  #> Mean toxicity risks for the patients : mean 16 % (3 %, 28 %)  #> Doses selected as TDEOT : mean 50 (10, 90)  #> True toxicity at TDEOT : mean 0 % (0 %, 0 %)  #> Proportion of trials selecting the TDEOT: 0 % #> Proportion of trials selecting the TDDT: 0 % #> Dose most often selected as TDEOT: 0  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted probabilities of DLE at dose most often selected : mean NA % (NA %, NA %)  #> The summary table of the final TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the TDEOT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #> The summary table of the final TDDT across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    24.92   56.13   87.34   87.34  118.56  149.77   #> The summary table of dose levels, the optimal dose #>  to recommend for subsequent study across all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    17.95   43.51   69.07   69.07   94.63  120.19   #> The summary table of the final ratios of the optimal dose for stopping across #>                   all simulations #>     Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   #>    473.5   781.3  1089.2  1089.2  1397.0  1704.8   #>  #> Stop reason triggered: #>  ≥ 36 patients dosed :  50 % #>  Stopped because of missing dose :  50 %"},{"path":"https://openpharma.github.io/crmPack/reference/summary-Simulations-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"Summarize model-based design simulations, relative given truth","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-Simulations-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"","code":"# S4 method for class 'Simulations' summary(object, truth, target = c(0.2, 0.35), ...)"},{"path":"https://openpharma.github.io/crmPack/reference/summary-Simulations-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"object Simulations object want summarize truth function takes input dose (vector) returns true probability (vector) toxicity target target toxicity interval (default: 20-35%) used computations ... Additional arguments can supplied truth","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-Simulations-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"object class SimulationsSummary","code":""},{"path":"https://openpharma.github.io/crmPack/reference/summary-Simulations-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the model-based design simulations, relative to a given truth — summary,Simulations-method","text":"","code":"# nolint start  # Define the dose-grid emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  # Initialize the CRM model model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  # Choose the rule for selecting the next dose myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Choose the rule for the cohort-size mySize1 <- CohortSizeRange(   intervals = c(0, 30),   cohort_size = c(1, 3) ) mySize2 <- CohortSizeDLT(   intervals = c(0, 1),   cohort_size = c(1, 3) ) mySize <- maxSize(mySize1, mySize2)  # Choose the rule for stopping myStopping1 <- StoppingMinCohorts(nCohorts = 3) myStopping2 <- StoppingTargetProb(   target = c(0.2, 0.35),   prob = 0.5 ) myStopping3 <- StoppingMinPatients(nPatients = 20) myStopping <- (myStopping1 & myStopping2) | myStopping3  # Choose the rule for dose increments myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) )  # Initialize the design design <- Design(   model = model,   nextBest = myNextBest,   stopping = myStopping,   increments = myIncrements,   cohort_size = mySize,   data = emptydata,   startingDose = 3 )  ## define the true function myTruth <- probFunction(model, alpha0 = 7, alpha1 = 8)  # Run the simulation on the desired design # We only generate 1 trial outcomes here for illustration, for the actual study # this should be increased of course options <- McmcOptions(   burnin = 100,   step = 2,   samples = 1000 ) time <- system.time(   mySims <- simulate(     design,     args = NULL,     truth = myTruth,     nsim = 1,     seed = 819,     mcmcOptions = options,     parallel = FALSE,     derive = list(       max_mtd = max,       mean_mtd = mean,       median_mtd = median     ),   ) )[3]  # Summarize the Results of the Simulations summary(mySims, truth = myTruth) #> Summary of 1 simulations #>  #> Target toxicity interval was 20, 35 % #> Target dose interval corresponding to this was 19.6, 21.6  #> Intervals are corresponding to 10 and 90 % quantiles #>  #> Number of patients overall : mean 16 (16, 16)  #> Number of patients treated above target tox interval : mean 9 (9, 9)  #> Proportions of DLTs in the trials : mean 38 % (38 %, 38 %)  #> Mean toxicity risks for the patients on active : mean 41 % (41 %, 41 %)  #> Doses selected as MTD : mean 15 (15, 15)  #> True toxicity at doses selected : mean 3 % (3 %, 3 %)  #> Proportion of trials selecting target MTD: 0 % #> Dose most often selected as MTD: 15  #> Observed toxicity rate at dose most often selected: NaN % #> Fitted toxicity rate at dose most often selected : mean 27 % (27 %, 27 %)  #> max_mtd : 57.21  #> mean_mtd : 16.59  #> median_mtd : 15.68  #> Stop reason triggered: #>  ≥ 3 cohorts dosed :  100 % #>  P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5 :  100 % #>  ≥ 20 patients dosed :  0 %  # nolint end"},{"path":"https://openpharma.github.io/crmPack/reference/tidy.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidying CrmPackClass objects — tidy","title":"Tidying CrmPackClass objects — tidy","text":"spirit broom package, provide method convert CrmPackClass object (list ) tibbles. Following principles broom package, convert CrmPackClass object (list ) tibbles.  basic, default representation.  method tidies GeneralData object.  method tidies DataGrouped object.  method tidies DataDA object.  method tidies DataDual object.  method tidies DataParts object.  method tidies DataMixture object.  method tidies DataOrdinal object.  method tidies LogisticIndepBeta object.  method tidies Effloglog object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/tidy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tidying CrmPackClass objects — tidy","text":"","code":"tidy(x, ...)  # S4 method for class 'CrmPackClass' tidy(x, ...)  # S4 method for class 'GeneralData' tidy(x, ...)  # S4 method for class 'DataGrouped' tidy(x, ...)  # S4 method for class 'DataDA' tidy(x, ...)  # S4 method for class 'DataDual' tidy(x, ...)  # S4 method for class 'DataParts' tidy(x, ...)  # S4 method for class 'DataMixture' tidy(x, ...)  # S4 method for class 'DataOrdinal' tidy(x, ...)  # S4 method for class 'Simulations' tidy(x, ...)  # S4 method for class 'LogisticIndepBeta' tidy(x, ...)  # S4 method for class 'Effloglog' tidy(x, ...)  # S4 method for class 'IncrementsMaxToxProb' tidy(x, ...)  # S4 method for class 'IncrementsRelative' tidy(x, ...)  # S4 method for class 'CohortSizeDLT' tidy(x, ...)  # S4 method for class 'CohortSizeMin' tidy(x, ...)  # S4 method for class 'CohortSizeMax' tidy(x, ...)  # S4 method for class 'CohortSizeRange' tidy(x, ...)  # S4 method for class 'CohortSizeParts' tidy(x, ...)  # S4 method for class 'IncrementsMin' tidy(x, ...)  # S4 method for class 'IncrementsRelative' tidy(x, ...)  # S4 method for class 'IncrementsRelativeDLT' tidy(x, ...)  # S4 method for class 'IncrementsRelativeParts' tidy(x, ...)  # S4 method for class 'NextBestNCRM' tidy(x, ...)  # S4 method for class 'NextBestNCRMLoss' tidy(x, ...)  # S4 method for class 'DualDesign' tidy(x, ...)  # S4 method for class 'Samples' tidy(x, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/tidy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tidying CrmPackClass objects — tidy","text":"x (CrmPackClass) object tidied. ... potentially used class-specific methods.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/tidy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tidying CrmPackClass objects — tidy","text":"(list ) tibble(s) representing object tidy form. tibble::tibble object. tibble::tibble object. tibble::tibble object. tibble::tibble object. tibble::tibble object. tibble::tibble object. tibble::tibble object. list tibble::tibble objects. list tibble::tibble objects.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/tidy.html","id":"usage-notes","dir":"Reference","previous_headings":"","what":"Usage Notes","title":"Tidying CrmPackClass objects — tidy","text":"prior observations indicated Cohort value 0 returned tibble.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/tidy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tidying CrmPackClass objects — tidy","text":"","code":"CohortSizeConst(3) %>% tidy() #> # A tibble: 1 × 1 #>    size #>   <int> #> 1     3 .DefaultData() %>% tidy() .DefaultDataOrdinal() %>% tidy() #> # A tibble: 10 × 11 #>       ID Cohort  Dose Placebo  NObs NGrid DoseGrid   XLevel Cat0  Cat1  Cat2  #>    <int>  <int> <dbl> <lgl>   <int> <int> <list>      <int> <lgl> <lgl> <lgl> #>  1     1      1    10 FALSE      10    10 <dbl [10]>      1 TRUE  FALSE FALSE #>  2     2      2    20 FALSE      10    10 <dbl [10]>      2 TRUE  FALSE FALSE #>  3     3      3    30 FALSE      10    10 <dbl [10]>      3 TRUE  FALSE FALSE #>  4     4      4    40 FALSE      10    10 <dbl [10]>      4 TRUE  FALSE FALSE #>  5     5      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  6     6      5    50 FALSE      10    10 <dbl [10]>      5 FALSE TRUE  FALSE #>  7     7      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  8     8      6    60 FALSE      10    10 <dbl [10]>      6 TRUE  FALSE FALSE #>  9     9      6    60 FALSE      10    10 <dbl [10]>      6 FALSE TRUE  FALSE #> 10    10      6    60 FALSE      10    10 <dbl [10]>      6 FALSE FALSE TRUE  .DefaultDataGrouped() %>% tidy() #> # A tibble: 3 × 10 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid   Group #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>     <fct> #> 1     1      1     1      1 FALSE FALSE       3    11 <dbl [11]> mono  #> 2     2      2     3      2 FALSE FALSE       3    11 <dbl [11]> mono  #> 3     3      3     5      3 FALSE FALSE       3    11 <dbl [11]> combo .DefaultDataDA() %>% tidy() #> # A tibble: 8 × 12 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid     U    T0  TMax #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>   <dbl> <dbl> <dbl> #> 1     1      1   0.1      1 FALSE FALSE       8    41 <dbl>       42     0    60 #> 2     2      2   0.5      2 FALSE FALSE       8    41 <dbl>       30    15    60 #> 3     3      3   1.5      3 TRUE  FALSE       8    41 <dbl>       15    30    60 #> 4     4      4   3        4 TRUE  FALSE       8    41 <dbl>        5    40    60 #> 5     5      5   6        5 FALSE FALSE       8    41 <dbl>       20    55    60 #> 6     6      6  10        6 FALSE FALSE       8    41 <dbl>       25    70    60 #> 7     7      6  10        6 TRUE  FALSE       8    41 <dbl>       30    75    60 #> 8     8      6  10        6 FALSE FALSE       8    41 <dbl>       60    85    60 .DefaultData() %>% tidy() .DefaultDataOrdinal() %>% tidy() #> # A tibble: 10 × 11 #>       ID Cohort  Dose Placebo  NObs NGrid DoseGrid   XLevel Cat0  Cat1  Cat2  #>    <int>  <int> <dbl> <lgl>   <int> <int> <list>      <int> <lgl> <lgl> <lgl> #>  1     1      1    10 FALSE      10    10 <dbl [10]>      1 TRUE  FALSE FALSE #>  2     2      2    20 FALSE      10    10 <dbl [10]>      2 TRUE  FALSE FALSE #>  3     3      3    30 FALSE      10    10 <dbl [10]>      3 TRUE  FALSE FALSE #>  4     4      4    40 FALSE      10    10 <dbl [10]>      4 TRUE  FALSE FALSE #>  5     5      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  6     6      5    50 FALSE      10    10 <dbl [10]>      5 FALSE TRUE  FALSE #>  7     7      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  8     8      6    60 FALSE      10    10 <dbl [10]>      6 TRUE  FALSE FALSE #>  9     9      6    60 FALSE      10    10 <dbl [10]>      6 FALSE TRUE  FALSE #> 10    10      6    60 FALSE      10    10 <dbl [10]>      6 FALSE FALSE TRUE  .DefaultDataGrouped() %>% tidy() #> # A tibble: 3 × 10 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid   Group #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>     <fct> #> 1     1      1     1      1 FALSE FALSE       3    11 <dbl [11]> mono  #> 2     2      2     3      2 FALSE FALSE       3    11 <dbl [11]> mono  #> 3     3      3     5      3 FALSE FALSE       3    11 <dbl [11]> combo .DefaultDataDA() %>% tidy() #> # A tibble: 8 × 12 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid     U    T0  TMax #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>   <dbl> <dbl> <dbl> #> 1     1      1   0.1      1 FALSE FALSE       8    41 <dbl>       42     0    60 #> 2     2      2   0.5      2 FALSE FALSE       8    41 <dbl>       30    15    60 #> 3     3      3   1.5      3 TRUE  FALSE       8    41 <dbl>       15    30    60 #> 4     4      4   3        4 TRUE  FALSE       8    41 <dbl>        5    40    60 #> 5     5      5   6        5 FALSE FALSE       8    41 <dbl>       20    55    60 #> 6     6      6  10        6 FALSE FALSE       8    41 <dbl>       25    70    60 #> 7     7      6  10        6 TRUE  FALSE       8    41 <dbl>       30    75    60 #> 8     8      6  10        6 FALSE FALSE       8    41 <dbl>       60    85    60 .DefaultData() %>% tidy() .DefaultDataOrdinal() %>% tidy() #> # A tibble: 10 × 11 #>       ID Cohort  Dose Placebo  NObs NGrid DoseGrid   XLevel Cat0  Cat1  Cat2  #>    <int>  <int> <dbl> <lgl>   <int> <int> <list>      <int> <lgl> <lgl> <lgl> #>  1     1      1    10 FALSE      10    10 <dbl [10]>      1 TRUE  FALSE FALSE #>  2     2      2    20 FALSE      10    10 <dbl [10]>      2 TRUE  FALSE FALSE #>  3     3      3    30 FALSE      10    10 <dbl [10]>      3 TRUE  FALSE FALSE #>  4     4      4    40 FALSE      10    10 <dbl [10]>      4 TRUE  FALSE FALSE #>  5     5      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  6     6      5    50 FALSE      10    10 <dbl [10]>      5 FALSE TRUE  FALSE #>  7     7      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  8     8      6    60 FALSE      10    10 <dbl [10]>      6 TRUE  FALSE FALSE #>  9     9      6    60 FALSE      10    10 <dbl [10]>      6 FALSE TRUE  FALSE #> 10    10      6    60 FALSE      10    10 <dbl [10]>      6 FALSE FALSE TRUE  .DefaultDataGrouped() %>% tidy() #> # A tibble: 3 × 10 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid   Group #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>     <fct> #> 1     1      1     1      1 FALSE FALSE       3    11 <dbl [11]> mono  #> 2     2      2     3      2 FALSE FALSE       3    11 <dbl [11]> mono  #> 3     3      3     5      3 FALSE FALSE       3    11 <dbl [11]> combo .DefaultDataDA() %>% tidy() #> # A tibble: 8 × 12 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid     U    T0  TMax #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>   <dbl> <dbl> <dbl> #> 1     1      1   0.1      1 FALSE FALSE       8    41 <dbl>       42     0    60 #> 2     2      2   0.5      2 FALSE FALSE       8    41 <dbl>       30    15    60 #> 3     3      3   1.5      3 TRUE  FALSE       8    41 <dbl>       15    30    60 #> 4     4      4   3        4 TRUE  FALSE       8    41 <dbl>        5    40    60 #> 5     5      5   6        5 FALSE FALSE       8    41 <dbl>       20    55    60 #> 6     6      6  10        6 FALSE FALSE       8    41 <dbl>       25    70    60 #> 7     7      6  10        6 TRUE  FALSE       8    41 <dbl>       30    75    60 #> 8     8      6  10        6 FALSE FALSE       8    41 <dbl>       60    85    60 .DefaultData() %>% tidy() .DefaultDataOrdinal() %>% tidy() #> # A tibble: 10 × 11 #>       ID Cohort  Dose Placebo  NObs NGrid DoseGrid   XLevel Cat0  Cat1  Cat2  #>    <int>  <int> <dbl> <lgl>   <int> <int> <list>      <int> <lgl> <lgl> <lgl> #>  1     1      1    10 FALSE      10    10 <dbl [10]>      1 TRUE  FALSE FALSE #>  2     2      2    20 FALSE      10    10 <dbl [10]>      2 TRUE  FALSE FALSE #>  3     3      3    30 FALSE      10    10 <dbl [10]>      3 TRUE  FALSE FALSE #>  4     4      4    40 FALSE      10    10 <dbl [10]>      4 TRUE  FALSE FALSE #>  5     5      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  6     6      5    50 FALSE      10    10 <dbl [10]>      5 FALSE TRUE  FALSE #>  7     7      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  8     8      6    60 FALSE      10    10 <dbl [10]>      6 TRUE  FALSE FALSE #>  9     9      6    60 FALSE      10    10 <dbl [10]>      6 FALSE TRUE  FALSE #> 10    10      6    60 FALSE      10    10 <dbl [10]>      6 FALSE FALSE TRUE  .DefaultDataGrouped() %>% tidy() #> # A tibble: 3 × 10 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid   Group #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>     <fct> #> 1     1      1     1      1 FALSE FALSE       3    11 <dbl [11]> mono  #> 2     2      2     3      2 FALSE FALSE       3    11 <dbl [11]> mono  #> 3     3      3     5      3 FALSE FALSE       3    11 <dbl [11]> combo .DefaultDataDA() %>% tidy() #> # A tibble: 8 × 12 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid     U    T0  TMax #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>   <dbl> <dbl> <dbl> #> 1     1      1   0.1      1 FALSE FALSE       8    41 <dbl>       42     0    60 #> 2     2      2   0.5      2 FALSE FALSE       8    41 <dbl>       30    15    60 #> 3     3      3   1.5      3 TRUE  FALSE       8    41 <dbl>       15    30    60 #> 4     4      4   3        4 TRUE  FALSE       8    41 <dbl>        5    40    60 #> 5     5      5   6        5 FALSE FALSE       8    41 <dbl>       20    55    60 #> 6     6      6  10        6 FALSE FALSE       8    41 <dbl>       25    70    60 #> 7     7      6  10        6 TRUE  FALSE       8    41 <dbl>       30    75    60 #> 8     8      6  10        6 FALSE FALSE       8    41 <dbl>       60    85    60 .DefaultData() %>% tidy() .DefaultDataOrdinal() %>% tidy() #> # A tibble: 10 × 11 #>       ID Cohort  Dose Placebo  NObs NGrid DoseGrid   XLevel Cat0  Cat1  Cat2  #>    <int>  <int> <dbl> <lgl>   <int> <int> <list>      <int> <lgl> <lgl> <lgl> #>  1     1      1    10 FALSE      10    10 <dbl [10]>      1 TRUE  FALSE FALSE #>  2     2      2    20 FALSE      10    10 <dbl [10]>      2 TRUE  FALSE FALSE #>  3     3      3    30 FALSE      10    10 <dbl [10]>      3 TRUE  FALSE FALSE #>  4     4      4    40 FALSE      10    10 <dbl [10]>      4 TRUE  FALSE FALSE #>  5     5      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  6     6      5    50 FALSE      10    10 <dbl [10]>      5 FALSE TRUE  FALSE #>  7     7      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  8     8      6    60 FALSE      10    10 <dbl [10]>      6 TRUE  FALSE FALSE #>  9     9      6    60 FALSE      10    10 <dbl [10]>      6 FALSE TRUE  FALSE #> 10    10      6    60 FALSE      10    10 <dbl [10]>      6 FALSE FALSE TRUE  .DefaultDataGrouped() %>% tidy() #> # A tibble: 3 × 10 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid   Group #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>     <fct> #> 1     1      1     1      1 FALSE FALSE       3    11 <dbl [11]> mono  #> 2     2      2     3      2 FALSE FALSE       3    11 <dbl [11]> mono  #> 3     3      3     5      3 FALSE FALSE       3    11 <dbl [11]> combo .DefaultDataDA() %>% tidy() #> # A tibble: 8 × 12 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid     U    T0  TMax #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>   <dbl> <dbl> <dbl> #> 1     1      1   0.1      1 FALSE FALSE       8    41 <dbl>       42     0    60 #> 2     2      2   0.5      2 FALSE FALSE       8    41 <dbl>       30    15    60 #> 3     3      3   1.5      3 TRUE  FALSE       8    41 <dbl>       15    30    60 #> 4     4      4   3        4 TRUE  FALSE       8    41 <dbl>        5    40    60 #> 5     5      5   6        5 FALSE FALSE       8    41 <dbl>       20    55    60 #> 6     6      6  10        6 FALSE FALSE       8    41 <dbl>       25    70    60 #> 7     7      6  10        6 TRUE  FALSE       8    41 <dbl>       30    75    60 #> 8     8      6  10        6 FALSE FALSE       8    41 <dbl>       60    85    60 .DefaultData() %>% tidy() .DefaultDataOrdinal() %>% tidy() #> # A tibble: 10 × 11 #>       ID Cohort  Dose Placebo  NObs NGrid DoseGrid   XLevel Cat0  Cat1  Cat2  #>    <int>  <int> <dbl> <lgl>   <int> <int> <list>      <int> <lgl> <lgl> <lgl> #>  1     1      1    10 FALSE      10    10 <dbl [10]>      1 TRUE  FALSE FALSE #>  2     2      2    20 FALSE      10    10 <dbl [10]>      2 TRUE  FALSE FALSE #>  3     3      3    30 FALSE      10    10 <dbl [10]>      3 TRUE  FALSE FALSE #>  4     4      4    40 FALSE      10    10 <dbl [10]>      4 TRUE  FALSE FALSE #>  5     5      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  6     6      5    50 FALSE      10    10 <dbl [10]>      5 FALSE TRUE  FALSE #>  7     7      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  8     8      6    60 FALSE      10    10 <dbl [10]>      6 TRUE  FALSE FALSE #>  9     9      6    60 FALSE      10    10 <dbl [10]>      6 FALSE TRUE  FALSE #> 10    10      6    60 FALSE      10    10 <dbl [10]>      6 FALSE FALSE TRUE  .DefaultDataGrouped() %>% tidy() #> # A tibble: 3 × 10 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid   Group #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>     <fct> #> 1     1      1     1      1 FALSE FALSE       3    11 <dbl [11]> mono  #> 2     2      2     3      2 FALSE FALSE       3    11 <dbl [11]> mono  #> 3     3      3     5      3 FALSE FALSE       3    11 <dbl [11]> combo .DefaultDataDA() %>% tidy() #> # A tibble: 8 × 12 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid     U    T0  TMax #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>   <dbl> <dbl> <dbl> #> 1     1      1   0.1      1 FALSE FALSE       8    41 <dbl>       42     0    60 #> 2     2      2   0.5      2 FALSE FALSE       8    41 <dbl>       30    15    60 #> 3     3      3   1.5      3 TRUE  FALSE       8    41 <dbl>       15    30    60 #> 4     4      4   3        4 TRUE  FALSE       8    41 <dbl>        5    40    60 #> 5     5      5   6        5 FALSE FALSE       8    41 <dbl>       20    55    60 #> 6     6      6  10        6 FALSE FALSE       8    41 <dbl>       25    70    60 #> 7     7      6  10        6 TRUE  FALSE       8    41 <dbl>       30    75    60 #> 8     8      6  10        6 FALSE FALSE       8    41 <dbl>       60    85    60 .DefaultData() %>% tidy() .DefaultDataOrdinal() %>% tidy() #> # A tibble: 10 × 11 #>       ID Cohort  Dose Placebo  NObs NGrid DoseGrid   XLevel Cat0  Cat1  Cat2  #>    <int>  <int> <dbl> <lgl>   <int> <int> <list>      <int> <lgl> <lgl> <lgl> #>  1     1      1    10 FALSE      10    10 <dbl [10]>      1 TRUE  FALSE FALSE #>  2     2      2    20 FALSE      10    10 <dbl [10]>      2 TRUE  FALSE FALSE #>  3     3      3    30 FALSE      10    10 <dbl [10]>      3 TRUE  FALSE FALSE #>  4     4      4    40 FALSE      10    10 <dbl [10]>      4 TRUE  FALSE FALSE #>  5     5      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  6     6      5    50 FALSE      10    10 <dbl [10]>      5 FALSE TRUE  FALSE #>  7     7      5    50 FALSE      10    10 <dbl [10]>      5 TRUE  FALSE FALSE #>  8     8      6    60 FALSE      10    10 <dbl [10]>      6 TRUE  FALSE FALSE #>  9     9      6    60 FALSE      10    10 <dbl [10]>      6 FALSE TRUE  FALSE #> 10    10      6    60 FALSE      10    10 <dbl [10]>      6 FALSE FALSE TRUE  .DefaultDataGrouped() %>% tidy() #> # A tibble: 3 × 10 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid   Group #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>     <fct> #> 1     1      1     1      1 FALSE FALSE       3    11 <dbl [11]> mono  #> 2     2      2     3      2 FALSE FALSE       3    11 <dbl [11]> mono  #> 3     3      3     5      3 FALSE FALSE       3    11 <dbl [11]> combo .DefaultDataDA() %>% tidy() #> # A tibble: 8 × 12 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid     U    T0  TMax #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>   <dbl> <dbl> <dbl> #> 1     1      1   0.1      1 FALSE FALSE       8    41 <dbl>       42     0    60 #> 2     2      2   0.5      2 FALSE FALSE       8    41 <dbl>       30    15    60 #> 3     3      3   1.5      3 TRUE  FALSE       8    41 <dbl>       15    30    60 #> 4     4      4   3        4 TRUE  FALSE       8    41 <dbl>        5    40    60 #> 5     5      5   6        5 FALSE FALSE       8    41 <dbl>       20    55    60 #> 6     6      6  10        6 FALSE FALSE       8    41 <dbl>       25    70    60 #> 7     7      6  10        6 TRUE  FALSE       8    41 <dbl>       30    75    60 #> 8     8      6  10        6 FALSE FALSE       8    41 <dbl>       60    85    60 .DefaultSimulations() %>% tidy() #> $fit #> $fit[[1]] #>        middle        lower     upper #> 1  0.04693896 0.0005215131 0.2149296 #> 2  0.09087797 0.0049284446 0.2934208 #> 3  0.12709154 0.0133276184 0.3478543 #> 4  0.20529673 0.0447701741 0.4333915 #> 5  0.27304163 0.0916535890 0.4850230 #> 6  0.33253652 0.1479780163 0.5387231 #> 7  0.38462951 0.1920009627 0.5948274 #> 8  0.50414036 0.2807141050 0.7073378 #> 9  0.56079474 0.3179473404 0.7816701 #> 10 0.66841307 0.4047515390 0.8918444 #> 11 0.71170065 0.4321206588 0.9245487 #>  #>  #> $stop_report #> # A tibble: 1 × 1 #>   stop_report[,NA] [,NA] [,\"≥ 3 cohorts dosed\"] [,\"P(0.2 ≤ prob(DLE | NBD) ≤ 0…¹ #>   <lgl>            <lgl> <lgl>                  <lgl>                            #> 1 TRUE             TRUE  TRUE                   TRUE                             #> # ℹ abbreviated name: ¹​[,\"P(0.2 ≤ prob(DLE | NBD) ≤ 0.35) ≥ 0.5\"] #> # ℹ 1 more variable: stop_report[5] <lgl> #>  #> $data #> $data[[1]] #> # A tibble: 16 × 9 #>       ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid   #>    <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>     #>  1     1      1     3      2 FALSE FALSE      16    11 <dbl [11]> #>  2     2      2     5      3 FALSE FALSE      16    11 <dbl [11]> #>  3     3      3    10      4 FALSE FALSE      16    11 <dbl [11]> #>  4     4      4    20      6 TRUE  FALSE      16    11 <dbl [11]> #>  5     5      5    20      6 FALSE FALSE      16    11 <dbl [11]> #>  6     6      5    20      6 FALSE FALSE      16    11 <dbl [11]> #>  7     7      5    20      6 FALSE FALSE      16    11 <dbl [11]> #>  8     8      6    25      7 FALSE FALSE      16    11 <dbl [11]> #>  9     9      6    25      7 TRUE  FALSE      16    11 <dbl [11]> #> 10    10      6    25      7 FALSE FALSE      16    11 <dbl [11]> #> 11    11      7    25      7 FALSE FALSE      16    11 <dbl [11]> #> 12    12      7    25      7 TRUE  FALSE      16    11 <dbl [11]> #> 13    13      7    25      7 FALSE FALSE      16    11 <dbl [11]> #> 14    14      8    25      7 TRUE  FALSE      16    11 <dbl [11]> #> 15    15      8    25      7 TRUE  FALSE      16    11 <dbl [11]> #> 16    16      8    25      7 TRUE  FALSE      16    11 <dbl [11]> #>  #>  #> $doses #> # A tibble: 1 × 1 #>   doses #>   <dbl> #> 1    15 #>  #> $seed #> # A tibble: 1 × 1 #>    seed #>   <int> #> 1   819 #>  #> attr(,\"class\") #> [1] \"tbl_Simulations\" \"list\"            .DefaultLogisticIndepBeta() %>% tidy() #> $pseudoData #> # A tibble: 2 × 3 #>    Dose     N   Tox #>   <dbl> <int> <dbl> #> 1    25     3  1.05 #> 2   300     3  1.8  #>  #> $data #> # A tibble: 0 × 9 #> # ℹ 9 variables: ID <int>, Cohort <int>, Dose <dbl>, XLevel <int>, Tox <lgl>, #> #   Placebo <lgl>, NObs <int>, NGrid <int>, DoseGrid <list> #>  #> $params #> # A tibble: 2 × 3 #>   Param   mean cov           #>   <chr>  <dbl> <named list>  #> 1 Phi1  -1.95  <dbl [2 × 2]> #> 2 Phi2   0.412 <dbl [2 × 2]> #>  #> attr(,\"class\") #> [1] \"tbl_LogisticIndepBeta\" \"list\"                  .DefaultEffloglog() %>% tidy() #> $pseudoData #> # A tibble: 2 × 2 #>    Dose Response #>   <dbl>    <dbl> #> 1    25     1.22 #> 2   300     2.51 #>  #> $data #> # A tibble: 8 × 10 #>      ID Cohort  Dose XLevel Tox   Placebo  NObs NGrid DoseGrid       W #>   <int>  <int> <dbl>  <int> <lgl> <lgl>   <int> <int> <list>     <dbl> #> 1     1      1    25      1 FALSE FALSE       8    12 <dbl [12]>  0.31 #> 2     2      2    50      2 FALSE FALSE       8    12 <dbl [12]>  0.42 #> 3     3      2    50      2 FALSE FALSE       8    12 <dbl [12]>  0.59 #> 4     4      3    75      3 FALSE FALSE       8    12 <dbl [12]>  0.45 #> 5     5      4   100      4 TRUE  FALSE       8    12 <dbl [12]>  0.6  #> 6     6      4   100      4 TRUE  FALSE       8    12 <dbl [12]>  0.7  #> 7     7      5   225      9 TRUE  FALSE       8    12 <dbl [12]>  0.6  #> 8     8      6   300     12 TRUE  FALSE       8    12 <dbl [12]>  0.52 #>  #> $params #> # A tibble: 2 × 3 #>   Param   mean cov           #>   <chr>  <dbl> <named list>  #> 1 theta1 -2.82 <dbl [2 × 2]> #> 2 theta2  2.71 <dbl [2 × 2]> #>  #> attr(,\"class\") #> [1] \"tbl_Effloglog\" \"list\"          IncrementsMaxToxProb(prob = c(\"DLAE\" = 0.2, \"CRS\" = 0.05)) %>% tidy() #> # A tibble: 2 × 2 #>   Grade  Prob #>   <chr> <dbl> #> 1 DLAE   0.2  #> 2 CRS    0.05 CohortSizeRange(intervals = c(0, 20), cohort_size = c(1, 3)) %>% tidy() #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0    20           1 #> 2    20   Inf           3 .DefaultCohortSizeDLT() %>% tidy() #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0     1           1 #> 2     1   Inf           3 .DefaultCohortSizeMin() %>% tidy() #> [[1]] #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0    10           1 #> 2    10   Inf           3 #>  #> [[2]] #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0     1           1 #> 2     1   Inf           3 #>  #> attr(,\"class\") #> [1] \"tbl_CohortSizeMin\" \"tbl_CohortSizeMin\" \"list\"              .DefaultCohortSizeMax() %>% tidy() #> [[1]] #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0    10           1 #> 2    10   Inf           3 #>  #> [[2]] #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0     1           1 #> 2     1   Inf           3 #>  #> attr(,\"class\") #> [1] \"tbl_CohortSizeMax\" \"tbl_CohortSizeMax\" \"list\"              .DefaultCohortSizeRange() %>% tidy() #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0    30           1 #> 2    30   Inf           3 CohortSizeParts(cohort_sizes = c(1, 3)) %>% tidy() #> # A tibble: 2 × 2 #>    part cohort_size #>   <int>       <int> #> 1     1           1 #> 2     2           3 .DefaultIncrementsMin() %>% tidy() #> [[1]] #> # A tibble: 3 × 3 #>     min   max increment #>   <dbl> <dbl>     <dbl> #> 1     0     1      1    #> 2     1     3      0.33 #> 3     3   Inf      0.2  #>  #> [[2]] #> # A tibble: 2 × 3 #>     min   max increment #>   <dbl> <dbl>     <dbl> #> 1     0    20      1    #> 2    20   Inf      0.33 #>  #> attr(,\"class\") #> [1] \"tbl_IncrementsMin\" \"tbl_IncrementsMin\" \"list\"              CohortSizeRange(intervals = c(0, 20), cohort_size = c(1, 3)) %>% tidy() #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0    20           1 #> 2    20   Inf           3 x <- .DefaultIncrementsRelativeDLT() x %>% tidy() #> # A tibble: 3 × 3 #>     min   max increment #>   <dbl> <dbl>     <dbl> #> 1     0     1      1    #> 2     1     3      0.33 #> 3     3   Inf      0.2  .DefaultIncrementsRelativeParts() %>% tidy() #> $dlt_start #> # A tibble: 1 × 1 #>   dlt_start #>       <int> #> 1         0 #>  #> $clean_start #> # A tibble: 1 × 1 #>   clean_start #>         <int> #> 1           1 #>  #> $intervals #> # A tibble: 2 × 1 #>   intervals #>       <dbl> #> 1         0 #> 2         2 #>  #> $increments #> # A tibble: 2 × 1 #>   increments #>        <dbl> #> 1          2 #> 2          1 #>  #> attr(,\"class\") #> [1] \"tbl_IncrementsRelativeParts\" \"list\"                        NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 ) %>%   tidy() #> # A tibble: 3 × 4 #>   Range       min   max max_prob #>   <chr>     <dbl> <dbl>    <dbl> #> 1 Underdose  0     0.2     NA    #> 2 Target     0.2   0.35    NA    #> 3 Overdose   0.35  1        0.25 .DefaultNextBestNCRMLoss() %>% tidy() #> # A tibble: 4 × 5 #>   Range        Lower Upper LossCoefficient MaxOverdoseProb #>   <chr>        <dbl> <dbl>           <dbl>           <dbl> #> 1 Underdose     0     0.2                1            0.25 #> 2 Target        0.2   0.35               0            0.25 #> 3 Overdose      0.35  0.6                1            0.25 #> 4 Unacceptable  0.6   1                  2            0.25 .DefaultDualDesign() %>% tidy() #> $model #> $sigma2betaW #> # A tibble: 1 × 1 #>   sigma2betaW #>         <dbl> #> 1        0.01 #>  #> $rw1 #> # A tibble: 1 × 1 #>   rw1   #>   <lgl> #> 1 TRUE  #>  #> $betaZ_params #> # A tibble: 2 × 3 #>    mean cov[,1]  [,2] prec[,1]  [,2] #>   <dbl>   <dbl> <dbl>    <dbl> <dbl> #> 1     0       1     0        1     0 #> 2     1       0     1        0     1 #>  #> $ref_dose #> # A tibble: 1 × 1 #>   ref_dose   #>   <pstv_nmb> #> 1 1          #>  #> $use_log_dose #> # A tibble: 1 × 1 #>   use_log_dose #>   <lgl>        #> 1 FALSE        #>  #> $sigma2W #> # A tibble: 2 × 1 #>   sigma2W #>     <dbl> #> 1     0.1 #> 2     0.1 #>  #> $rho #> # A tibble: 2 × 1 #>     rho #>   <dbl> #> 1     1 #> 2     1 #>  #> $use_fixed #> # A tibble: 3 × 1 #>   use_fixed #>   <lgl>     #> 1 FALSE     #> 2 FALSE     #> 3 TRUE      #>  #> $datanames #> # A tibble: 5 × 1 #>   datanames #>   <chr>     #> 1 nObs      #> 2 w         #> 3 x         #> 4 xLevel    #> 5 y         #>  #> $datanames_prior #> # A tibble: 2 × 1 #>   datanames_prior #>   <chr>           #> 1 nGrid           #> 2 doseGrid        #>  #> $sample #> # A tibble: 5 × 1 #>   sample #>   <chr>  #> 1 betaZ  #> 2 precW  #> 3 rho    #> 4 betaW  #> 5 delta  #>  #> attr(,\"class\") #> [1] \"tbl_DualEndpointRW\" \"list\"               #>  #> $data #> # A tibble: 0 × 10 #> # ℹ 10 variables: ID <int>, Cohort <int>, Dose <dbl>, XLevel <int>, Tox <lgl>, #> #   Placebo <lgl>, NObs <int>, NGrid <int>, DoseGrid <list>, W <dbl> #>  #> $stopping #> $stop_list #> $stop_list[[1]] #> $target #> # A tibble: 2 × 1 #>   target #>    <dbl> #> 1    0.9 #> 2    1   #>  #> $is_relative #> # A tibble: 1 × 1 #>   is_relative #>   <lgl>       #> 1 TRUE        #>  #> $prob #> # A tibble: 1 × 1 #>    prob #>   <dbl> #> 1   0.5 #>  #> $report_label #> # A tibble: 1 × 1 #>   report_label                            #>   <chr>                                   #> 1 P(0.9 ≤ Biomarker ≤ 1) ≥ 0.5 (relative) #>  #> attr(,\"class\") #> [1] \"tbl_StoppingTargetBiomarker\" \"list\"                        #>  #> $stop_list[[2]] #> # A tibble: 1 × 2 #>   nPatients report_label        #>       <int> <chr>               #> 1        40 ≥ 40 patients dosed #>  #>  #> $report_label #> # A tibble: 1 × 1 #>   report_label #>   <chr>        #> 1 NA           #>  #> attr(,\"class\") #> [1] \"tbl_StoppingAny\" \"list\"            #>  #> $increments #> # A tibble: 2 × 3 #>     min   max increment #>   <dbl> <dbl>     <dbl> #> 1     0    20      1    #> 2    20   Inf      0.33 #>  #> $pl_cohort_size #> # A tibble: 1 × 1 #>    size #>   <int> #> 1     0 #>  #> $nextBest #> $target #> # A tibble: 2 × 1 #>   target #>    <dbl> #> 1    0.9 #> 2    1   #>  #> $overdose #> # A tibble: 2 × 1 #>   overdose #>      <dbl> #> 1     0.35 #> 2     1    #>  #> $max_overdose_prob #> # A tibble: 1 × 1 #>   max_overdose_prob #>               <dbl> #> 1              0.25 #>  #> $target_relative #> # A tibble: 1 × 1 #>   target_relative #>   <lgl>           #> 1 TRUE            #>  #> $target_thresh #> # A tibble: 1 × 1 #>   target_thresh #>           <dbl> #> 1          0.01 #>  #> attr(,\"class\") #> [1] \"tbl_NextBestDualEndpoint\" \"list\"                     #>  #> $cohort_size #> [[1]] #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0    30           1 #> 2    30   Inf           3 #>  #> [[2]] #> # A tibble: 2 × 3 #>     min   max cohort_size #>   <dbl> <dbl>       <int> #> 1     0     1           1 #> 2     1   Inf           3 #>  #> attr(,\"class\") #> [1] \"tbl_CohortSizeMax\" \"tbl_CohortSizeMax\" \"list\"              #>  #> $startingDose #> # A tibble: 1 × 1 #>   startingDose #>          <dbl> #> 1            3 #>  #> attr(,\"class\") #> [1] \"tbl_DualDesign\" \"list\"           options <- McmcOptions(   burnin = 100,   step = 1,   samples = 2000 )  emptydata <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))  model <- LogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56 )  samples <- mcmc(emptydata, model, options) samples %>% tidy() #> $data #> # A tibble: 2,000 × 10 #>    Iteration Chain  alpha0  alpha1 nChains nParameters nIterations nBurnin nThin #>        <int> <int>   <dbl>   <dbl>   <int>       <int>       <int>   <int> <int> #>  1         1     1 -0.715   1.02         1           1        2100     100     1 #>  2         2     1 -0.676   1.42         1           1        2100     100     1 #>  3         3     1 -1.76    5.36         1           1        2100     100     1 #>  4         4     1 -1.19    4.33         1           1        2100     100     1 #>  5         5     1 -1.78    0.962        1           1        2100     100     1 #>  6         6     1 -1.84    4.73         1           1        2100     100     1 #>  7         7     1  0.0402  3.89         1           1        2100     100     1 #>  8         8     1 -0.585   3.54         1           1        2100     100     1 #>  9         9     1 -3.00   16.4          1           1        2100     100     1 #> 10        10     1  1.53    0.0815       1           1        2100     100     1 #> # ℹ 1,990 more rows #> # ℹ 1 more variable: parallel <lgl> #>  #> $options #> # A tibble: 1 × 5 #>   iterations burnin  step rng_kind rng_seed #>        <int>  <int> <int> <chr>       <int> #> 1       2100    100     1 NA             NA #>  #> attr(,\"class\") #> [1] \"tbl_Samples\" \"list\""},{"path":"https://openpharma.github.io/crmPack/reference/update-Data-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating Data Objects — update,Data-method","title":"Updating Data Objects — update,Data-method","text":"method updates existing Data object new data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-Data-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating Data Objects — update,Data-method","text":"","code":"# S4 method for class 'Data' update(   object,   x,   y,   ID = length(object@ID) + seq_along(y),   new_cohort = TRUE,   check = TRUE,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/update-Data-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating Data Objects — update,Data-method","text":"object (Data) object want update. x (number) dose level (one level !). y (integer) DLT vector (0/1 vector) patients cohort. can also supply numeric vectors, converted integer internally. ID (integer) patient IDs. can also supply numeric vectors, converted integer internally. new_cohort (flag) TRUE (default) new data assigned new cohort. check (flag) whether validation updated object conducted. See details . ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-Data-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating Data Objects — update,Data-method","text":"new, updated Data object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-Data-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Updating Data Objects — update,Data-method","text":"current implementation update method allows updating Data class object adding single dose level x . However, might use cases new cohort added contains placebo active dose. Hence, update need performed iteratively calling update method twice. example, first call user can add placebo, second call, active dose. Since cohort placebo allowed, update method normally throw error attempting add placebo first call. allow updates, check parameter set FALSE first call.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-Data-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating Data Objects — update,Data-method","text":"","code":"# Create some data of class 'Data'. my_data <- Data(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data with a new cohort. my_data1 <- update(my_data, x = 20, y = c(0L, 1L, 1L)) my_data1 #> An object of class \"Data\" #> Slot \"x\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 20.0 20.0 20.0 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 0 1 0 0 1 1 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #>  [1]  1  2  3  4  5  6  6  6 11 11 11 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 11 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 6 6 6 7 7 7 #>  #> Slot \"nObs\": #> [1] 11 #>"},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDA-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataDA Objects — update,DataDA-method","title":"Updating DataDA Objects — update,DataDA-method","text":"method updates existing DataDA object new data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDA-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataDA Objects — update,DataDA-method","text":"","code":"# S4 method for class 'DataDA' update(object, u, t0, trialtime, y, ..., check = TRUE)"},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDA-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataDA Objects — update,DataDA-method","text":"object (DataDA) object want update. u (numeric) new DLT free survival times patients, .e. existing patients object well new patients. t0 (numeric) time patient starts DLT observation window. parameter covers patients, .e. existing patients object well new patients. trialtime (number) current time trial, .e. followup time. y (numeric) new DLTs patients, .e. existing patients object well new patients. ... arguments passed Data update method update-Data. used new patients added cohort. check (flag) whether validation updated object conducted. See help update-Data details use case parameter.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDA-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataDA Objects — update,DataDA-method","text":"new, updated DataDA object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDA-method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Updating DataDA Objects — update,DataDA-method","text":"function capable adding new patients also updates existing ones respect y, t0, u slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDA-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataDA Objects — update,DataDA-method","text":"","code":"# Create an object of class 'DataDA'. my_data <- DataDA(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60 ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data. my_data1 <- update(   object = my_data,   y = c(my_data@y, 0), # The 'y' will be updated according to 'u'.   u = c(my_data@u, 20),   t0 = c(my_data@t0, 95),   x = 20,   trialtime = 120 # This is the global timeline for a trial. ) my_data1 #> An object of class \"DataDA\" #> Slot \"u\": #> [1] 42 30 15  5 20 25 30 35 20 #>  #> Slot \"t0\": #> [1]  0 15 30 40 55 70 75 85 95 #>  #> Slot \"Tmax\": #> [1] 60 #>  #> Slot \"x\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 20.0 #>  #> Slot \"y\": #> [1] 0 0 1 1 0 0 1 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1]  1  2  3  4  5  6  6  6 11 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 5 6 7 8 9 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 5 6 6 6 7 #>  #> Slot \"nObs\": #> [1] 9 #>"},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDual-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataDual Objects — update,DataDual-method","title":"Updating DataDual Objects — update,DataDual-method","text":"method updates existing DataDual object new data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDual-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataDual Objects — update,DataDual-method","text":"","code":"# S4 method for class 'DataDual' update(object, w, ..., check = TRUE)"},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDual-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataDual Objects — update,DataDual-method","text":"object (DataDual) object want update. w (numeric) continuous vector biomarker values patients update. ... arguments passed Data update method update-Data. check (flag) whether validation updated object conducted. See help update-Data details use case parameter.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDual-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataDual Objects — update,DataDual-method","text":"new, updated DataDual object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataDual-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataDual Objects — update,DataDual-method","text":"","code":"# Create some data of class 'DataDual'. my_data <- DataDual(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 0, 0, 0, 0, 1, 0),   w = rnorm(8),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data with a new cohort. my_data1 <- update(my_data, x = 20, y = c(0, 1, 1), w = c(0.4, 1.2, 2.2)) my_data1 #> An object of class \"DataDual\" #> Slot \"w\": #>  [1] -0.38377314 -0.20837647 -0.84199596 -0.58915968  0.75582202  0.77971207 #>  [7]  0.53335135 -0.08566696  0.40000000  1.20000000  2.20000000 #>  #> Slot \"x\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 10.0 10.0 20.0 20.0 20.0 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 0 1 0 0 1 1 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #>  [1]  1  2  3  4  5  6  6  6 11 11 11 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 11 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 6 6 6 7 7 7 #>  #> Slot \"nObs\": #> [1] 11 #>"},{"path":"https://openpharma.github.io/crmPack/reference/update-DataOrdinal-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataOrdinal Objects — update,DataOrdinal-method","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"method updates existing DataOrdinal object new data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"","code":"# S4 method for class 'DataOrdinal' update(   object,   x,   y,   ID = length(object@ID) + seq_along(y),   new_cohort = TRUE,   check = TRUE,   ... )"},{"path":"https://openpharma.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"object (DataOrdinal) object want update. x (number) dose level (one level !). y (integer) vector toxicity grades (0, 1, 2, ...) patients cohort. can also supply numeric vectors, converted integer internally. ID (integer) patient IDs. can also supply numeric vectors, converted integer internally. new_cohort (flag) TRUE (default) new data assigned new cohort. check (flag) whether validation updated object conducted. See Details . ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"new, updated DataOrdinal object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"current implementation update method allows updating DataOrdinal class object adding single dose level x . However, might use cases new cohort added contains placebo active dose. Hence, update need performed iteratively calling update method twice. example, first call user can add placebo, second call, active dose. Since cohort placebo allowed, update method normally throw error attempting add placebo first call. allow updates, check parameter set FALSE first call.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataOrdinal-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataOrdinal Objects — update,DataOrdinal-method","text":"","code":"data <- DataOrdinal(   x = c(10, 20, 30, 40, 50, 50, 50, 60, 60, 60),   y = as.integer(c(0, 0, 0, 0, 0, 1, 0, 0, 1, 2)),   ID = 1L:10L,   cohort = as.integer(c(1:4, 5, 5, 5, 6, 6, 6)),   doseGrid = c(seq(from = 10, to = 100, by = 10)),   yCategories = c(\"No tox\" = 0L, \"Sub-tox AE\" = 1L, \"DLT\" = 2L),   placebo = FALSE )  update(data, x = 70, y = c(1L, 2L, 1L)) #> An object of class \"DataOrdinal\" #> Slot \"x\": #>  [1] 10 20 30 40 50 50 50 60 60 60 70 70 70 #>  #> Slot \"y\": #>  [1] 0 0 0 0 0 1 0 0 1 2 1 2 1 #>  #> Slot \"doseGrid\": #>  [1]  10  20  30  40  50  60  70  80  90 100 #>  #> Slot \"nGrid\": #> [1] 10 #>  #> Slot \"xLevel\": #>  [1] 1 2 3 4 5 5 5 6 6 6 7 7 7 #>  #> Slot \"yCategories\": #>     No tox Sub-tox AE        DLT  #>          0          1          2  #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 #>  #> Slot \"cohort\": #>  [1] 1 2 3 4 5 5 5 6 6 6 7 7 7 #>  #> Slot \"nObs\": #> [1] 13 #>"},{"path":"https://openpharma.github.io/crmPack/reference/update-DataParts-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating DataParts Objects — update,DataParts-method","title":"Updating DataParts Objects — update,DataParts-method","text":"method updates existing DataParts object new data.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataParts-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating DataParts Objects — update,DataParts-method","text":"","code":"# S4 method for class 'DataParts' update(object, x, y, ..., check = TRUE)"},{"path":"https://openpharma.github.io/crmPack/reference/update-DataParts-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating DataParts Objects — update,DataParts-method","text":"object (DataParts) object want update. x (number) dose level (one level !). y (integer) DLT vector (0/1 vector) patients cohort. can also supply numeric vectors, converted integer internally. ... arguments passed Data update method update-Data. check (flag) whether validation updated object conducted. See help update-Data details use case parameter.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataParts-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating DataParts Objects — update,DataParts-method","text":"new, updated DataParts object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-DataParts-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Updating DataParts Objects — update,DataParts-method","text":"","code":"# Create an object of class 'DataParts'. my_data <- DataParts(   x = c(0.1, 0.5, 1.5),   y = c(0, 0, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   part = c(1L, 1L, 1L),   nextPart = 1L,   part1Ladder = c(0.1, 0.5, 1.5, 3, 6, 10) ) #> Used default patient IDs! #> Used best guess cohort indices!  # Update the data with a new cohort. # Note that since we reached the last level from 'part1Ladder' # then the 'nextPart' is switched from '1' to '2'. my_data1 <- update(my_data, x = 10, y = 0L) my_data1 #> An object of class \"DataParts\" #> Slot \"part\": #> [1] 1 1 1 1 #>  #> Slot \"nextPart\": #> [1] 2 #>  #> Slot \"part1Ladder\": #> [1]  0.1  0.5  1.5  3.0  6.0 10.0 #>  #> Slot \"x\": #> [1]  0.1  0.5  1.5 10.0 #>  #> Slot \"y\": #> [1] 0 0 0 0 #>  #> Slot \"doseGrid\": #>  [1]  0.1  0.5  1.5  3.0  6.0 10.0 12.0 14.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 #> [16] 30.0 32.0 34.0 36.0 38.0 40.0 42.0 44.0 46.0 48.0 50.0 52.0 54.0 56.0 58.0 #> [31] 60.0 62.0 64.0 66.0 68.0 70.0 72.0 74.0 76.0 78.0 80.0 #>  #> Slot \"nGrid\": #> [1] 41 #>  #> Slot \"xLevel\": #> [1] 1 2 3 6 #>  #> Slot \"placebo\": #> [1] FALSE #>  #> Slot \"ID\": #> [1] 1 2 3 4 #>  #> Slot \"cohort\": #> [1] 1 2 3 4 #>  #> Slot \"nObs\": #> [1] 4 #>"},{"path":"https://openpharma.github.io/crmPack/reference/update-ModelPseudo-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Update method for the ModelPseudo model class. This is a method to update the model class slots (estimates, parameters, variables and etc.), when the new data (e.g. new observations of responses) are available. This method is mostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","title":"Update method for the ModelPseudo model class. This is a method to update the model class slots (estimates, parameters, variables and etc.), when the new data (e.g. new observations of responses) are available. This method is mostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"Update method ModelPseudo model class. method update model class slots (estimates, parameters, variables etc.), new data (e.g. new observations responses) available. method mostly used obtain new modal estimates pseudo model parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-ModelPseudo-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update method for the ModelPseudo model class. This is a method to update the model class slots (estimates, parameters, variables and etc.), when the new data (e.g. new observations of responses) are available. This method is mostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"","code":"# S4 method for class 'ModelPseudo' update(object, data, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/update-ModelPseudo-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update method for the ModelPseudo model class. This is a method to update the model class slots (estimates, parameters, variables and etc.), when the new data (e.g. new observations of responses) are available. This method is mostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"object (ModelPseudo) model update. data (Data) currently available data. ... used.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-ModelPseudo-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update method for the ModelPseudo model class. This is a method to update the model class slots (estimates, parameters, variables and etc.), when the new data (e.g. new observations of responses) are available. This method is mostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"new ModelPseudo class object.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/update-ModelPseudo-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update method for the ModelPseudo model class. This is a method to update the model class slots (estimates, parameters, variables and etc.), when the new data (e.g. new observations of responses) are available. This method is mostly used to obtain new modal estimates for pseudo model parameters. — update,ModelPseudo-method","text":"","code":"# Update the 'LogisticIndepBeta' model with new data. empty_data <- Data(doseGrid = seq(25, 300, 25))  my_model_lib <- LogisticIndepBeta(   binDLE = c(1.05, 1.8),   DLEweights = c(3, 3),   DLEdose = c(25, 300),   data = empty_data )  # Then, we have some new observations data. data <- Data(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 4L, 5L, 6L),   doseGrid = empty_data@doseGrid )  # Update the model to get new estimates. new_model_lib <- update(object = my_model_lib, data = data)  # Update the 'Effloglog' model with new data. empty_data_dual <- DataDual(doseGrid = seq(25, 300, 25), placebo = FALSE)  my_model_eff <- Effloglog(   eff = c(1.223, 2.513),   eff_dose = c(25, 300),   nu = c(a = 1, b = 0.025),   data = empty_data_dual,   const = 0 )  # Data with new observations data. my_data_dual <- DataDual(   x = c(25, 50, 50, 75, 100, 100, 225, 300),   y = c(0, 0, 0, 0, 1, 1, 1, 1),   w = c(0.31, 0.42, 0.59, 0.45, 0.6, 0.7, 0.6, 0.52),   ID = 1:8,   cohort = c(1L, 2L, 2L, 3L, 4L, 4L, 5L, 6L),   doseGrid = empty_data_dual@doseGrid )  # Update the model to get new estimates. new_model_eff <- update(object = my_model_eff, data = my_data_dual)"},{"path":"https://openpharma.github.io/crmPack/reference/v_cohort_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"functions used internally validate format input CohortSize inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_cohort_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"","code":"v_cohort_size_range(object)  v_cohort_size_dlt(object)  v_cohort_size_const(object)  v_cohort_size_parts(object)  v_cohort_size_max(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_cohort_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"object (CohortSize) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_cohort_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_cohort_size.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of CohortSize Objects — v_cohort_size","text":"v_cohort_size_range(): validates CohortSizeRange object contains valid intervals  cohort_size slots. v_cohort_size_dlt(): validates CohortSizeDLT object contains valid intervals  cohort_size slots. v_cohort_size_const(): validates CohortSizeConst object contains valid size slot. v_cohort_size_parts(): validates CohortSizeParts object contains valid sizes slot. v_cohort_size_max(): validates CohortSizeMax object contains valid cohort_sizes slot.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_data_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"functions used internally validate format input GeneralData inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_data_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"","code":"v_general_data(object)  h_doses_unique_per_cohort(dose, cohort)  v_data(object)  v_data_dual(object)  v_data_parts(object)  v_data_mixture(object)  v_data_da(object)  v_data_ordinal(object)  v_data_grouped(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_data_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"object (GeneralData) object validate. dose (numeric) dose values. cohort (integer) cohort indices parallel doses.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_data_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"character vector validation failure messages, TRUE case validation passes. TRUE dose unique per cohort, otherwise FALSE.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_data_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of GeneralData Objects — v_data_objects","text":"v_general_data(): validates GeneralData object contains unique ID, non-negative cohort indices ID cohort vectors length nObs. h_doses_unique_per_cohort(): helper function verifies whether dose values unique every different cohort. v_data(): validates Data object contains valid elements respect types, dependency length. v_data_dual(): validates DataDual object contains valid biomarker vector respect type length. v_data_parts(): validates DataParts object contains valid elements respect types, dependency length. v_data_mixture(): validates DataMixture object contains valid elements respect types, dependency length. v_data_da(): validates DataDA object contains valid elements respect types, dependency length. v_data_ordinal(): validates DataOrdinal object contains valid elements respect types, dependency length. v_data_grouped(): validates DataGrouped object contains valid group information.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"functions used internally validate format input RuleDesign inherited classes therefore exported.  functions used internally validate format input RuleDesignOrdinal inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"","code":"v_rule_design(object)  v_rule_design_ordinal(object)  v_design_grouped(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"object (RuleDesignOrdinal) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"character vector validation failure messages, TRUE case validation passes. character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_design.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of RuleDesign Objects — v_design","text":"v_rule_design(): validates RuleDesign object contains valid startingDose. v_rule_design_ordinal(): validates RuleDesignOrdinal object contains valid starting_dose. v_design_grouped(): validates DesignGrouped object contains valid flags.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_general_simulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"functions used internally validate format input GeneralSimulations inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_general_simulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"","code":"v_general_simulations(object)  v_simulations(object)  v_dual_simulations(object)  v_da_simulations(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_general_simulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"object (GeneralSimulations) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_general_simulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_general_simulations.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of GeneralSimulations Objects — v_general_simulations","text":"v_general_simulations(): validates GeneralSimulations object contains valid data object valid dose simulations. v_simulations(): validates Simulations object contains valid object fit, stop_reasons, stop_report, additional_stats compared general class GeneralSimulations. v_dual_simulations(): validates DualSimulations object capture dose-biomarker fits, sigma2W rho estimates. v_da_simulations(): validates DASimulations object contains valid trialduration vector trial duration values simulations.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_increments.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Increments Objects — v_increments","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"functions used internally validate format input Increments inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_increments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"","code":"v_increments_relative(object)  v_increments_relative_parts(object)  v_increments_relative_dlt(object)  v_increments_dose_levels(object)  v_increments_hsr_beta(object)  v_increments_min(object)  v_increments_maxtoxprob(object)  v_increments_ordinal(object)  v_cohort_size_ordinal(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_increments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"object (Increments) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_increments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_increments.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Increments Objects — v_increments","text":"v_increments_relative(): validates IncrementsRelative object contains valid intervals increments parameters. v_increments_relative_parts(): validates IncrementsRelativeParts object contains valid dlt_start clean_start parameters. v_increments_relative_dlt(): validates IncrementsRelativeDLT object contains valid intervals increments parameters. v_increments_dose_levels(): validates IncrementsDoseLevels object contains valid levels basis_level option. v_increments_hsr_beta(): validates IncrementsHSRBeta object contains valid probability target, threshold shape parameters. v_increments_min(): validates IncrementsMin object contains list Increments objects. v_increments_maxtoxprob(): validates IncrementsMaxToxProb v_increments_ordinal(): validates IncrementsOrdinal object contains valid grade standard Increments rule. v_cohort_size_ordinal(): validates CohortSizeOrdinal object contains valid grade standard CohortSize rule.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"functions used internally validate format input McmcOptions inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"","code":"v_mcmc_options(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"object (McmcOptions) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_mcmcoptions_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of McmcOptions Objects — v_mcmcoptions_objects","text":"v_mcmc_options(): validates McmcOptions object contains valid integer scalars iterations, burnin step well proper parameters Random Number Generator.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_model_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"functions used internally validate format input GeneralModel ModelPseudo inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_model_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"","code":"v_general_model(object)  v_model_logistic_kadane(object)  v_model_logistic_kadane_beta_gamma(object)  v_model_logistic_normal_mix(object)  v_model_logistic_normal_fixed_mix(object)  v_model_logistic_log_normal_mix(object)  v_model_dual_endpoint(object)  v_model_dual_endpoint_rw(object)  v_model_dual_endpoint_beta(object)  v_model_dual_endpoint_emax(object)  v_model_logistic_indep_beta(object)  v_model_eff_log_log(object)  v_model_eff_flexi(object)  v_model_da_logistic_log_normal(object)  v_model_tite_logistic_log_normal(object)  v_model_one_par_exp_normal_prior(object)  v_model_one_par_exp_prior(object)  v_logisticlognormalordinal(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_model_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"object (GeneralModel) (ModelPseudo)  object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_model_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_model_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of GeneralModel and ModelPseudo Objects — v_model_objects","text":"v_general_model(): validates names arguments init function included datanames datanames_prior slots. v_model_logistic_kadane(): validates logistic Kadane model parameters valid. v_model_logistic_kadane_beta_gamma(): validates logistic Kadane model parameters beta gamma prior valid. v_model_logistic_normal_mix(): validates weightpar valid. v_model_logistic_normal_fixed_mix(): validates component list valid ModelParamsNormal objects well weights correct. v_model_logistic_log_normal_mix(): validates share_weight represents probability. v_model_dual_endpoint(): validates DualEndpoint class slots valid. v_model_dual_endpoint_rw(): validates DualEndpointRW class slots valid. v_model_dual_endpoint_beta(): validates DualEndpointBeta class slots valid. v_model_dual_endpoint_emax(): validates DualEndpointEmax class slots valid. v_model_logistic_indep_beta(): validates LogisticIndepBeta class slots valid. v_model_eff_log_log(): validates Effloglog class slots valid. v_model_eff_flexi(): validates EffFlexi class slots valid. v_model_da_logistic_log_normal(): validates DALogisticLogNormal class slots valid. v_model_tite_logistic_log_normal(): validates TITELogisticLogNormal class slots valid. v_model_one_par_exp_normal_prior(): validates OneParLogNormalPrior class slots valid. v_model_one_par_exp_prior(): validates OneParExpPrior class slots valid. v_logisticlognormalordinal(): confirms cov diagonal","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_model_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"functions used internally validate format object model parameters inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_model_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"","code":"v_model_params_normal(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_model_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"object (ModelParamsNormal) multivariate normal parameters object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_model_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_model_params.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Model Parameters Objects — v_model_params","text":"v_model_params_normal(): helper function validates multivariate normal parameters.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_next_best.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"functions used internally validate format input NextBest inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_next_best.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"","code":"v_next_best_mtd(object)  v_next_best_ncrm(object)  v_next_best_ncrm_loss(object)  v_next_best_dual_endpoint(object)  v_next_best_min_dist(object)  v_next_best_inf_theory(object)  v_next_best_td(object)  v_next_best_td_samples(object)  v_next_best_max_gain_samples(object)  v_next_best_prob_mtd_lte(object)  v_next_best_prob_mtd_min_dist(object)  v_next_best_ordinal(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_next_best.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"object (NextBest) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_next_best.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_next_best.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of NextBest Objects — v_next_best","text":"v_next_best_mtd(): validates NextBestMTD object contains valid target probability derive function. v_next_best_ncrm(): validates NextBestNCRM object contains valid target probability, overdose max_overdose_prob probability ranges. v_next_best_ncrm_loss(): validates NextBestNCRMLoss object contains valid objects. v_next_best_dual_endpoint(): validates NextBestDualEndpoint object contains valid probability objects. v_next_best_min_dist(): validates NextBestMinDist object contains valid target object. v_next_best_inf_theory(): validates NextBestInfTheory object contains valid target asymmetry objects. v_next_best_td(): validates NextBestTD object contains valid prob_target_drt prob_target_eot probabilities. v_next_best_td_samples(): validates NextBestTDsamples object contains valid derive function. v_next_best_max_gain_samples(): validates NextBestMaxGainSamples object contains valid derive mg_derive functions. v_next_best_prob_mtd_lte(): validates NextBestProbMTDLTE object contains valid target probability method string value. v_next_best_prob_mtd_min_dist(): validates NextBestProbMTDMinDist object contains valid target probability method string value. v_next_best_ordinal(): validates NextBestOrdinal object contains valid grade standard NextBest rule.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_pseudo_simulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"functions used internally validate format input PseudoSimulations inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_pseudo_simulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"","code":"v_pseudo_simulations(object)  v_pseudo_dual_simulations(object)  v_pseudo_dual_flex_simulations(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_pseudo_simulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"object (PseudoSimulations) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_pseudo_simulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_pseudo_simulations.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of PseudoSimulations Objects — v_pseudo_simulations","text":"v_pseudo_simulations(): validates PseudoSimulations object contains valid fit, FinalTDtargetEndOfTrialEstimates , FinalTDtargetDuringTrialAtDoseGrid,FinalTDtargetEndOfTrialAtDoseGrid , FinalTDEOTCIs, FinalTDEOTRatios, FinalCIs, FinalRatios, object valid stopReasons simulations. v_pseudo_dual_simulations(): validates PseudoDualSimulations object contains valid fit_eff, final_gstar_estimates , final_gstar_at_dose_grid, final_gstar_cis , final_gstar_ratios, final_optimal_dose, final_optimal_dose_at_dose_grid object valid sigma2_est simulations. v_pseudo_dual_flex_simulations(): validates PseudoDualFlexiSimulations object contains valid sigma2_beta_w_est vector final posterior mean sigma2betaW estimates.FinalGstarEstimates , FinalGstarAtDoseGrid,","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_safety_window.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"functions used internally validate format input SafetyWindow inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_safety_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"","code":"v_safety_window_size(object)  v_safety_window_const(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_safety_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"object (SafetyWindow) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_safety_window.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_safety_window.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of SafetyWindow Objects — v_safety_window","text":"v_safety_window_size(): validates SafetyWindowSize object contains valid slots. v_safety_window_const(): validates SafetyWindowConst object contains valid slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_samples_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"functions used internally validate format input Samples inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_samples_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"","code":"v_samples(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_samples_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"object (Samples) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_samples_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_samples_objects.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Samples Objects — v_samples_objects","text":"v_samples(): validates Samples object contains valid data slot.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_starting_dose.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of StartingDose Objects — v_starting_dose","title":"Internal Helper Functions for Validation of StartingDose Objects — v_starting_dose","text":"Validates StartingDose object contains valid starting_dose.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_starting_dose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of StartingDose Objects — v_starting_dose","text":"","code":"v_starting_dose(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_starting_dose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of StartingDose Objects — v_starting_dose","text":"object (StartingDose) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_starting_dose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of StartingDose Objects — v_starting_dose","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"functions used internally validate format input Stopping inherited classes therefore exported.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"","code":"v_stopping_cohorts_near_dose(object)  v_stopping_patients_near_dose(object)  v_stopping_min_cohorts(object)  v_stopping_min_patients(object)  v_stopping_target_prob(object)  v_stopping_mtd_distribution(object)  v_stopping_mtd_cv(object)  v_stopping_target_biomarker(object)  v_stopping_list(object)  v_stopping_all(object)  v_stopping_tdci_ratio(object)"},{"path":"https://openpharma.github.io/crmPack/reference/v_stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"object (Stopping) object validate.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_stopping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"character vector validation failure messages, TRUE case validation passes.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/v_stopping.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal Helper Functions for Validation of Stopping Objects — v_stopping","text":"v_stopping_cohorts_near_dose(): validates StoppingCohortsNearDose object contains valid nCohorts percentage parameters. v_stopping_patients_near_dose(): validates StoppingPatientsNearDose object contains valid nPatients percentage parameters. v_stopping_min_cohorts(): validates StoppingMinCohorts object contains valid nCohorts parameter. v_stopping_min_patients(): validates StoppingMinPatients object contains valid nPatients parameter. v_stopping_target_prob(): validates StoppingTargetProb object contains valid target prob parameters. v_stopping_mtd_distribution(): validates StoppingMTDdistribution object contains valid target, thresh prob parameters. v_stopping_mtd_cv(): validates StoppingMTDCV object contains valid probability target percentage threshold. v_stopping_target_biomarker(): validates StoppingTargetBiomarker object contains valid target, is_relative probslots. v_stopping_list(): validates StoppingList object contains valid stop_list, summary slots. v_stopping_all(): validates StoppingAll object contains valid stop_list slot. v_stopping_tdci_ratio(): validates StoppingTDCIRatio object contains valid target_ratio  prob_target slots.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/windowLength.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the safety window length of the next cohort — windowLength","title":"Determine the safety window length of the next cohort — windowLength","text":"function determines safety window length next cohort.","code":""},{"path":"https://openpharma.github.io/crmPack/reference/windowLength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the safety window length of the next cohort — windowLength","text":"","code":"windowLength(safetyWindow, size, ...)  # S4 method for class 'SafetyWindowSize' windowLength(safetyWindow, size, data, ...)  # S4 method for class 'SafetyWindowConst' windowLength(safetyWindow, size, ...)"},{"path":"https://openpharma.github.io/crmPack/reference/windowLength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the safety window length of the next cohort — windowLength","text":"safetyWindow rule, object class SafetyWindow size next cohort size ... additional arguments data data input, object class DataDA","code":""},{"path":"https://openpharma.github.io/crmPack/reference/windowLength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the safety window length of the next cohort — windowLength","text":"windowLength list safety window parameters (gap, follow, follow_min)","code":""},{"path":"https://openpharma.github.io/crmPack/reference/windowLength.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Determine the safety window length of the next cohort — windowLength","text":"windowLength(SafetyWindowSize): Determine safety window length based cohort size windowLength(SafetyWindowConst): Constant safety window length","code":""},{"path":"https://openpharma.github.io/crmPack/reference/windowLength.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine the safety window length of the next cohort — windowLength","text":"","code":"# nolint start  # Create the data data <- DataDA(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60 ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data npiece_ <- 10 lambda_prior <- function(k) {   npiece_ / (data@Tmax * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(     as.matrix(c(1:npiece_), 1, npiece_),     2,     lambda_prior   ))),   c_par = 2 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 200) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the rule which will be used to select the next cohort size # based on the class 'CohortSizeConst' mySize <- CohortSizeConst(size = 3)  # Determine the cohort size for the next cohort sizeRecommendation <- size(mySize, dose = doseRecommendation$value, data = data)  # Rule for the safety window length: #   -having patientGap as (0,7,3,3,...) for cohort size <4 #   -and having patientGap as (0,9,5,5,...) for cohort size >=4 myWindowLength <- SafetyWindowSize(   gap = list(c(7, 3), c(9, 5)),   size = c(1, 4),   follow = 7,   follow_min = 14 )  # Determine the safety window parameters for the next cohort windowLength(myWindowLength, size = sizeRecommendation) #> $patientGap #> [1] 0 7 3 #>  #> $patientFollow #> [1] 7 #>  #> $patientFollowMin #> [1] 14 #>   # nolint end # nolint start  # Create the data data <- DataDA(   x = c(0.1, 0.5, 1.5, 3, 6, 10, 10, 10),   y = c(0, 0, 1, 1, 0, 0, 1, 0),   doseGrid = c(0.1, 0.5, 1.5, 3, 6, seq(from = 10, to = 80, by = 2)),   u = c(42, 30, 15, 5, 20, 25, 30, 60),   t0 = c(0, 15, 30, 40, 55, 70, 75, 85),   Tmax = 60 ) #> Used default patient IDs! #> Used best guess cohort indices!  # Initialize the CRM model used to model the data npiece_ <- 10 lambda_prior <- function(k) {   npiece_ / (data@Tmax * (npiece_ - k + 0.5)) }  model <- DALogisticLogNormal(   mean = c(-0.85, 1),   cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),   ref_dose = 56,   npiece = npiece_,   l = as.numeric(t(apply(     as.matrix(c(1:npiece_), 1, npiece_),     2,     lambda_prior   ))),   c_par = 2 )  # Set-up some MCMC parameters and generate samples from the posterior options <- McmcOptions(burnin = 100, step = 2, samples = 200) set.seed(94) samples <- mcmc(data, model, options)  # Define the rule for dose increments and calculate the maximum dose allowed myIncrements <- IncrementsRelative(   intervals = c(0, 20),   increments = c(1, 0.33) ) nextMaxDose <- maxDose(myIncrements, data = data)  # Define the rule which will be used to select the next best dose # based on the class 'NextBestNCRM' myNextBest <- NextBestNCRM(   target = c(0.2, 0.35),   overdose = c(0.35, 1),   max_overdose_prob = 0.25 )  # Calculate the next best dose doseRecommendation <- nextBest(   myNextBest,   doselimit = nextMaxDose,   samples = samples,   model = model,   data = data )  # Define the rule which will be used to select the next cohort size # based on the class 'CohortSizeConst' mySize <- CohortSizeConst(size = 3)  # Determine the cohort size for the next cohort sizeRecommendation <- size(mySize, dose = doseRecommendation$value, data = data)  # Rule for having safety window length with constant safety window parameters myWindowLength <- SafetyWindowConst(gap = c(7, 3), follow = 7, follow_min = 14)  # Determine the safety window parameters for the next cohort windowLength(myWindowLength, size = sizeRecommendation) #> $patientGap #> [1] 0 7 3 #>  #> $patientFollow #> [1] 7 #>  #> $patientFollowMin #> [1] 14 #>   # nolint end"},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-2009002","dir":"Changelog","previous_headings":"","what":"Version 2.0.0.9002","title":"Version 2.0.0.9002","text":"Note: release (1.0 -> 2.0) signifies major breaking revamp package. Users advised carefully review release notes documentation detailed information changes necessary updates existing code. Implemented IncrementsMaxToxProb class Implemented knit_print methods almost crmPack classes improve rendering Markdown Quarto documents. See vignette details. Provided basic support ordinal CRM models. See vignette details. Implemented broom-like tidy methods concrete crmPack classes. See vignette details. Removed multiplot function. Use Please use equivalent functionality packages, cowplot ggpubr. Added new DataGrouped DesignGrouped classes corresponding model LogisticLogNormalGrouped support simultaneous dose escalation monotherapy combination therapy arms. Created CrmPackClass class ultimate ancestor crmPack classes allow identification crmPack classes simpler definition generic methods. approximate now returns list containing fitted model , optionally, ggplot object approximated dose/toxicity curve. Modified wording attribute stopTrial’s return value StoppingMTDdistribution objects strictly match definition given online documentation. return value unchanged. Corrected spelling name messgae [sic] attribute return value stopTrial signature stopping = \"StoppingTDCIRatio\". Changed type ref_dose LogisticNormalMixture LogisticNormalFixedMixture classes positive_number numeric consistency classes. Added -parameter constructor functions named .Default<class name> provide usable instances concrete subclasses Increments, Model, NextBest Stopping. Added new function dose_grid_range returns range doses dose grid. Added new function ngrid returns number doses dose grid. Modified efficacy-EffFlexi method: allowed vectorized dose; NA now returned doses outside dose grid range (warning thrown). Added new custom checkmate function check_range. Added method names objects class Samples. Added method size objects class Samples. Added new custom checkmate function check_length. Added unique flag assert_probabilities checkmate custom functions. Created new vignette describes use certain functions features crmPack major refactoring. Removed MASS Imports Rcpp, RcppArmadillo Suggests used old development version. doselimit argument nextBest method now specified Inf instead numeric(0). Added new helper functions nextBest methods, particularly plotting finding dose closest grid. Added new NextBestNCRMLoss class corresponding nextBest method. Warning message printed anymore nextBest methods doselimit specified. Set prototype target = 0.3 NextBestMinDist class. Added new customized checkmate functions probability values checking. Renamed argument derive function mtdSamples mtd_samples NextBestMTD class. Allowed from_prior flag - argument modelspecs function GeneralModel class. Created new ProbitLogNormalRel model class support (standardized) dose. Changed ProbitLogNormal supports log (standardized) dose . Added logger feature. user interface consists four functions: enable_logging, disable_logging, is_logging_enabled, log_trace. Re-factored sampleSize function returns 0 burnin > iterations. vector t0 slot DataDA class must sorted ascending order. Replaced warning message cohort ID provided user constructor Data. Introduced validation updated object update methods Data-like classes. Added check flag possibly omit validation updated object. Set package use testthat. Added lifecycle package. Include rolling CRM design, previously available separate GitHub branch. Additional authors change maintainer. Included ‘additional_stats’ add reporting additional parameters method simulate summarize MTD. ‘report_label’ can added stopping rules individual combined stopping rule reporting.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-100","dir":"Changelog","previous_headings":"","what":"Version 1.0.0","title":"Version 1.0.0","text":"CRAN release: 2019-06-13 Reference JSS publication.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-029","dir":"Changelog","previous_headings":"","what":"Version 0.2.9","title":"Version 0.2.9","text":"CRAN release: 2018-12-21 default use 5 cores available cores machine. Note value can also changed user. Change maintainer","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"bugfixes-0-2-8","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.8","text":"PLcohortSize now defaults 0 placebo patients upon Design class initialization (instead 1 - note effect erroneous simulations, due option set Data class) “examine” function also stops stopping rules fulfilled already case DLTs occurring. case beforehand lead infinite looping (thanks John Kirkpatrick reporting bug) Removed RW2 warnings “DualEndpointRW” - seems work nicely now (thanks Charles Warne reporting!) Removed WinBUGS since used anyway (paper describe )","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"new-features-0-2-8","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.8","text":"“examine” function now counts number times dose recommended contiguously break e.g. default 100 times (can specified new option “examine”) avoid infinite loops issues corresponding warning condition met New “Increments” class “IncrementsNumDoseLevels” works directly number dose levels dose grid can incremented current next cohort (thanks John Kirkpatrick suggestion). can example used order force design skip dose level escalating. Included JSS manuscript new vignette. now possible specify many cores used parallel computations used.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-027","dir":"Changelog","previous_headings":"","what":"Version 0.2.7","title":"Version 0.2.7","text":"CRAN release: 2018-03-13","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"bugfixes-0-2-7","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.7","text":"LogisticNormal now works - prec found .","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-026","dir":"Changelog","previous_headings":"","what":"Version 0.2.6","title":"Version 0.2.6","text":"CRAN release: 2018-02-15","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"bugfixes-0-2-6","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.6","text":"Replaced BayesLogit dependency JAGS code, since BayesLogit taken CRAN. Speed one example pass CRAN check.","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"new-features-0-2-5","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.5","text":"matching doses dose grid now includes tolerance 1e-10, order make user-friendly (thanks YJ Choi Giuseppe investigating)","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"bugfixes-0-2-5","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.5","text":"minor fix alpha1 description LogisticLogNormal-class minor fix scale_colour_manual import ggplot2 reported R-Core","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"new-features-0-2-4","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.4","text":"case multiple nextBest plots now also returned original plots list singlePlots, allow customization, jointly plotting . ProbitLogNormal: Now also model allows reference dose log transformation (standardized) dose. can specified options refDose useLogDose. DualEndpoint: additional options ProbitLogNormal now available DualEndpoint models. consequence, parameter “refDose” class DualEndpointBeta needed renamed “refDoseBeta”, parameter “refDose” class DualEndpointEmax renamed “refDoseEmax”.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"bugfixes-0-2-4","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.4","text":"documentation: DualEndpoint description fixed problem formula","code":""},{"path":[]},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"new-features-0-2-3","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.3","text":"New increment class “IncrementMin” added allows combine multiple increment rules MIN operation","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-021","dir":"Changelog","previous_headings":"","what":"Version 0.2.1","title":"Version 0.2.1","text":"CRAN release: 2017-05-03","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"new-features-0-2-1","dir":"Changelog","previous_headings":"","what":"New features:","title":"Version 0.2.1","text":"Option targetThresh NextBestDualEndpoint allows tune target probability onwards used derive next best dose (fixed 0.05) Added ProbitLogNormal model NextBestDualEndpoint class, additional option “scale” now allows also specify absolute biomarker target ranges. corresponding method evaluation, safety samples now longer included evaluation biomarker target probability, now description consistent computations. NextBestNCRM NextBestDualEndpoint now return matrix target overdosing probabilities additional list element “probs” result “nextBest” applied. Note StoppingTargetBiomarker evaluation, toxicity longer part biomarker target probability.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"bugfixes-0-2-1","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"Version 0.2.1","text":"Added back example vignette, can opened crmPackExample() Clarified DualEndpointRW model samples prior obtained due impropriety RW prior (added model class description). DualEndpointRW models, now possible non-equidistant grid points, obtain sensible results. (still needs thoroughly tested though.) DualEndpointBeta model, now possible negative E0 Emax parameters. Cohort size 0 placebo now possible - e.g. start patients later move larger cohorts also including placebo subjects. simulating firstSeparate=TRUE placebo, now first (sentinel) cohort includes one active one placebo patients, next patients use cohort size active placebo arms, respectively. Barplots work now also one observed value simulations NextBestDualEndpoint now takes account active doses optimizing biomarker outcome next best dose among admissible doses, thus avoiding early stopping placebo dose level. DataMixture objects used, mcmc now correctly sets fromPrior FALSE shared data object contains data.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-020","dir":"Changelog","previous_headings":"","what":"Version 0.2.0","title":"Version 0.2.0","text":"CRAN release: 2016-07-16 Added arguments probmin probmax MinimalInformative order control probability threshold minimum maximum dose minimally informative prior Values 95% CI corresponding ratio upper lower limit CI displayed results using ‘nextBest’ six- number summary tables including values lowest, 25th percentile, 50th percentile median, mean, 75th precentile highest final (stopping) estimates dose levels corresponds target probability DLE used end trial, TDEOT ratios upper lower 95% credibility intervals (CI) TDEOT dose levels corresponds target probability DLE used trial dose levels corresponds maximum gain value, Gstar ratios upper lower 95% CI final estimates Gstar optimal doses, either TDEOT (DLE response ) minimum TDEOT Gstar (DLE efficacy response) ratios optimal dose across simulations also displayed using ‘summary’ simulations.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-018","dir":"Changelog","previous_headings":"","what":"Version 0.1.8","title":"Version 0.1.8","text":"CRAN release: 2016-02-17 value 95% CI final estimates displayed results using ‘stopTrial’ Bugfixes dual endpoint designs: Improved graphical display plots nextBest dose Improved methodology compute Gstar Warnings removed using nextBest simulations Stopping rules can now also freely combined using /operators dual endpoint design stopping rules using MCMC samples.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-016","dir":"Changelog","previous_headings":"","what":"Version 0.1.6","title":"Version 0.1.6","text":"CRAN release: 2015-12-22 New model class “LogisticLogNormalMixture” added, use new data class “DataMixture”. New stopping rule “StoppingHighestDose” added. “examine” method longer stops two consecutive cohorts start dose. important e.g. two-parts study designs, part 1 can end dose part 2 starts. contents “datanames” slot new models longer restricted specific set, previously enforced validation function GeneralModel AllModels classes. Sampling prior can now enabled/disabled user mcmc function, necessary models might prior even though nObs == 0. Bugfix: results MinimalInformative function reproducible beforehand. Now seed parameter can supplied, ensures reproducibility. Bugfix: Compatibility help file links new ggplot2 package version.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-015","dir":"Changelog","previous_headings":"","what":"Version 0.1.5","title":"Version 0.1.5","text":"CRAN release: 2015-11-12 Bugfix: newer versions grid plotting simulation objects longer work. fixed.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-012","dir":"Changelog","previous_headings":"","what":"Version 0.1.2","title":"Version 0.1.2","text":"publication) prior quantiles specified approximated logistic (log) normal priors.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-011","dir":"Changelog","previous_headings":"","what":"Version 0.1.1","title":"Version 0.1.1","text":"Bugfix: Previously, happen NextBestNCRM rule, higher doses lead decreasing probability overdosing, doses numerically probability 1 DLT. bugfix, clarified rules documentation fixed rule method, right limit overdose interval vector inclusive.","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-010","dir":"Changelog","previous_headings":"","what":"Version 0.1.0","title":"Version 0.1.0","text":"Added examine function generate table hypothetical trial courses model-based rule-based DLT-endpoint designs Made results mcmc() (works usual set.seed earlier user code) simulate() (previously already promised) reproducible. See help file mcmc details. Additional improvements reduce confusing warning messages / notes mcmc() higher-level functions. Made simulate parallel=TRUE work r.roche.com (Linux server), using parallelization method laptops (Windows) Passing empty (zero length) vector doselimit parameter nextBest function now considered requesting dose recommendation without strict dose limit, corresponding warning printed. Introduced GeneralModel class, class Model single agent dose escalation derives. Another branch ComboLogistic model multiple agent combinations (future version). Similarly introduced GeneralData class, class Data single agent derives, separately subclass DataCombo (future version).","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-0023","dir":"Changelog","previous_headings":"","what":"Version 0.0.23","title":"Version 0.0.23","text":"Fixed bug mcmc function led error “data elements must many rows sample size ” slightly changed JAGS way handling burnin / thinning (user impact). Reduced number MCMC samples dual-endpoint example vignette able plot vignette","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-0022","dir":"Changelog","previous_headings":"","what":"Version 0.0.22","title":"Version 0.0.22","text":"simulate function fixed (specification arguments) Dual-endpoint model-based design added. 3+3 design simulation now possible, see ?ThreePlusThreeDesign Welcome message attaching crmPack, .e. library(“crmPack”) run crmPackUpgrade() function easy upgrade crmPack latest version Rule-based designs now can specified class RuleDesign, model-based designs stay class Design. even special class DualDesign class, dual-endpoint model-based designs. Corresponding classes GeneralSimulations, Simulations DualSimulations capture output trial simulations rule-based, model-based dual-endpoint designs. class Simulations-summary renamed SimulationsSummary, similarly classes GeneralSimulationsSummary DualSimulationsSummary. Stopping CohortSize rules based intervals (IncrementsRelative, IncrementsRelativeDLT, CohortSizeRange, CohortSizeDLT) now use different intervals definition. Now “intervals” slots contain left bounds intervals. , last element needed infinity. See vignette examples. StoppingMaxPatients class removed, redundant class StoppingMinPatients. Please just use StoppingMinPatients class instead. Initialization methods replaced dedicated initialization functions. Please now use Class(…) functions instead new(“Class”, …) calls obtain correct objects. change also reflected vignette. extract function extracting parameter samples Samples objects removed (due name conflict ggmcmc dependency packages). Please now use instead “get” method Samples objects (see vignette example) obtain data ggmcmc format. crmPack now needs package httr (’s now “Imports” field). Packages Rcpp RcppArmadillo moved “Depends” “Suggests” packages. Currently using . showLegend argument model fit plotting functions, order show legend .","code":""},{"path":"https://openpharma.github.io/crmPack/news/index.html","id":"version-0021","dir":"Changelog","previous_headings":"","what":"Version 0.0.21","title":"Version 0.0.21","text":"NEWS version","code":""}]
