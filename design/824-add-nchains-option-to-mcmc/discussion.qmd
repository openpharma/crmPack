---
title: "Design/discussion document for multiple MCMC chains"
format: html
embed-resources: TRUE
editor: visual
---

```{r}
#| eval: TRUE
#| label: set-up
#| echo: FALSE

suppressPackageStartupMessages({
  library(crmPack)
  library(knitr)
  library(kableExtra)
  library(mvtnorm)
  library(checkmate)
  library(dplyr)
  library(rjags)
})

# The Validate class needs to be defined in the Quarto document.  Perhaps because it's not exported from `crmPack`?
Validate <- setRefClass(
  Class = "Validate",
  fields = list(msg = "character"),
  methods = list(
    check = function(test, string = "") {
      "Check whether the \\code{test} is \\code{TRUE}; if so, return \\code{NULL}.
      Otherwise, add the \\code{string} message into the cumulative messages vector \\code{msg}."
      assert_flag(test)
      assert_string(string)
      if (test) {
        NULL
      } else {
        msg <<- c(msg, string)
      }
    },
    result = function() {
      "Return either cumulative messages vector \\code{msg}
      (which contains the error messages from all the checks),
      or \\code{NULL}, if \\code{msg} is empty (i.e. all the checks were successful)."
      if (length(msg) > 0) {
        msg
      } else {
        TRUE
      }
    }
  )
)
```

# Questions

- Why does `McmcOptions` treat `burnin` and `n.iter` differently to JAGS?  `mcmc` sets the JAGS `n.iter` option to `McmcOptions` `iterations - burnin`.
- Should we consider modifying `h_jags_write_model` to use return a string rather than a temporary file?  `jags_model` could then use `textConnection`, which removes any interaction with the file system.

# Background

In principle, adding support for multiple MCMC chains to `crmPack` should be straightforward.
`rjags` supports multiple chains via the `n.chains` argument to `jags.model` and related functions.
All that it appears we need to do is to add a similar parameter to `mcmc` and we have what we need.

And indeed, this will/should work. But it will not be effective. The reason is that, to test
convergence effectively, different chains estimating the same model should start from different
initial positions. If these positions are extreme, so much the better, as it supports the assumption
that the chains will converge (to the same stable state) regardless of their starting positions.

This is where our difficulties begin. For each model class, `crmPack` provides *constant* starting
values for the MCMC chain(s). For example, this is the `init` slot for `LogisticLogNormal`:

```{r}
#| eval: FALSE
#| label: example-init-slot

init = function() {
  list(theta = c(0, 1))
}
```

Clearly, what values can be considered extreme depend on the prior distribution of the model. These are provided elsewhere in the model object.  (For example in the `params` slot of `ModelLogNormal`.) This is where our difficulties deepen:

> There is no direct way for a slot of an S4 object to access the value in another slot *of the same object*.

## Is there a need for an `n.chains` argument to `mcmc`?
An `n.chains` argument to `mcmc` might be useful, but I don't believe it is necessary.  My reason for saying so is the way in which chains are initialised in JAGS.  When using a single chain, users simply supply a `list` containing the necessary information to initialise the chain.  To use multiple chains, the user supplies a `list` of such `list`s and sets `n.chains` to the length of the outer `list`. It would be a simple matter for `crmPack` to set `n.chains` for `jags.model` on the basis of the length of the list of user supplied `inits`.

Of course, if the user wanted `crmPack` to automate the creation of the model `inits`, then `n.chains` would be useful.  However, as I shall demonstrate later in this document, I think there are better ways to do this.

```{r}
#| label: list-of-lists-demo
#| eval: FALSE
#| echo: FALSE
model <- rjags::jags.model(
  file = textConnection(
    "model {
      theta ~ dmnorm(mean, prec)
      alpha0 <- theta[1]
      alpha1 <- theta[2]
    }"
  ),
  data = list(
    mean = c(-0.85, 1.00),
    prec = matrix(c(1.333, 0.667, 0.667, 1.333), nrow = 2)
  ),
  inits = list(
    list(theta = c(1, 0)),
    list(theta = c(0, 1))
  ),
  quiet = FALSE,
  n.adapt = 0,
  n.chains = 2
)
update(model, n.iter = 500)
samples <- rjags::jags.samples(
  model = model,
  variable.names = c("alpha0", "alpha1"),
  n.iter = 500,
  thin = 2
)
samples
```


# Simplistic support for multiple chains
By modifying the function` in a `Model`'s `init` slot to take a parameter that defines the number of chains required, multiple `inits` can be easily supported without breaking existing code:

```{r}
#| label: simple-inits-1
#| eval: TRUE

model <- .DefaultLogisticLogNormal()
model@init()
model@init

model@init <- function(n = 1) {
  lapply(seq_len(n), function(i) list(theta = c(-0.85, 1)))
}

model@init()
model@init(3)
```

But this simply produces the same starting values for every chain.  As explained above, this is sub-optimal.  Different starting values for different chains are possible, but need reference to other slots of the same `Model` object.  As explained earlier, this is awkward, fragile and horrible:

```{r}
#| label: simple-inits-2
#| eval: TRUE

model@init <- function(n = 1, aModel) {
  lapply(
    seq_len(n), 
    function(i, mu, var) {
      x <- as.vector(rmvnorm(1, mu, var))
      list("theta" = x)
    },
    mu = aModel@params@mean,
    var = aModel@params@cov
  )
}

model@init(3, model)
```

# An intermediate route to support multipe MCMC chains 

- Create a new class, `McmcOptionsList`, which simply contains a `list` of `McmcOptions`
- Modify the signature of the `mcmc` generic so that `options = ANY`.
- For each existing `mcmc` method, define a sibling with signature `options = "McmcOptionsList" that simply iterates over the current method and then binds the results together

This option does not allow different initial values for each chain in the list.  I don't believe this is sufficient.

# A comprehensive, flexible and reliable method of setting initial MCMC chain states
To allow maximum flexibility - and to provide end users to implement their own initialisation strategy - create a new class.  The parent class does nothing beyond providing a placeholder.  Actual implementation is handled in child classes.  It will also be helpful to create a helper function to provide common functionality.

## Separation of chain-level and simulation-level parameters

Some JAGS parameters affect only a single chain, others the entire call to the simulation function.  Since `crmPack` currently supports use of only a single chain, these two types of setting are conflated in `McmcOptions`.  For clarity, separate them into different classes.

### Chain-level JAGS parameters

These essentially control a single pseudo-random number generator.  Here, `model_init` is the slot that contains the value retuned by `model@init()`, which would normally be set by the `initialise(chainOptions, model)` method.

>  Does the `initialised` slot fit better here or in `ChainOptions`?  Or is it even needed?  [It's difficult to imagine a situation in which some `RNGOptions` elements of a `ChainOptions`'s `option_list` slot are initialised and others aren't...]

```{r}
#| label: prng-1

# Closely based on v_mcmc_options
v_rng_options <- function(object) {
  v <- Validate()
  allowed_rng_kinds <- c(
    "base::Wichmann-Hill",
    "base::Marsaglia-Multicarry",
    "base::Super-Duper",
    "base::Mersenne-Twister",
    NA_character_
  )
  
  is_rng_kind_scalar <- test_string(object@rng_name, na.ok = TRUE)
  v$check(is_rng_kind_scalar, "rng_name must be a single string")
  v$check(
    test_subset(object@rng_name, allowed_rng_kinds),
    paste0(
      "rng_name must one of the following: ",
      paste(allowed_rng_kinds, collapse = ", "),
      ". User specifies the rng_name without `base::` prefix"
    )
  )
  
  is_rng_seed_scalar <- test_int(object@rng_seed, na.ok = TRUE)
  v$check(is_rng_seed_scalar, "rng_seed must be an integer scalar")
  
  # Below `if` condition is not only reasonable but also needed as R CMD check
  # is activating some stricter checks and it fails when arguments to `||` are
  # not scalars, even if `||` works well with vectors of length > 1.
  if (is_rng_kind_scalar && is_rng_seed_scalar) {
    v$check(
      !is.na(object@rng_name) || is.na(object@rng_seed),
      "rng_seed supplied but rng_kind not set"
    )
  }
  v$result()  
}

.RNGOptions <- setClass(
  Class = "RNGOptions",
  slots = c(
    initialised = "logical",
    model_init = "list",
    rng_name = "character",
    rng_seed = "integer"
  ),
  prototype = prototype(
    initialised = FALSE,
    model_init = list(),
    rng_name = NA_character_,
    rng_seed = NA_integer_
  ),
  contains = "CrmPackClass",
  validity = v_rng_options
)

## constructor ----
RNGOptions <- function(name = NA_character_, seed = NA_integer_) {
  .RNGOptions(
    rng_name = ifelse(is.na(name), NA_character_, paste0("base::", name)),
    rng_seed = seed, 
    model_init = list()
  )
}

## default constructor ----
.DefaultRNGOptions <- function() {
  .RNGOptions()
}

RNGOptions()
x <- RNGOptions("Mersenne-Twister", 511031L)
x@model_init <- (.DefaultLogisticLogNormal())@init()
x
```

### Simulation-level JAGS parameters

```{r}
#| label: initialiser-1
#| eval: TRUE

h_prepare_mcmcoptions_list <- function(n, options) {
  assert_count(n)
  if (is.null(options)) {
    options <- lapply(seq_len(n), function(i) .DefaultRNGOptions())
  } else {
    assert_true(length(options) == n)
  }
  assert_list(options, any.missing = FALSE)
  for (opt in options) {
    assert_class(opt, "RNGOptions")
  } 
  options
}

# Chain Options ----
v_chain_options <- function(object) {
  v <- Validate()
  v$check(
    test_int(object@samples, lower = 1L),
    "samples must be integer scalar greater than or equal to 1"
  )
  v$check(
    test_int(object@burnin, lower = 0L),
    "burn-in must be non-negative integer scalar"
  )
  # This below check should not be conducted in above test, using
  # `upper = object@samples -1` argument, since object@samples might be
  # not-valid. In such a case `test_int` throws an internal error.
  v$check(
    test_true(object@burnin < object@samples),
    "burn-in must be lower than samples"
  )
  v$check(
    test_int(object@step, lower = 1L),
    "step must be integer scalar greater than or equal to 1"
  )
  v$check(
    all(sapply(object@options_list, function(z) test_class(z, "RNGOptions"))),
    "all elements of options_list must be RNGOptions objects"
  )
  v$result()
}

.ChainOptions <- setClass(
  Class = "ChainOptions",
  slots = c(
    burnin = "integer",
    step = "integer",
    samples = "integer",
    options_list = "list"
  ),
  prototype = prototype(
    burnin = 1e4L,
    step = 2L,
    samples = 2e4L,
    option_list = list()
  ),
  contains = "CrmPackClass",
  validity = v_chain_options
)

## constructor ----
ChainOptions <- function(
    burnin = 1E4L, 
    step = 2L, 
    samples = 1E4L, 
    n_chains = 1, 
    options = NULL
  ) {
  options <- h_prepare_mcmcoptions_list(n_chains, options)
  .ChainOptions(options_list = options)
}
```

For example

```{r}
#| label: initialiser-2
#| eval: TRUE
#| error: TRUE

ChainOptions()
```

## Legacy behaviour

```{r}
#| label: initialiser-3
#| eval: TRUE

# Legacy initialisation ----
v_legacy_chain_options <- function(object) {
  v <- v_chain_options(object)
  if (v) {
    v <- Validate()
  }
  params <- lapply(object@options_list, function(z) z@model_init)
  v$check(
    sum(duplicated.default(params)) == length(params) - 1L,
    "All elements of the options_list must have the same value in their model_init slots"
  )
  v$result()
}

.LegacyChainOptions <- setClass(
  Class = "LegacyChainOptions",
  contains = "ChainOptions",
  validity = v_legacy_chain_options
)

## constructor ----
LegacyChainOptions <- function(n_chains = 1, options = NULL) {
  options <- h_prepare_mcmcoptions_list(n_chains, options)
  .LegacyChainOptions(options_list = options)
}

LegacyChainOptions()
```

## New functionality

```{r}
#| label: initialiser-4
#| eval: TRUE

# Random initialisation ----
v_random_chain_options <- function(object) {
  v <- v_chain_options(object)
  if (v) {
    v <- Validate()
  }
  v$result()
}

.RandomChainOptions <- setClass(
  Class = "RandomChainOptions",
  contains = "ChainOptions",
  validity = v_random_chain_options
)

## constructor ----
RandomChainOptions <- function(n_chains = 1, options = NULL) {
  options <- h_prepare_mcmcoptions_list(n_chains, options)
  .RandomChainOptions(options_list = options)
}

RandomChainOptions(2)
```

## New style initialisation

Provide an initialisation method.  By separating the method from the class, we allow access to the option object's slots, which is helpful - not least because it allows us (and end users) to implement new functionality in the future without having to change the existing code base.  

```{r}
#| label: initialiser-5
#| eval: TRUE
#| output: false

setGeneric(
  name = "initialise",
  def = function(opts, model, ...) {
    standardGeneric("initialise")
  },
  valueClass = "ChainOptions"
)


```

Since the parent class does nothing, prevent its use - and provide a useful aide-memoire to developers.

```{r}
#| label: initialiser-5a
#| eval: TRUE
#| error: TRUE

setMethod(
  f = "initialise",
  signature = c("ChainOptions", "GeneralModel"),
  def = function(opts, model, n_chains = 1, ...) {
    stop("initialise must be implemented in a sub class.")
  }
)

initialise(ChainOptions(), .DefaultLogisticNormal())
```

### Legacy initialisation

Legacy initialisation becomes

```{r}
#| label: initialiser-6
#| eval: TRUE

setMethod(
  f = "initialise",
  signature = c("LegacyChainOptions", "GeneralModel"),
  def = function(opts, model, ...) {
    model_init <- model@init()
    names(model_init) <- names(model@init())
    for (i in seq_len(length(opts@options_list))) {
      opts@options_list[[i]]@model_init  <- model_init
      opts@options_list[[i]]@initialised <- TRUE
    }
    opts
  }
)

opts <- LegacyChainOptions()
opts <- initialise(opts, .DefaultLogisticLogNormal())
opts

opts1 <- LegacyChainOptions(2)
opts1 <- initialise(opts1, .DefaultLogisticLogNormal())
for (i in opts1@options_list) {
  print(paste0(names(i@model_init), ": ", paste0(i@model_init, collapse = " ")))
}

opts2 <- LegacyChainOptions(2, opts1@options_list)
opts2
```

### Random initialisation

Random initialisation is achieved so:

```{r}
#| label: initialiser-7
#| eval: TRUE
#| error: TRUE

setMethod(
  f = "initialise",
  signature = c("RandomChainOptions", "GeneralModel"),
  definition = function(opts, model, ...) {
    param_names <- names(model@init())
    opts@options_list <- lapply(
      opts@options_list, 
      function(z) {
        tmp <- mvtnorm::rmvnorm(1, model@params@mean, model@params@cov)[1, ]
        model_init <- list()
        model_init[[param_names]] <- tmp
        z@model_init <- model_init
        z@initialised <- TRUE
        z
      }
    )
    opts
  }
)

initialise(RandomChainOptions(), .DefaultLogisticLogNormal())
opts3 <- initialise(RandomChainOptions(n_chains = 3), .DefaultLogisticLogNormal())
for (i in opts3@options_list) {
  print(paste0(names(i@model_init), ": ", paste0(i@model_init, collapse = " ")))
}

```

### Other `ChainOptions` classes

Other `ChainOptions` might include

- `QuantileChainOptions`: starting values are chosen on the basis of equally-spaced quantiles of the prior
- `UserDefinedChainOptions`: user-defined starting values
- Etc

Now we have the infrastructure, we can start to use it, keeping in mind the need to avoid breaking changes.

## Modify the `mcmc` method

### Modified generic

> In what follows, I've temporarily removed value class checking to allow flexibility whilst adapting the `Samples` class to support multiple chains 

We need to modify the signature of `mcmc`, remembering the need to avoid breaking changes.  We could write:

#### Option 1

```{r}
#| label: mcmc-1
#| eval: TRUE
#| output: FALSE

setGeneric(
  name = "mcmc",
  def = function(data, model, options = NULL, initialiser = NULL, ...) {
    standardGeneric("mcmc")
  }
  # ,
  # valueClass = "Samples"
)
```

This separates the existing and new methodology, but allows the possibility of conflict between the `options` and `initialiser` arguments.  So, ideally, we'd also need a new stub.

```{r}
#| label: mcmc-1a
#| eval: TRUE
#| error: TRUE

setMethod(
  f = "mcmc",
  signature = signature(
    data = "GeneralData",
    model = "GeneralModel",
    options = "ANY",
    initialiser = "ANY"
  ),
  def = function(data,
                 model,
                 options,
                 initialiser,
                 from_prior = data@nObs == 0L,
                 ...) {
    stop("You cannot specify both options and initialiser in a call to mcmc")
  }
)

myModel <- LogisticLogNormal(
  mean = c(-0.85, 1),
  cov = matrix(c(1, -0.5, -0.5, 1), nrow = 2),
  ref_dose = 56
)
emptyData <- Data(doseGrid = c(1, 3, 5, 10, 15, 20, 25, 40, 50, 80, 100))

mcmc(emptyData, myModel, .DefaultMcmcOptions(), LegacyChainOptions())
```

#### Option 2

With a new helper function to convert between `McmcOptions` and `ChainOptions`, we could write:

```{r}
#| label: mcmc-1b
#| eval: FALSE

h_ensure_new_style_initialisation <- function(opts) {
  if (test_class(opts, "McmcOptions")) {
    lifecycle::deprecate_warn(
      paste0(
        "The McmcOptions class has been deprecated and will be removed in a ",
        "future version of crmPack.  Please use the ChainOptions class instead"
      )
    )
    tmp <- LegacyChainOptions()
    tmp <- initialise(tmp, opts)
    opts <- tmp
  }
  assert_class(opts, "ChainOptions")
  opts
}

setMethod(
  f = "mcmc",
  signature = signature(
    data = "GeneralData",
    model = "GeneralModel",
    options = "ANY"
  ),
  def = function(data,
                 model,
                 options,
                 from_prior = data@nObs == 0L,
                 ...) {
    options <- h_ensure_new_style_initilisation(options)
    ...
  }
)
```

This removes the need for a stub to check if both `initialiser` and `options` are specified.  I prefer this option.

```{r}
#| label: mcmc-1c
#| eval: TRUE
#| echo: FALSE

h_ensure_new_style_initialisation <- function(opts, model) {
  if (test_class(opts, "McmcOptions")) {
    lifecycle::deprecate_warn(
      when = "2.0",
      what = "crmPack::McmcOptions()",
      details = paste0(
        "The McmcOptions class has been deprecated and will be removed in a ",
        "future version of crmPack.  Please use the ChainOptions class instead"
      )
    )
    opts <- LegacyChainOptions()
    opts <- initialise(opts, model)
  }
  assert_class(opts, "ChainOptions")
  opts
}
```

### The `NewSamples` class

The `options` slot of the `Samples` class requires its value to be an `McmcOptions` class.  This will need to change.  As a temporary workaround, define a `NewSamples` class.

```{r}
#| label: new-samples-1
#| eval: TRUE

v_new_samples <- function(object) {
  v <- Validate()
  sapply(
    names(object@data),
    function(nm) {
      x <- object@data[[nm]]
      if (is.list(x)) {
        sapply(
          seq_len(length(x)),
          function(i) {
            v$check(
              NROW(x[[i]]) == (object@options@samples - object@options@burnin) / object@options@step,
              paste0(
                "Every element in data@",
                nm,
                "[chain [",
                i ,
                "] must be of the same length (no. of rows) as the original chain"              )
            )
            v$check(
              test_numeric(x[[i]], finite = TRUE, any.missing = FALSE),
              paste0("Every element in data@", nm, "[chain ", i ,"] must be a finite object of type integer or double")
            )
          }
        )       
      } else {
        expected <- dim(x)["iteration"]
        if (is.null(expected)) {
          expected <- length(x)
        }
        v$check(
          expected == round((object@options@samples - object@options@burnin) / object@options@step, 3),
          "Every element in data must be of the same length (no. of rows) as the sample size was"
        )
        v$check(
          all(sapply(object@data, test_numeric, finite = TRUE, any.missing = FALSE)),
          "Every element in data must be a finite object of type integer or double"
        )        
      }
    }
  )
  v$result()
}

.NewSamples <- setClass(
  Class = "NewSamples",
  slots = c(
    data = "list",
    options = "ChainOptions"
  ),
  prototype = prototype(
    data = list(),
    options = ChainOptions()
  ),
  contains = "CrmPackClass",
  validity = v_new_samples
)

NewSamples <- function(data, options) {
  new("NewSamples", data = data, options = options)
}

opt <- LegacyChainOptions()
jags_model <- rjags::jags.model(
  file = textConnection(
    "model {
       theta ~ dmnorm(mean, prec)
       alpha0 <- theta[1]
       alpha1 <- exp(theta[2])
    }"
  ),
  data = h_jags_get_data(myModel, emptyData, TRUE),
  inits = list(theta = c(0, 1)),
  n.adapt = 0
  )
jags_samples <- rjags::jags.samples(
  model = jags_model,
  variable.names = myModel@sample,
  n.iter = (opt@samples - opt@burnin),
  thin = opt@step
)

oneChain <- NewSamples(data = jags_samples, options = opt)
str(oneChain)
```

All looks good.

> The validation function for `NewSamples` could be simplified by requiring the `data` to be a `list` of `list`s, even
for a single chain.

What about multiple chains?

```{r}
#| label: new-samples-2
#| echo: TRUE

opt <- LegacyChainOptions(3)
jags_model <- rjags::jags.model(
  file = textConnection(
    "model {
       theta ~ dmnorm(mean, prec)
       alpha0 <- theta[1]
       alpha1 <- exp(theta[2])
    }"
  ),
  data = h_jags_get_data(myModel, emptyData, TRUE),
  inits = list(
    list(theta = c(0, 1)),
    list(theta = c(0, 1)),
    list(theta = c(0, 1))
  ),
  n.chains = 3,
  n.adapt = 0
  )
jags_samples <- rjags::jags.samples(
  model = jags_model,
  variable.names = myModel@sample,
  n.iter = (opt@samples - opt@burnin),
  thin = opt@step
)

threeChains <- NewSamples(data = jags_samples, options = opt)
str(threeChains)
```

That looks OK too.

### Modifying the `mcmc` method

#### Modify the `h_jags_extract_samples

`h_jags_extract_samples` needs to be rewritten because the current version hard codes the chain index to 1.

```{r}
#| label: mcmc-8
#| eval: TRUE

h_jags_extract_samples <- function(x) {
  assert_class(x, "mcarray")
  
  lapply(
    seq_len(dim(x)[3]),
    function(i) {
      z <- x[, , i]
      # In case that there are multiple parameters in a node.
      if (is.matrix(z)) {
        z <- t(z)
      }
      z
    }
  )
}
```

Now the `mcmc` method becomes:

```{r}
#| label: mcmc-2a
#| echo: TRUE

setMethod(
  f = "mcmc",
  signature = signature(
    data = "GeneralData",
    model = "GeneralModel",
    options = "ANY"
  ),
  def = function(data,
                 model,
                 options,
                 from_prior = data@nObs == 0L,
                 ...) {
    assert_flag(from_prior)
    options <- h_ensure_new_style_initialisation(options, model)
    model_fun <- if (from_prior) {
      model@priormodel
    } else {
      h_jags_join_models(model@datamodel, model@priormodel)
    }

    model_file <- h_jags_write_model(model_fun)
    local_options <- initialise(options, model)
    init_list <- lapply(
      local_options@options_list, 
      function(z) {
        rv <- z@model_init
        rv$.RNG.name <- h_null_if_na(z@rng_name)
        rv$.RNG.seed <- h_null_if_na(z@rng_seed)
        rv
      }
    )
    model_data <- h_jags_get_data(model, data, from_prior)
    jags_model <- rjags::jags.model(
      file = model_file,
      data = model_data,
      inits = init_list,
      quiet = !is_logging_enabled(),
      n.adapt = 0, # No adaptation. Important for reproducibility.
      n.chains = length(local_options@options_list)
    )
    update(jags_model, n.iter = local_options@burnin, progress.bar = "none")
    # This is necessary as some outputs are written directly from the JAGS
    # compiled code to the outstream.
    log_trace("Running rjags::jags.samples")
    if (is_logging_enabled()) {
      jags_samples <- rjags::jags.samples(
        model = jags_model,
        variable.names = model@sample,
        n.iter = (local_options@samples - local_options@burnin),
        thin = local_options@step
      )
    } else {
      invisible(
        capture.output(
          jags_samples <- rjags::jags.samples(
            model = jags_model,
            variable.names = model@sample,
            n.iter = (local_options@samples - local_options@burnin),
            thin = local_options@step,
            progress.bar = "none"
          )
        )
      )
    }
    log_trace("JAGS samples: ", jags_samples, capture = TRUE)
    samples <- lapply(jags_samples, h_jags_extract_samples)
    NewSamples(data = samples, options = local_options)
  }
)
```

#### Using `McmcOptions`

With the exception of the deprecation warning, calls using `McmcOptions` work exactly as they do at the moment.

```{r}
#| label: mcmc-3
#|echo: TRUE

oneChain <- mcmc(emptyData, myModel, .DefaultMcmcOptions())
str(oneChain)
```

#### Using `ChainOptions`

For example:

```{r}
#| label: mcmc-5
#| eval: TRUE
#| error: TRUE

threeChains <- mcmc(emptyData, myModel, options = LegacyChainOptions(3))

str(threeChains)
```

### `get-NewSamples` and `tidy-NewSamples`

I will take these out of order because they will simplify presentation and validation in later sections.

#### `get-NewSamples`

```{r}
#| label: get-NewSamples
#| eval: TRUE
#| error: TRUE

setMethod("get",
  signature =
    signature(
      x = "NewSamples",
      pos = "character",
      envir = "ANY",
      mode = "ANY",
      inherits = "ANY"
    ),
  def =
    function(x,
             pos,
             envir = NULL,
             mode = NULL,
             inherits = NULL) {
      ## check the parameter name
      assert_scalar(pos)
      assert_choice(pos, names(x@data))

      ## get the samples for this parameter
      rv <- lapply(
        seq_len(length(x@data[[pos]])),
        function(i) {
          d <- x@data[[pos]][[i]]
          ## this can be either a vector or a matrix

          ## how many parameters do we have?
          nPars <- NCOL(d)

          ## what are the names of all parameter
          ## elements?
          elements <-
            if (nPars == 1L) {
              pos
            } else {
              paste(pos,
                "[", seq_len(nPars), "]",
                sep = ""
              )
            }

          ## in case we have a vector parameter
          if (nPars > 1L) {
            ## what are the indices to be returned?
            indices <-
              if (is.null(envir)) {
                seq_along(elements)
              } else {
                assert_integer(envir)
                assert_subset(envir, seq_along(elements))
              }

            ## subset the data matrix and par names appropriately
            d <- d[, indices, drop = FALSE]
            elements <- elements[indices]

            ## and also reduce the number of parameters
            nPars <- length(indices)
          }

          ## now we can build
          ret <- data.frame(
            Iteration = seq_len(NROW(d)),
            Parameter =
              factor(rep(elements, each = NROW(d)),
               levels = elements
              ),
            value = as.numeric(d)
          )

          ## add the attributes
          ret <- structure(ret,
            nChains = as.integer(length(x@data)),
            nParameters = nPars,
            nIterations = x@options@samples,
            nBurnin = x@options@burnin,
            nThin = x@options@step,
            description = elements,
            parallel = FALSE
          )
        }
      ) %>% dplyr::bind_rows(.id = "Chain")
      return(rv)
    }
)

alpha0 <- threeChains %>% get("alpha0")

as_tibble(alpha0)

alpha0 %>% 
  group_by(Chain) %>% 
  group_walk(
    function(.x, .y) print(.x %>% head()),
    .keep = TRUE
  )
```

This appears to work as expected.

#### `tidy-NewSamples`

First, we need `tidy` methods for `RNGOptions` and `ChainOptions`.

#### `tidy-RNGOptions`

```{r}
#| label: tidy-NewRNGOptions
#| eval: TRUE
#| error: TRUE

setMethod(
  f = "tidy",
  signature = signature(x = "RNGOptions"),
  definition = function(x, ...) {
    tibble(
      model_init = list(x@model_init),
      rng_name = x@rng_name,
      rng_seed = x@rng_seed,
      initialised = x@initialised
    ) %>% crmPack:::h_tidy_class(x)
  }
)

tidy(RNGOptions())
```

#### `tidy-ChainOptions`

```{r}
#| label: tidy-ChainOptions
#| eval: TRUE
#| error: TRUE

setMethod(
  f = "tidy",
  signature = signature(x = "ChainOptions"),
  definition = function(x, ...) {
    tibble(
      burnin = x@burnin,
      step = x@step,
      samples = x@samples
    ) %>%
    dplyr::bind_rows(
      lapply(
        seq_len(length(x@options_list)), 
        function(i) tidy(x@options_list[[i]]) %>% tibble::add_column(Chain = i) 
      )
    ) %>% crmPack:::h_tidy_class(x)
  }
)

LegacyChainOptions(3) %>%  tidy()
```

Now we can proceed.

```{r}
#| label: tidy-NewSamples
#| eval: TRUE
#| error: TRUE

setMethod(
  f = "tidy",
  signature = signature(x = "NewSamples"),
  definition = function(x, ...) {
    rv <- lapply(
      slotNames(x),
      function(nm) {
        if (nm == "data") {
          lapply(
            names(x@data),
            function(nm) {
              get(x, nm) %>% dplyr::bind_rows()
            }
          ) %>%
            dplyr::bind_rows() %>%
            tidyr::pivot_wider(
              names_from = Parameter,
              values_from = value
            ) %>%
            dplyr::bind_cols(crmPack:::h_handle_attributes(get(x, names(x@data)[1])))
        } else {
          slot(x, nm) %>%
            tidy() %>%
            dplyr::bind_cols()
        }
      }
    )
    names(rv) <- c("data", "options")
    rv <- rv %>% crmPack:::h_tidy_class(x)
    rv
  }
)
threeChains %>% tidy()
```



# Downstream adaptations

The following methods and classes reference the Samples class and are not discussed above.  They may need modification.  There are probably more.

- `Design-simulate`
- `Model-dose`
- `Model-prob`
- `Model-efficacy`
- `Model-biomarker`
- `NextBest-nextBest`
- `NextBest-stopTrial`
- `Samples-approximate`
- `Samples-fit`
- `Samples-fitGain`
- `Samples-fitPEM`
- `Samples-names`
- `Samples-plot`
- `Samples-plotGain`
- `Samples-plotDualResponses`
- `Samples-size`
